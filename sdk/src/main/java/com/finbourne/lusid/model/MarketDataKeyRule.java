/*
 * LUSID API
 *
 * Contact: info@finbourne.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

package com.finbourne.lusid.model;

import java.util.Objects;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;
import java.time.OffsetDateTime;
import java.util.Arrays;
import org.openapitools.jackson.nullable.JsonNullable;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonArray;
import com.google.gson.JsonDeserializationContext;
import com.google.gson.JsonDeserializer;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParseException;
import com.google.gson.TypeAdapterFactory;
import com.google.gson.reflect.TypeToken;
import com.google.gson.TypeAdapter;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;

import java.lang.reflect.Type;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Map.Entry;
import java.util.Set;

import com.finbourne.lusid.JSON;

/**
 * When performing analytics, instruments and models have dependencies on market data.  A market data key rule essentially tells lusid to \&quot;resolve dependencies matching the pattern &#39;X&#39; using data of the form &#39;Y&#39;\&quot;.  The parameter &#39;X&#39; is defined by the key of the key rule, and might specify \&quot;all USD rates curves\&quot; or \&quot;all RIC-based prices\&quot;.  The parameter &#39;Y&#39; is defined by the remaining fields of the key rule, and allows the user to configure things such as  where to look for data, what sort of data should be looked for (e.g. bid/mid/ask), and how old the data is allowed to be.
 */
@jakarta.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen")
public class MarketDataKeyRule {
  public static final String SERIALIZED_NAME_KEY = "key";
  @SerializedName(SERIALIZED_NAME_KEY)
  private String key;

  public static final String SERIALIZED_NAME_SUPPLIER = "supplier";
  @SerializedName(SERIALIZED_NAME_SUPPLIER)
  private String supplier;

  public static final String SERIALIZED_NAME_DATA_SCOPE = "dataScope";
  @SerializedName(SERIALIZED_NAME_DATA_SCOPE)
  private String dataScope;

  /**
   * The available values are: Price, Spread, Rate, LogNormalVol, NormalVol, ParSpread, IsdaSpread, Upfront, Index, Ratio, Delta, PoolFactor, InflationAssumption, DirtyPrice
   */
  @JsonAdapter(QuoteTypeEnum.Adapter.class)
  public enum QuoteTypeEnum {
    PRICE("Price"),
    
    SPREAD("Spread"),
    
    RATE("Rate"),
    
    LOGNORMALVOL("LogNormalVol"),
    
    NORMALVOL("NormalVol"),
    
    PARSPREAD("ParSpread"),
    
    ISDASPREAD("IsdaSpread"),
    
    UPFRONT("Upfront"),
    
    INDEX("Index"),
    
    RATIO("Ratio"),
    
    DELTA("Delta"),
    
    POOLFACTOR("PoolFactor"),
    
    INFLATIONASSUMPTION("InflationAssumption"),
    
    DIRTYPRICE("DirtyPrice");

    private String value;

    QuoteTypeEnum(String value) {
      this.value = value;
    }

    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }

    public static QuoteTypeEnum fromValue(String value) {
      for (QuoteTypeEnum b : QuoteTypeEnum.values()) {
        if (b.value.equals(value)) {
          return b;
        }
      }
      throw new IllegalArgumentException("Unexpected value '" + value + "'");
    }

    public static class Adapter extends TypeAdapter<QuoteTypeEnum> {
      @Override
      public void write(final JsonWriter jsonWriter, final QuoteTypeEnum enumeration) throws IOException {
        jsonWriter.value(enumeration.getValue());
      }

      @Override
      public QuoteTypeEnum read(final JsonReader jsonReader) throws IOException {
        String value =  jsonReader.nextString();
        return QuoteTypeEnum.fromValue(value);
      }
    }
  }

  public static final String SERIALIZED_NAME_QUOTE_TYPE = "quoteType";
  @SerializedName(SERIALIZED_NAME_QUOTE_TYPE)
  private QuoteTypeEnum quoteType;

  public static final String SERIALIZED_NAME_FIELD = "field";
  @SerializedName(SERIALIZED_NAME_FIELD)
  private String field;

  public static final String SERIALIZED_NAME_QUOTE_INTERVAL = "quoteInterval";
  @SerializedName(SERIALIZED_NAME_QUOTE_INTERVAL)
  private String quoteInterval;

  public static final String SERIALIZED_NAME_AS_AT = "asAt";
  @SerializedName(SERIALIZED_NAME_AS_AT)
  private OffsetDateTime asAt;

  public static final String SERIALIZED_NAME_PRICE_SOURCE = "priceSource";
  @SerializedName(SERIALIZED_NAME_PRICE_SOURCE)
  private String priceSource;

  public static final String SERIALIZED_NAME_MASK = "mask";
  @SerializedName(SERIALIZED_NAME_MASK)
  private String mask;

  public static final String SERIALIZED_NAME_SOURCE_SYSTEM = "sourceSystem";
  @SerializedName(SERIALIZED_NAME_SOURCE_SYSTEM)
  private String sourceSystem;

  public MarketDataKeyRule() {
  }

  public MarketDataKeyRule key(String key) {
    
    this.key = key;
    return this;
  }

   /**
   * A dot-separated string that defines a pattern for matching market data dependencies.  The form of the string depends on the type of the dependency; see below for basic types and the Knowledge Base for further info.  Quote lookup: \&quot;Quote.{CodeType}.*\&quot; e.g. \&quot;Quote.RIC.*\&quot; refers to &#39;any RIC quote&#39;  Fx rates: \&quot;Fx.CurrencyPair.*\&quot;, which refers to &#39;any FX rate&#39;  Discounting curves: \&quot;Rates.{Currency}.{Currency}OIS e.g. \&quot;Rates.USD.USDOIS\&quot; refers to the OIS USD discounting curve                For non-fx and non-quote rules, trailing parameters can be replaced by the wildcard character &#39;*&#39;.  e.g. \&quot;Rates.*.*\&quot; matches any dependency on a discounting curve.
   * @return key
  **/
  @jakarta.annotation.Nonnull
  public String getKey() {
    return key;
  }


  public void setKey(String key) {
    this.key = key;
  }


  public MarketDataKeyRule supplier(String supplier) {
    
    this.supplier = supplier;
    return this;
  }

   /**
   * The market data supplier (where the data comes from)
   * @return supplier
  **/
  @jakarta.annotation.Nonnull
  public String getSupplier() {
    return supplier;
  }


  public void setSupplier(String supplier) {
    this.supplier = supplier;
  }


  public MarketDataKeyRule dataScope(String dataScope) {
    
    this.dataScope = dataScope;
    return this;
  }

   /**
   * The scope in which the data should be found when using this rule.
   * @return dataScope
  **/
  @jakarta.annotation.Nonnull
  public String getDataScope() {
    return dataScope;
  }


  public void setDataScope(String dataScope) {
    this.dataScope = dataScope;
  }


  public MarketDataKeyRule quoteType(QuoteTypeEnum quoteType) {
    
    this.quoteType = quoteType;
    return this;
  }

   /**
   * The available values are: Price, Spread, Rate, LogNormalVol, NormalVol, ParSpread, IsdaSpread, Upfront, Index, Ratio, Delta, PoolFactor, InflationAssumption, DirtyPrice
   * @return quoteType
  **/
  @jakarta.annotation.Nonnull
  public QuoteTypeEnum getQuoteType() {
    return quoteType;
  }


  public void setQuoteType(QuoteTypeEnum quoteType) {
    this.quoteType = quoteType;
  }


  public MarketDataKeyRule field(String field) {
    
    this.field = field;
    return this;
  }

   /**
   * The conceptual qualification for the field, typically &#39;bid&#39;, &#39;mid&#39; (default), or &#39;ask&#39;, but can also be &#39;open&#39;, &#39;close&#39;, etc.  When resolving quotes from LUSID&#39;s database, only quotes whose Field is identical to the Field specified here  will be accepted as market data.  When resolving data from an external supplier, the Field must be one of a defined set for the given supplier.                Note: Applies to the retrieval of quotes only. Has no impact on the resolution of complex market data.
   * @return field
  **/
  @jakarta.annotation.Nullable
  public String getField() {
    return field;
  }


  public void setField(String field) {
    this.field = field;
  }


  public MarketDataKeyRule quoteInterval(String quoteInterval) {
    
    this.quoteInterval = quoteInterval;
    return this;
  }

   /**
   * Shorthand for the time interval used to select market data. This must be a dot-separated string              nominating a start and end date, for example &#39;5D.0D&#39; to look back 5 days from today (0 days ago). The syntax              is &lt;i&gt;int&lt;/i&gt;&lt;i&gt;char&lt;/i&gt;.&lt;i&gt;int&lt;/i&gt;&lt;i&gt;char&lt;/i&gt;, where &lt;i&gt;char&lt;/i&gt; is one of              D(ay), Bd(business day), W(eek), M(onth) or Y(ear).              Business days are calculated using the calendars specified on the Valuation Request.              If no calendar is provided in the request, then it will default to only skipping weekends.              For example, if the valuation date is a Monday, then a quote interval of \&quot;1Bd\&quot; would behave as \&quot;3D\&quot;,              looking back to the Friday. Data with effectiveAt on the weekend will still be found in that window.
   * @return quoteInterval
  **/
  @jakarta.annotation.Nullable
  public String getQuoteInterval() {
    return quoteInterval;
  }


  public void setQuoteInterval(String quoteInterval) {
    this.quoteInterval = quoteInterval;
  }


  public MarketDataKeyRule asAt(OffsetDateTime asAt) {
    
    this.asAt = asAt;
    return this;
  }

   /**
   * The AsAt predicate specification.
   * @return asAt
  **/
  @jakarta.annotation.Nullable
  public OffsetDateTime getAsAt() {
    return asAt;
  }


  public void setAsAt(OffsetDateTime asAt) {
    this.asAt = asAt;
  }


  public MarketDataKeyRule priceSource(String priceSource) {
    
    this.priceSource = priceSource;
    return this;
  }

   /**
   * The source of the quote. For a given provider/supplier of market data there may be an additional qualifier, e.g. the exchange or bank that provided the quote
   * @return priceSource
  **/
  @jakarta.annotation.Nullable
  public String getPriceSource() {
    return priceSource;
  }


  public void setPriceSource(String priceSource) {
    this.priceSource = priceSource;
  }


  public MarketDataKeyRule mask(String mask) {
    
    this.mask = mask;
    return this;
  }

   /**
   * Allows for partial or complete override of the market asset resolved for a dependency  Either a named override or a dot separated string (A.B.C.D.*).  e.g. for Rates curve &#39;EUR.*&#39; will replace the resolve MarketAsset &#39;GBP/12M&#39;, &#39;GBP/3M&#39; with the EUR equivalent, if there  are no wildcards in the mask, the mask is taken as the MarketAsset for any dependency matching the rule.
   * @return mask
  **/
  @jakarta.annotation.Nullable
  public String getMask() {
    return mask;
  }


  public void setMask(String mask) {
    this.mask = mask;
  }


  public MarketDataKeyRule sourceSystem(String sourceSystem) {
    
    this.sourceSystem = sourceSystem;
    return this;
  }

   /**
   * If set, this parameter will seek an external source of market data.  Optional and, if omitted, will default to \&quot;Lusid\&quot;.  This means that data will be retrieved from the LUSID Quote Store and LUSID Complex Market Data Store.                This can be set to \&quot;MarketDataOverrides\&quot; if Supplier is set to \&quot;Client\&quot;.
   * @return sourceSystem
  **/
  @jakarta.annotation.Nullable
  public String getSourceSystem() {
    return sourceSystem;
  }


  public void setSourceSystem(String sourceSystem) {
    this.sourceSystem = sourceSystem;
  }



  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    MarketDataKeyRule marketDataKeyRule = (MarketDataKeyRule) o;
    return Objects.equals(this.key, marketDataKeyRule.key) &&
        Objects.equals(this.supplier, marketDataKeyRule.supplier) &&
        Objects.equals(this.dataScope, marketDataKeyRule.dataScope) &&
        Objects.equals(this.quoteType, marketDataKeyRule.quoteType) &&
        Objects.equals(this.field, marketDataKeyRule.field) &&
        Objects.equals(this.quoteInterval, marketDataKeyRule.quoteInterval) &&
        Objects.equals(this.asAt, marketDataKeyRule.asAt) &&
        Objects.equals(this.priceSource, marketDataKeyRule.priceSource) &&
        Objects.equals(this.mask, marketDataKeyRule.mask) &&
        Objects.equals(this.sourceSystem, marketDataKeyRule.sourceSystem);
  }

  private static <T> boolean equalsNullable(JsonNullable<T> a, JsonNullable<T> b) {
    return a == b || (a != null && b != null && a.isPresent() && b.isPresent() && Objects.deepEquals(a.get(), b.get()));
  }

  @Override
  public int hashCode() {
    return Objects.hash(key, supplier, dataScope, quoteType, field, quoteInterval, asAt, priceSource, mask, sourceSystem);
  }

  private static <T> int hashCodeNullable(JsonNullable<T> a) {
    if (a == null) {
      return 1;
    }
    return a.isPresent() ? Arrays.deepHashCode(new Object[]{a.get()}) : 31;
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class MarketDataKeyRule {\n");
    sb.append("    key: ").append(toIndentedString(key)).append("\n");
    sb.append("    supplier: ").append(toIndentedString(supplier)).append("\n");
    sb.append("    dataScope: ").append(toIndentedString(dataScope)).append("\n");
    sb.append("    quoteType: ").append(toIndentedString(quoteType)).append("\n");
    sb.append("    field: ").append(toIndentedString(field)).append("\n");
    sb.append("    quoteInterval: ").append(toIndentedString(quoteInterval)).append("\n");
    sb.append("    asAt: ").append(toIndentedString(asAt)).append("\n");
    sb.append("    priceSource: ").append(toIndentedString(priceSource)).append("\n");
    sb.append("    mask: ").append(toIndentedString(mask)).append("\n");
    sb.append("    sourceSystem: ").append(toIndentedString(sourceSystem)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }


  public static HashSet<String> openapiFields;
  public static HashSet<String> openapiRequiredFields;

  static {
    // a set of all properties/fields (JSON key names)
    openapiFields = new HashSet<String>();
    openapiFields.add("key");
    openapiFields.add("supplier");
    openapiFields.add("dataScope");
    openapiFields.add("quoteType");
    openapiFields.add("field");
    openapiFields.add("quoteInterval");
    openapiFields.add("asAt");
    openapiFields.add("priceSource");
    openapiFields.add("mask");
    openapiFields.add("sourceSystem");

    // a set of required properties/fields (JSON key names)
    openapiRequiredFields = new HashSet<String>();
    openapiRequiredFields.add("key");
    openapiRequiredFields.add("supplier");
    openapiRequiredFields.add("dataScope");
    openapiRequiredFields.add("quoteType");
  }

 /**
  * Validates the JSON Object and throws an exception if issues found
  *
  * @param jsonObj JSON Object
  * @throws IOException if the JSON Object is invalid with respect to MarketDataKeyRule
  */
  public static void validateJsonObject(JsonObject jsonObj) throws IOException {
      if (jsonObj == null) {
        if (!MarketDataKeyRule.openapiRequiredFields.isEmpty()) { // has required fields but JSON object is null
          throw new IllegalArgumentException(String.format("The required field(s) %s in MarketDataKeyRule is not found in the empty JSON string", MarketDataKeyRule.openapiRequiredFields.toString()));
        }
      }

      Set<Entry<String, JsonElement>> entries = jsonObj.entrySet();
      // check to see if the JSON string contains additional fields
      for (Entry<String, JsonElement> entry : entries) {
        if (!MarketDataKeyRule.openapiFields.contains(entry.getKey())) {
          throw new IllegalArgumentException(String.format("The field `%s` in the JSON string is not defined in the `MarketDataKeyRule` properties. JSON: %s", entry.getKey(), jsonObj.toString()));
        }
      }

      // check to make sure all required properties/fields are present in the JSON string
      for (String requiredField : MarketDataKeyRule.openapiRequiredFields) {
        if (jsonObj.get(requiredField) == null) {
          throw new IllegalArgumentException(String.format("The required field `%s` is not found in the JSON string: %s", requiredField, jsonObj.toString()));
        }
      }
      if (!jsonObj.get("key").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `key` to be a primitive type in the JSON string but got `%s`", jsonObj.get("key").toString()));
      }
      if (!jsonObj.get("supplier").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `supplier` to be a primitive type in the JSON string but got `%s`", jsonObj.get("supplier").toString()));
      }
      if (!jsonObj.get("dataScope").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `dataScope` to be a primitive type in the JSON string but got `%s`", jsonObj.get("dataScope").toString()));
      }
      if (!jsonObj.get("quoteType").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `quoteType` to be a primitive type in the JSON string but got `%s`", jsonObj.get("quoteType").toString()));
      }
      if ((jsonObj.get("field") != null && !jsonObj.get("field").isJsonNull()) && !jsonObj.get("field").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `field` to be a primitive type in the JSON string but got `%s`", jsonObj.get("field").toString()));
      }
      if ((jsonObj.get("quoteInterval") != null && !jsonObj.get("quoteInterval").isJsonNull()) && !jsonObj.get("quoteInterval").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `quoteInterval` to be a primitive type in the JSON string but got `%s`", jsonObj.get("quoteInterval").toString()));
      }
      if ((jsonObj.get("priceSource") != null && !jsonObj.get("priceSource").isJsonNull()) && !jsonObj.get("priceSource").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `priceSource` to be a primitive type in the JSON string but got `%s`", jsonObj.get("priceSource").toString()));
      }
      if ((jsonObj.get("mask") != null && !jsonObj.get("mask").isJsonNull()) && !jsonObj.get("mask").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `mask` to be a primitive type in the JSON string but got `%s`", jsonObj.get("mask").toString()));
      }
      if ((jsonObj.get("sourceSystem") != null && !jsonObj.get("sourceSystem").isJsonNull()) && !jsonObj.get("sourceSystem").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `sourceSystem` to be a primitive type in the JSON string but got `%s`", jsonObj.get("sourceSystem").toString()));
      }
  }

  public static class CustomTypeAdapterFactory implements TypeAdapterFactory {
    @SuppressWarnings("unchecked")
    @Override
    public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {
       if (!MarketDataKeyRule.class.isAssignableFrom(type.getRawType())) {
         return null; // this class only serializes 'MarketDataKeyRule' and its subtypes
       }
       final TypeAdapter<JsonElement> elementAdapter = gson.getAdapter(JsonElement.class);
       final TypeAdapter<MarketDataKeyRule> thisAdapter
                        = gson.getDelegateAdapter(this, TypeToken.get(MarketDataKeyRule.class));

       return (TypeAdapter<T>) new TypeAdapter<MarketDataKeyRule>() {
           @Override
           public void write(JsonWriter out, MarketDataKeyRule value) throws IOException {
             JsonObject obj = thisAdapter.toJsonTree(value).getAsJsonObject();
             elementAdapter.write(out, obj);
           }

           @Override
           public MarketDataKeyRule read(JsonReader in) throws IOException {
             JsonObject jsonObj = elementAdapter.read(in).getAsJsonObject();
             validateJsonObject(jsonObj);
             return thisAdapter.fromJsonTree(jsonObj);
           }

       }.nullSafe();
    }
  }

 /**
  * Create an instance of MarketDataKeyRule given an JSON string
  *
  * @param jsonString JSON string
  * @return An instance of MarketDataKeyRule
  * @throws IOException if the JSON string is invalid with respect to MarketDataKeyRule
  */
  public static MarketDataKeyRule fromJson(String jsonString) throws IOException {
    return JSON.getGson().fromJson(jsonString, MarketDataKeyRule.class);
  }

 /**
  * Convert an instance of MarketDataKeyRule to an JSON string
  *
  * @return JSON string
  */
  public String toJson() {
    return JSON.getGson().toJson(this);
  }
}
