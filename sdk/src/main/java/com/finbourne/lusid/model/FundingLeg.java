/*
 * LUSID API
 *
 * Contact: info@finbourne.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

package com.finbourne.lusid.model;

import java.util.Objects;
import com.finbourne.lusid.model.InstrumentLeg;
import com.finbourne.lusid.model.LegDefinition;
import com.finbourne.lusid.model.TimeZoneConventions;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;
import java.time.OffsetDateTime;
import java.util.Arrays;
import org.openapitools.jackson.nullable.JsonNullable;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonArray;
import com.google.gson.JsonDeserializationContext;
import com.google.gson.JsonDeserializer;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParseException;
import com.google.gson.TypeAdapterFactory;
import com.google.gson.reflect.TypeToken;
import com.google.gson.TypeAdapter;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;

import java.lang.reflect.Type;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Map.Entry;
import java.util.Set;

import com.finbourne.lusid.JSON;

/**
 * LUSID representation of a Funding Leg with variable notional.  This Funding Leg is a hybrid between a single leg swap and a loan facility; the notional is not fixed and can vary within a reset period.    The model can be used to represent the funding leg of a basket of instruments (e.g. equities) where the contents of the basket can change over time. The actual notional history is stored in the FundingLegHistory object.   The actual notional history is stored in the FundingLegHistory object.   The main analytic calculated for this instrument is Accrual rather than PV.
 */
@jakarta.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen")
public class FundingLeg extends InstrumentLeg {
  public static final String SERIALIZED_NAME_START_DATE = "startDate";
  @SerializedName(SERIALIZED_NAME_START_DATE)
  private OffsetDateTime startDate;

  public static final String SERIALIZED_NAME_MATURITY_DATE = "maturityDate";
  @SerializedName(SERIALIZED_NAME_MATURITY_DATE)
  private OffsetDateTime maturityDate;

  public static final String SERIALIZED_NAME_LEG_DEFINITION = "legDefinition";
  @SerializedName(SERIALIZED_NAME_LEG_DEFINITION)
  private LegDefinition legDefinition;

  public static final String SERIALIZED_NAME_NOTIONAL = "notional";
  @SerializedName(SERIALIZED_NAME_NOTIONAL)
  private java.math.BigDecimal notional;

  public static final String SERIALIZED_NAME_TIME_ZONE_CONVENTIONS = "timeZoneConventions";
  @SerializedName(SERIALIZED_NAME_TIME_ZONE_CONVENTIONS)
  private TimeZoneConventions timeZoneConventions;

  public FundingLeg() {
    // this.instrumentType = this.getClass().getSimpleName();
  }

  public FundingLeg startDate(OffsetDateTime startDate) {
    
    this.startDate = startDate;
    return this;
  }

   /**
   * The start date of the instrument. This is normally synonymous with the trade-date.
   * @return startDate
  **/
  @jakarta.annotation.Nonnull
  public OffsetDateTime getStartDate() {
    return startDate;
  }


  public void setStartDate(OffsetDateTime startDate) {
    this.startDate = startDate;
  }


  public FundingLeg maturityDate(OffsetDateTime maturityDate) {
    
    this.maturityDate = maturityDate;
    return this;
  }

   /**
   * The final maturity date of the instrument. This means the last date on which the instruments makes a payment of any amount. For the avoidance of doubt, that is not necessarily prior to its last sensitivity date for the purposes of risk; e.g. instruments such as Constant Maturity Swaps (CMS) often have sensitivities to rates beyond their last payment date.
   * @return maturityDate
  **/
  @jakarta.annotation.Nonnull
  public OffsetDateTime getMaturityDate() {
    return maturityDate;
  }


  public void setMaturityDate(OffsetDateTime maturityDate) {
    this.maturityDate = maturityDate;
  }


  public FundingLeg legDefinition(LegDefinition legDefinition) {
    
    this.legDefinition = legDefinition;
    return this;
  }

   /**
   * Get legDefinition
   * @return legDefinition
  **/
  @jakarta.annotation.Nonnull
  public LegDefinition getLegDefinition() {
    return legDefinition;
  }


  public void setLegDefinition(LegDefinition legDefinition) {
    this.legDefinition = legDefinition;
  }


  public FundingLeg notional(java.math.BigDecimal notional) {
    
    this.notional = notional;
    return this;
  }

   /**
   * The initial notional of the Funding Leg instrument. When \&quot;RequiresFundingLegHistory\&quot; property key is present in transaction key, during a GetValuation endpoint call (for instance), this field would overriden by the Funding Leg history&#39;s notional and this notional field would not be used in the pricing and accrual calculations. As such, we recommend setting this to 0 or not setting it at all. Please see the following Notebook example and Knowledge Base article: Notebook: https://github.com/finbourne/sample-notebooks/blob/master/examples/use-cases/instruments/Funding%20Leg%20Swap.ipynb Knowledge Base article: https://support.lusid.com/knowledgebase/article/KA-01764/
   * @return notional
  **/
  @jakarta.annotation.Nullable
  public java.math.BigDecimal getNotional() {
    return notional;
  }


  public void setNotional(java.math.BigDecimal notional) {
    this.notional = notional;
  }


  public FundingLeg timeZoneConventions(TimeZoneConventions timeZoneConventions) {
    
    this.timeZoneConventions = timeZoneConventions;
    return this;
  }

   /**
   * Get timeZoneConventions
   * @return timeZoneConventions
  **/
  @jakarta.annotation.Nullable
  public TimeZoneConventions getTimeZoneConventions() {
    return timeZoneConventions;
  }


  public void setTimeZoneConventions(TimeZoneConventions timeZoneConventions) {
    this.timeZoneConventions = timeZoneConventions;
  }



  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    FundingLeg fundingLeg = (FundingLeg) o;
    return Objects.equals(this.startDate, fundingLeg.startDate) &&
        Objects.equals(this.maturityDate, fundingLeg.maturityDate) &&
        Objects.equals(this.legDefinition, fundingLeg.legDefinition) &&
        (this.notional.compareTo(fundingLeg.getNotional()) == 0) &&
        Objects.equals(this.timeZoneConventions, fundingLeg.timeZoneConventions) &&
        super.equals(o);
  }

  private static <T> boolean equalsNullable(JsonNullable<T> a, JsonNullable<T> b) {
    return a == b || (a != null && b != null && a.isPresent() && b.isPresent() && Objects.deepEquals(a.get(), b.get()));
  }

  @Override
  public int hashCode() {
    return Objects.hash(startDate, maturityDate, legDefinition, notional, timeZoneConventions, super.hashCode());
  }

  private static <T> int hashCodeNullable(JsonNullable<T> a) {
    if (a == null) {
      return 1;
    }
    return a.isPresent() ? Arrays.deepHashCode(new Object[]{a.get()}) : 31;
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class FundingLeg {\n");
    sb.append("    ").append(toIndentedString(super.toString())).append("\n");
    sb.append("    startDate: ").append(toIndentedString(startDate)).append("\n");
    sb.append("    maturityDate: ").append(toIndentedString(maturityDate)).append("\n");
    sb.append("    legDefinition: ").append(toIndentedString(legDefinition)).append("\n");
    sb.append("    notional: ").append(toIndentedString(notional)).append("\n");
    sb.append("    timeZoneConventions: ").append(toIndentedString(timeZoneConventions)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }


  public static HashSet<String> openapiFields;
  public static HashSet<String> openapiRequiredFields;

  static {
    // a set of all properties/fields (JSON key names)
    openapiFields = new HashSet<String>();
    openapiFields.add("instrumentType");
    openapiFields.add("startDate");
    openapiFields.add("maturityDate");
    openapiFields.add("legDefinition");
    openapiFields.add("notional");
    openapiFields.add("timeZoneConventions");

    // a set of required properties/fields (JSON key names)
    openapiRequiredFields = new HashSet<String>();
    openapiRequiredFields.add("startDate");
    openapiRequiredFields.add("maturityDate");
    openapiRequiredFields.add("legDefinition");
    openapiRequiredFields.add("instrumentType");
  }

 /**
  * Validates the JSON Element and throws an exception if issues found
  *
  * @param jsonElement JSON Element
  * @throws IOException if the JSON Element is invalid with respect to FundingLeg
  */
  public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      if (jsonElement == null) {
        if (!FundingLeg.openapiRequiredFields.isEmpty()) { // has required fields but JSON element is null
          throw new IllegalArgumentException(String.format("The required field(s) %s in FundingLeg is not found in the empty JSON string", FundingLeg.openapiRequiredFields.toString()));
        }
      }

      // check to make sure all required properties/fields are present in the JSON string
      for (String requiredField : FundingLeg.openapiRequiredFields) {
        if (jsonElement.getAsJsonObject().get(requiredField) == null) {
          throw new IllegalArgumentException(String.format("The required field `%s` is not found in the JSON string: %s", requiredField, jsonElement.toString()));
        }
      }
  }

  public static class CustomTypeAdapterFactory implements TypeAdapterFactory {
    @SuppressWarnings("unchecked")
    @Override
    public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {
       if (!FundingLeg.class.isAssignableFrom(type.getRawType())) {
         return null; // this class only serializes 'FundingLeg' and its subtypes
       }
       final TypeAdapter<JsonElement> elementAdapter = gson.getAdapter(JsonElement.class);
       final TypeAdapter<FundingLeg> thisAdapter
                        = gson.getDelegateAdapter(this, TypeToken.get(FundingLeg.class));

       return (TypeAdapter<T>) new TypeAdapter<FundingLeg>() {
           @Override
           public void write(JsonWriter out, FundingLeg value) throws IOException {
             JsonObject obj = thisAdapter.toJsonTree(value).getAsJsonObject();
             elementAdapter.write(out, obj);
           }

           @Override
           public FundingLeg read(JsonReader in) throws IOException {
             JsonElement jsonElement = elementAdapter.read(in);
             validateJsonElement(jsonElement);
             return thisAdapter.fromJsonTree(jsonElement);
           }

       }.nullSafe();
    }
  }

 /**
  * Create an instance of FundingLeg given an JSON string
  *
  * @param jsonString JSON string
  * @return An instance of FundingLeg
  * @throws IOException if the JSON string is invalid with respect to FundingLeg
  */
  public static FundingLeg fromJson(String jsonString) throws IOException {
    return JSON.getGson().fromJson(jsonString, FundingLeg.class);
  }

 /**
  * Convert an instance of FundingLeg to an JSON string
  *
  * @return JSON string
  */
  public String toJson() {
    return JSON.getGson().toJson(this);
  }
}
