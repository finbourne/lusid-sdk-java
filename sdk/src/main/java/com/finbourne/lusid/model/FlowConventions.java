/*
 * LUSID API
 *
 * Contact: info@finbourne.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

package com.finbourne.lusid.model;

import java.util.Objects;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import org.openapitools.jackson.nullable.JsonNullable;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonArray;
import com.google.gson.JsonDeserializationContext;
import com.google.gson.JsonDeserializer;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParseException;
import com.google.gson.TypeAdapterFactory;
import com.google.gson.reflect.TypeToken;
import com.google.gson.TypeAdapter;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;

import java.lang.reflect.Type;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Map.Entry;
import java.util.Set;

import com.finbourne.lusid.JSON;

/**
 * A flow convention defines the specification for generation of the date schedule for a leg or set of cashflows.  It determines the tenor of these and, how to map the unadjusted set of dates to dates which are &#39;good business  days&#39;. For example, if an unadjusted date falls on a Saturday or a bank holiday, should it be rolled forward  or backward to obtain the adjusted date.  For more information, see https://support.lusid.com/knowledgebase/article/KA-02055/
 */
@jakarta.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen")
public class FlowConventions {
  public static final String SERIALIZED_NAME_CURRENCY = "currency";
  @SerializedName(SERIALIZED_NAME_CURRENCY)
  private String currency;

  public static final String SERIALIZED_NAME_PAYMENT_FREQUENCY = "paymentFrequency";
  @SerializedName(SERIALIZED_NAME_PAYMENT_FREQUENCY)
  private String paymentFrequency;

  public static final String SERIALIZED_NAME_DAY_COUNT_CONVENTION = "dayCountConvention";
  @SerializedName(SERIALIZED_NAME_DAY_COUNT_CONVENTION)
  private String dayCountConvention;

  public static final String SERIALIZED_NAME_ROLL_CONVENTION = "rollConvention";
  @SerializedName(SERIALIZED_NAME_ROLL_CONVENTION)
  private String rollConvention;

  public static final String SERIALIZED_NAME_PAYMENT_CALENDARS = "paymentCalendars";
  @SerializedName(SERIALIZED_NAME_PAYMENT_CALENDARS)
  private List<String> paymentCalendars = new ArrayList<>();

  public static final String SERIALIZED_NAME_RESET_CALENDARS = "resetCalendars";
  @SerializedName(SERIALIZED_NAME_RESET_CALENDARS)
  private List<String> resetCalendars = new ArrayList<>();

  public static final String SERIALIZED_NAME_SETTLE_DAYS = "settleDays";
  @SerializedName(SERIALIZED_NAME_SETTLE_DAYS)
  private Integer settleDays;

  public static final String SERIALIZED_NAME_RESET_DAYS = "resetDays";
  @SerializedName(SERIALIZED_NAME_RESET_DAYS)
  private Integer resetDays;

  public static final String SERIALIZED_NAME_LEAP_DAYS_INCLUDED = "leapDaysIncluded";
  @SerializedName(SERIALIZED_NAME_LEAP_DAYS_INCLUDED)
  private Boolean leapDaysIncluded;

  public static final String SERIALIZED_NAME_ACCRUAL_DATE_ADJUSTMENT = "accrualDateAdjustment";
  @SerializedName(SERIALIZED_NAME_ACCRUAL_DATE_ADJUSTMENT)
  private String accrualDateAdjustment;

  public static final String SERIALIZED_NAME_BUSINESS_DAY_CONVENTION = "businessDayConvention";
  @SerializedName(SERIALIZED_NAME_BUSINESS_DAY_CONVENTION)
  private String businessDayConvention;

  public static final String SERIALIZED_NAME_SCOPE = "scope";
  @SerializedName(SERIALIZED_NAME_SCOPE)
  private String scope;

  public static final String SERIALIZED_NAME_CODE = "code";
  @SerializedName(SERIALIZED_NAME_CODE)
  private String code;

  public FlowConventions() {
  }

  public FlowConventions currency(String currency) {
    
    this.currency = currency;
    return this;
  }

   /**
   * Currency of the flow convention.
   * @return currency
  **/
  @jakarta.annotation.Nonnull
  public String getCurrency() {
    return currency;
  }


  public void setCurrency(String currency) {
    this.currency = currency;
  }


  public FlowConventions paymentFrequency(String paymentFrequency) {
    
    this.paymentFrequency = paymentFrequency;
    return this;
  }

   /**
   * When generating a multiperiod flow, or when the maturity of the flow is not given but the start date is,  the tenor is the time-step from the anchor-date to the nominal maturity of the flow prior to any adjustment.
   * @return paymentFrequency
  **/
  @jakarta.annotation.Nonnull
  public String getPaymentFrequency() {
    return paymentFrequency;
  }


  public void setPaymentFrequency(String paymentFrequency) {
    this.paymentFrequency = paymentFrequency;
  }


  public FlowConventions dayCountConvention(String dayCountConvention) {
    
    this.dayCountConvention = dayCountConvention;
    return this;
  }

   /**
   * when calculating the fraction of a year between two dates, what convention is used to represent the number of days in a year  and difference between them.  For more information on day counts, see [knowledge base article KA-01798](https://support.lusid.com/knowledgebase/article/KA-01798)                Supported string (enumeration) values are: [Actual360, Act360, MoneyMarket, Actual365, Act365, Thirty360, ThirtyU360, Bond, ThirtyE360, EuroBond, ActualActual, ActAct, ActActIsda, ActActIsma, ActActIcma, OneOne, Act364, Act365F, Act365L, Act365_25, Act252, Bus252, NL360, NL365, ActActAFB, Act365Cad, ThirtyActIsda, Thirty365Isda, ThirtyEActIsda, ThirtyE360Isda, ThirtyE365Isda, ThirtyU360EOM].
   * @return dayCountConvention
  **/
  @jakarta.annotation.Nonnull
  public String getDayCountConvention() {
    return dayCountConvention;
  }


  public void setDayCountConvention(String dayCountConvention) {
    this.dayCountConvention = dayCountConvention;
  }


  public FlowConventions rollConvention(String rollConvention) {
    
    this.rollConvention = rollConvention;
    return this;
  }

   /**
   * For backward compatibility, this can either specify a business day convention or a roll convention. If the business  day convention is provided using the BusinessDayConvention property, this must be a valid roll convention.                When used as a roll convention:  The conventions specifying the rule used to generate dates in a schedule.    Supported string (enumeration) values are: [None, EndOfMonth, IMM, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30].                When in backward compatible mode:  Supported string (enumeration) values are: [NoAdjustment, None, Previous, P, Following, F, ModifiedPrevious, MP, ModifiedFollowing, MF, HalfMonthModifiedFollowing].
   * @return rollConvention
  **/
  @jakarta.annotation.Nonnull
  public String getRollConvention() {
    return rollConvention;
  }


  public void setRollConvention(String rollConvention) {
    this.rollConvention = rollConvention;
  }


  public FlowConventions paymentCalendars(List<String> paymentCalendars) {
    
    this.paymentCalendars = paymentCalendars;
    return this;
  }

  public FlowConventions addPaymentCalendarsItem(String paymentCalendarsItem) {
    if (this.paymentCalendars == null) {
      this.paymentCalendars = new ArrayList<>();
    }
    this.paymentCalendars.add(paymentCalendarsItem);
    return this;
  }

   /**
   * An array of strings denoting holiday calendars that apply to generation of payment schedules.
   * @return paymentCalendars
  **/
  @jakarta.annotation.Nonnull
  public List<String> getPaymentCalendars() {
    return paymentCalendars;
  }


  public void setPaymentCalendars(List<String> paymentCalendars) {
    this.paymentCalendars = paymentCalendars;
  }


  public FlowConventions resetCalendars(List<String> resetCalendars) {
    
    this.resetCalendars = resetCalendars;
    return this;
  }

  public FlowConventions addResetCalendarsItem(String resetCalendarsItem) {
    if (this.resetCalendars == null) {
      this.resetCalendars = new ArrayList<>();
    }
    this.resetCalendars.add(resetCalendarsItem);
    return this;
  }

   /**
   * An array of strings denoting holiday calendars that apply to generation of reset schedules.
   * @return resetCalendars
  **/
  @jakarta.annotation.Nonnull
  public List<String> getResetCalendars() {
    return resetCalendars;
  }


  public void setResetCalendars(List<String> resetCalendars) {
    this.resetCalendars = resetCalendars;
  }


  public FlowConventions settleDays(Integer settleDays) {
    
    this.settleDays = settleDays;
    return this;
  }

   /**
   * DEPRECATED  Number of Good Business Days between the trade date and the effective or settlement date of the instrument.  This field is now deprecated and not picked up in schedule generation or adjustment to bond accrual start date. Defaulted to 0 if not set.
   * @return settleDays
  **/
  @jakarta.annotation.Nullable
  public Integer getSettleDays() {
    return settleDays;
  }


  public void setSettleDays(Integer settleDays) {
    this.settleDays = settleDays;
  }


  public FlowConventions resetDays(Integer resetDays) {
    
    this.resetDays = resetDays;
    return this;
  }

   /**
   * The number of Good Business Days between determination and payment of reset. Defaulted to 0 if not set.
   * @return resetDays
  **/
  @jakarta.annotation.Nullable
  public Integer getResetDays() {
    return resetDays;
  }


  public void setResetDays(Integer resetDays) {
    this.resetDays = resetDays;
  }


  public FlowConventions leapDaysIncluded(Boolean leapDaysIncluded) {
    
    this.leapDaysIncluded = leapDaysIncluded;
    return this;
  }

   /**
   * If this flag is set to true, the 29th of February is included in the date schedule when the business roll convention is applied.  If this flag is set to false, the business roll convention ignores February 29 for date schedules, cash flow payments etc.  This flag defaults to true if not specified, i.e., leap days are included in a date schedule generation.
   * @return leapDaysIncluded
  **/
  @jakarta.annotation.Nullable
  public Boolean getLeapDaysIncluded() {
    return leapDaysIncluded;
  }


  public void setLeapDaysIncluded(Boolean leapDaysIncluded) {
    this.leapDaysIncluded = leapDaysIncluded;
  }


  public FlowConventions accrualDateAdjustment(String accrualDateAdjustment) {
    
    this.accrualDateAdjustment = accrualDateAdjustment;
    return this;
  }

   /**
   * Indicates if the accrual dates are adjusted to the payment dates. The default value is &#39;Adjusted&#39;.    Supported string (enumeration) values are: [Adjusted, Unadjusted].
   * @return accrualDateAdjustment
  **/
  @jakarta.annotation.Nullable
  public String getAccrualDateAdjustment() {
    return accrualDateAdjustment;
  }


  public void setAccrualDateAdjustment(String accrualDateAdjustment) {
    this.accrualDateAdjustment = accrualDateAdjustment;
  }


  public FlowConventions businessDayConvention(String businessDayConvention) {
    
    this.businessDayConvention = businessDayConvention;
    return this;
  }

   /**
   * When generating a set of dates, what convention should be used for adjusting dates that coincide with a non-business day.    Supported string (enumeration) values are: [NoAdjustment, None, Previous, P, Following, F, ModifiedPrevious, MP, ModifiedFollowing, MF, HalfMonthModifiedFollowing, Nearest].
   * @return businessDayConvention
  **/
  @jakarta.annotation.Nullable
  public String getBusinessDayConvention() {
    return businessDayConvention;
  }


  public void setBusinessDayConvention(String businessDayConvention) {
    this.businessDayConvention = businessDayConvention;
  }


  public FlowConventions scope(String scope) {
    
    this.scope = scope;
    return this;
  }

   /**
   * The scope used when updating or inserting the convention.
   * @return scope
  **/
  @jakarta.annotation.Nullable
  public String getScope() {
    return scope;
  }


  public void setScope(String scope) {
    this.scope = scope;
  }


  public FlowConventions code(String code) {
    
    this.code = code;
    return this;
  }

   /**
   * The code of the convention.
   * @return code
  **/
  @jakarta.annotation.Nullable
  public String getCode() {
    return code;
  }


  public void setCode(String code) {
    this.code = code;
  }



  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    FlowConventions flowConventions = (FlowConventions) o;
    return Objects.equals(this.currency, flowConventions.currency) &&
        Objects.equals(this.paymentFrequency, flowConventions.paymentFrequency) &&
        Objects.equals(this.dayCountConvention, flowConventions.dayCountConvention) &&
        Objects.equals(this.rollConvention, flowConventions.rollConvention) &&
        Objects.equals(this.paymentCalendars, flowConventions.paymentCalendars) &&
        Objects.equals(this.resetCalendars, flowConventions.resetCalendars) &&
        Objects.equals(this.settleDays, flowConventions.settleDays) &&
        Objects.equals(this.resetDays, flowConventions.resetDays) &&
        Objects.equals(this.leapDaysIncluded, flowConventions.leapDaysIncluded) &&
        Objects.equals(this.accrualDateAdjustment, flowConventions.accrualDateAdjustment) &&
        Objects.equals(this.businessDayConvention, flowConventions.businessDayConvention) &&
        Objects.equals(this.scope, flowConventions.scope) &&
        Objects.equals(this.code, flowConventions.code);
  }

  private static <T> boolean equalsNullable(JsonNullable<T> a, JsonNullable<T> b) {
    return a == b || (a != null && b != null && a.isPresent() && b.isPresent() && Objects.deepEquals(a.get(), b.get()));
  }

  @Override
  public int hashCode() {
    return Objects.hash(currency, paymentFrequency, dayCountConvention, rollConvention, paymentCalendars, resetCalendars, settleDays, resetDays, leapDaysIncluded, accrualDateAdjustment, businessDayConvention, scope, code);
  }

  private static <T> int hashCodeNullable(JsonNullable<T> a) {
    if (a == null) {
      return 1;
    }
    return a.isPresent() ? Arrays.deepHashCode(new Object[]{a.get()}) : 31;
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class FlowConventions {\n");
    sb.append("    currency: ").append(toIndentedString(currency)).append("\n");
    sb.append("    paymentFrequency: ").append(toIndentedString(paymentFrequency)).append("\n");
    sb.append("    dayCountConvention: ").append(toIndentedString(dayCountConvention)).append("\n");
    sb.append("    rollConvention: ").append(toIndentedString(rollConvention)).append("\n");
    sb.append("    paymentCalendars: ").append(toIndentedString(paymentCalendars)).append("\n");
    sb.append("    resetCalendars: ").append(toIndentedString(resetCalendars)).append("\n");
    sb.append("    settleDays: ").append(toIndentedString(settleDays)).append("\n");
    sb.append("    resetDays: ").append(toIndentedString(resetDays)).append("\n");
    sb.append("    leapDaysIncluded: ").append(toIndentedString(leapDaysIncluded)).append("\n");
    sb.append("    accrualDateAdjustment: ").append(toIndentedString(accrualDateAdjustment)).append("\n");
    sb.append("    businessDayConvention: ").append(toIndentedString(businessDayConvention)).append("\n");
    sb.append("    scope: ").append(toIndentedString(scope)).append("\n");
    sb.append("    code: ").append(toIndentedString(code)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }


  public static HashSet<String> openapiFields;
  public static HashSet<String> openapiRequiredFields;

  static {
    // a set of all properties/fields (JSON key names)
    openapiFields = new HashSet<String>();
    openapiFields.add("currency");
    openapiFields.add("paymentFrequency");
    openapiFields.add("dayCountConvention");
    openapiFields.add("rollConvention");
    openapiFields.add("paymentCalendars");
    openapiFields.add("resetCalendars");
    openapiFields.add("settleDays");
    openapiFields.add("resetDays");
    openapiFields.add("leapDaysIncluded");
    openapiFields.add("accrualDateAdjustment");
    openapiFields.add("businessDayConvention");
    openapiFields.add("scope");
    openapiFields.add("code");

    // a set of required properties/fields (JSON key names)
    openapiRequiredFields = new HashSet<String>();
    openapiRequiredFields.add("currency");
    openapiRequiredFields.add("paymentFrequency");
    openapiRequiredFields.add("dayCountConvention");
    openapiRequiredFields.add("rollConvention");
    openapiRequiredFields.add("paymentCalendars");
    openapiRequiredFields.add("resetCalendars");
  }

 /**
  * Validates the JSON Object and throws an exception if issues found
  *
  * @param jsonObj JSON Object
  * @throws IOException if the JSON Object is invalid with respect to FlowConventions
  */
  public static void validateJsonObject(JsonObject jsonObj) throws IOException {
      if (jsonObj == null) {
        if (!FlowConventions.openapiRequiredFields.isEmpty()) { // has required fields but JSON object is null
          throw new IllegalArgumentException(String.format("The required field(s) %s in FlowConventions is not found in the empty JSON string", FlowConventions.openapiRequiredFields.toString()));
        }
      }

      Set<Entry<String, JsonElement>> entries = jsonObj.entrySet();
      // check to see if the JSON string contains additional fields
      for (Entry<String, JsonElement> entry : entries) {
        if (!FlowConventions.openapiFields.contains(entry.getKey())) {
          throw new IllegalArgumentException(String.format("The field `%s` in the JSON string is not defined in the `FlowConventions` properties. JSON: %s", entry.getKey(), jsonObj.toString()));
        }
      }

      // check to make sure all required properties/fields are present in the JSON string
      for (String requiredField : FlowConventions.openapiRequiredFields) {
        if (jsonObj.get(requiredField) == null) {
          throw new IllegalArgumentException(String.format("The required field `%s` is not found in the JSON string: %s", requiredField, jsonObj.toString()));
        }
      }
      if (!jsonObj.get("currency").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `currency` to be a primitive type in the JSON string but got `%s`", jsonObj.get("currency").toString()));
      }
      if (!jsonObj.get("paymentFrequency").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `paymentFrequency` to be a primitive type in the JSON string but got `%s`", jsonObj.get("paymentFrequency").toString()));
      }
      if (!jsonObj.get("dayCountConvention").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `dayCountConvention` to be a primitive type in the JSON string but got `%s`", jsonObj.get("dayCountConvention").toString()));
      }
      if (!jsonObj.get("rollConvention").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `rollConvention` to be a primitive type in the JSON string but got `%s`", jsonObj.get("rollConvention").toString()));
      }
      // ensure the required json array is present
      if (jsonObj.get("paymentCalendars") == null) {
        throw new IllegalArgumentException("Expected the field `linkedContent` to be an array in the JSON string but got `null`");
      } else if (!jsonObj.get("paymentCalendars").isJsonArray()) {
        throw new IllegalArgumentException(String.format("Expected the field `paymentCalendars` to be an array in the JSON string but got `%s`", jsonObj.get("paymentCalendars").toString()));
      }
      // ensure the required json array is present
      if (jsonObj.get("resetCalendars") == null) {
        throw new IllegalArgumentException("Expected the field `linkedContent` to be an array in the JSON string but got `null`");
      } else if (!jsonObj.get("resetCalendars").isJsonArray()) {
        throw new IllegalArgumentException(String.format("Expected the field `resetCalendars` to be an array in the JSON string but got `%s`", jsonObj.get("resetCalendars").toString()));
      }
      if ((jsonObj.get("accrualDateAdjustment") != null && !jsonObj.get("accrualDateAdjustment").isJsonNull()) && !jsonObj.get("accrualDateAdjustment").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `accrualDateAdjustment` to be a primitive type in the JSON string but got `%s`", jsonObj.get("accrualDateAdjustment").toString()));
      }
      if ((jsonObj.get("businessDayConvention") != null && !jsonObj.get("businessDayConvention").isJsonNull()) && !jsonObj.get("businessDayConvention").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `businessDayConvention` to be a primitive type in the JSON string but got `%s`", jsonObj.get("businessDayConvention").toString()));
      }
      if ((jsonObj.get("scope") != null && !jsonObj.get("scope").isJsonNull()) && !jsonObj.get("scope").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `scope` to be a primitive type in the JSON string but got `%s`", jsonObj.get("scope").toString()));
      }
      if ((jsonObj.get("code") != null && !jsonObj.get("code").isJsonNull()) && !jsonObj.get("code").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `code` to be a primitive type in the JSON string but got `%s`", jsonObj.get("code").toString()));
      }
  }

  public static class CustomTypeAdapterFactory implements TypeAdapterFactory {
    @SuppressWarnings("unchecked")
    @Override
    public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {
       if (!FlowConventions.class.isAssignableFrom(type.getRawType())) {
         return null; // this class only serializes 'FlowConventions' and its subtypes
       }
       final TypeAdapter<JsonElement> elementAdapter = gson.getAdapter(JsonElement.class);
       final TypeAdapter<FlowConventions> thisAdapter
                        = gson.getDelegateAdapter(this, TypeToken.get(FlowConventions.class));

       return (TypeAdapter<T>) new TypeAdapter<FlowConventions>() {
           @Override
           public void write(JsonWriter out, FlowConventions value) throws IOException {
             JsonObject obj = thisAdapter.toJsonTree(value).getAsJsonObject();
             elementAdapter.write(out, obj);
           }

           @Override
           public FlowConventions read(JsonReader in) throws IOException {
             JsonObject jsonObj = elementAdapter.read(in).getAsJsonObject();
             validateJsonObject(jsonObj);
             return thisAdapter.fromJsonTree(jsonObj);
           }

       }.nullSafe();
    }
  }

 /**
  * Create an instance of FlowConventions given an JSON string
  *
  * @param jsonString JSON string
  * @return An instance of FlowConventions
  * @throws IOException if the JSON string is invalid with respect to FlowConventions
  */
  public static FlowConventions fromJson(String jsonString) throws IOException {
    return JSON.getGson().fromJson(jsonString, FlowConventions.class);
  }

 /**
  * Convert an instance of FlowConventions to an JSON string
  *
  * @return JSON string
  */
  public String toJson() {
    return JSON.getGson().toJson(this);
  }
}
