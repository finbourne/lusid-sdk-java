/*
 * LUSID API
 *
 * Contact: info@finbourne.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

package com.finbourne.lusid.model;

import java.util.Objects;
import com.finbourne.lusid.model.DataDefinition;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import org.openapitools.jackson.nullable.JsonNullable;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonArray;
import com.google.gson.JsonDeserializationContext;
import com.google.gson.JsonDeserializer;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParseException;
import com.google.gson.TypeAdapterFactory;
import com.google.gson.reflect.TypeToken;
import com.google.gson.TypeAdapter;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;

import java.lang.reflect.Type;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Map.Entry;
import java.util.Set;

import com.finbourne.lusid.JSON;

/**
 * When importing data from an external source there are essentially three levels of interaction with LUSID.  (1) The data is a raw document that LUSID does not understand. You can store and retrieve it but it does not full interact with other documents inside LUSID  (2) The data has a map from fields and paths to &#39;properties&#39; in LUSID. In essence, LUSID can then treat the data as weakly typed (decimal, string) data that can be returned through queries      and where various aggregation requests will then work.  (3) The data is fully translatable into LUSID and understood, in some sense, natively. This means that it can be used for context sensitive calculations such as pricing or risk calculations.  The data map object is designed to allow data to transition from step 1 to 2 and in some cases as an alternative for step 2 to 3.
 */
@jakarta.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen")
public class DataMapping {
  public static final String SERIALIZED_NAME_DATA_DEFINITIONS = "dataDefinitions";
  @SerializedName(SERIALIZED_NAME_DATA_DEFINITIONS)
  private List<DataDefinition> dataDefinitions;

  public DataMapping() {
  }

  public DataMapping dataDefinitions(List<DataDefinition> dataDefinitions) {
    
    this.dataDefinitions = dataDefinitions;
    return this;
  }

  public DataMapping addDataDefinitionsItem(DataDefinition dataDefinitionsItem) {
    if (this.dataDefinitions == null) {
      this.dataDefinitions = new ArrayList<>();
    }
    this.dataDefinitions.add(dataDefinitionsItem);
    return this;
  }

   /**
   * A map from LUSID item keys to data definitions that define the names, types and degree of uniqueness of data provided to LUSID in structured data stores.
   * @return dataDefinitions
  **/
  @jakarta.annotation.Nullable
  public List<DataDefinition> getDataDefinitions() {
    return dataDefinitions;
  }


  public void setDataDefinitions(List<DataDefinition> dataDefinitions) {
    this.dataDefinitions = dataDefinitions;
  }



  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    DataMapping dataMapping = (DataMapping) o;
    return Objects.equals(this.dataDefinitions, dataMapping.dataDefinitions);
  }

  private static <T> boolean equalsNullable(JsonNullable<T> a, JsonNullable<T> b) {
    return a == b || (a != null && b != null && a.isPresent() && b.isPresent() && Objects.deepEquals(a.get(), b.get()));
  }

  @Override
  public int hashCode() {
    return Objects.hash(dataDefinitions);
  }

  private static <T> int hashCodeNullable(JsonNullable<T> a) {
    if (a == null) {
      return 1;
    }
    return a.isPresent() ? Arrays.deepHashCode(new Object[]{a.get()}) : 31;
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class DataMapping {\n");
    sb.append("    dataDefinitions: ").append(toIndentedString(dataDefinitions)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }


  public static HashSet<String> openapiFields;
  public static HashSet<String> openapiRequiredFields;

  static {
    // a set of all properties/fields (JSON key names)
    openapiFields = new HashSet<String>();
    openapiFields.add("dataDefinitions");

    // a set of required properties/fields (JSON key names)
    openapiRequiredFields = new HashSet<String>();
  }

 /**
  * Validates the JSON Object and throws an exception if issues found
  *
  * @param jsonObj JSON Object
  * @throws IOException if the JSON Object is invalid with respect to DataMapping
  */
  public static void validateJsonObject(JsonObject jsonObj) throws IOException {
      if (jsonObj == null) {
        if (!DataMapping.openapiRequiredFields.isEmpty()) { // has required fields but JSON object is null
          throw new IllegalArgumentException(String.format("The required field(s) %s in DataMapping is not found in the empty JSON string", DataMapping.openapiRequiredFields.toString()));
        }
      }

      Set<Entry<String, JsonElement>> entries = jsonObj.entrySet();
      // check to see if the JSON string contains additional fields
      for (Entry<String, JsonElement> entry : entries) {
        if (!DataMapping.openapiFields.contains(entry.getKey())) {
          throw new IllegalArgumentException(String.format("The field `%s` in the JSON string is not defined in the `DataMapping` properties. JSON: %s", entry.getKey(), jsonObj.toString()));
        }
      }
      if (jsonObj.get("dataDefinitions") != null && !jsonObj.get("dataDefinitions").isJsonNull()) {
        JsonArray jsonArraydataDefinitions = jsonObj.getAsJsonArray("dataDefinitions");
        if (jsonArraydataDefinitions != null) {
          // ensure the json data is an array
          if (!jsonObj.get("dataDefinitions").isJsonArray()) {
            throw new IllegalArgumentException(String.format("Expected the field `dataDefinitions` to be an array in the JSON string but got `%s`", jsonObj.get("dataDefinitions").toString()));
          }

          // validate the optional field `dataDefinitions` (array)
          for (int i = 0; i < jsonArraydataDefinitions.size(); i++) {
            DataDefinition.validateJsonObject(jsonArraydataDefinitions.get(i).getAsJsonObject());
          };
        }
      }
  }

  public static class CustomTypeAdapterFactory implements TypeAdapterFactory {
    @SuppressWarnings("unchecked")
    @Override
    public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {
       if (!DataMapping.class.isAssignableFrom(type.getRawType())) {
         return null; // this class only serializes 'DataMapping' and its subtypes
       }
       final TypeAdapter<JsonElement> elementAdapter = gson.getAdapter(JsonElement.class);
       final TypeAdapter<DataMapping> thisAdapter
                        = gson.getDelegateAdapter(this, TypeToken.get(DataMapping.class));

       return (TypeAdapter<T>) new TypeAdapter<DataMapping>() {
           @Override
           public void write(JsonWriter out, DataMapping value) throws IOException {
             JsonObject obj = thisAdapter.toJsonTree(value).getAsJsonObject();
             elementAdapter.write(out, obj);
           }

           @Override
           public DataMapping read(JsonReader in) throws IOException {
             JsonObject jsonObj = elementAdapter.read(in).getAsJsonObject();
             validateJsonObject(jsonObj);
             return thisAdapter.fromJsonTree(jsonObj);
           }

       }.nullSafe();
    }
  }

 /**
  * Create an instance of DataMapping given an JSON string
  *
  * @param jsonString JSON string
  * @return An instance of DataMapping
  * @throws IOException if the JSON string is invalid with respect to DataMapping
  */
  public static DataMapping fromJson(String jsonString) throws IOException {
    return JSON.getGson().fromJson(jsonString, DataMapping.class);
  }

 /**
  * Convert an instance of DataMapping to an JSON string
  *
  * @return JSON string
  */
  public String toJson() {
    return JSON.getGson().toJson(this);
  }
}
