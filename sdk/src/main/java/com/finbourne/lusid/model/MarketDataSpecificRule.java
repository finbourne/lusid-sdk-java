/*
 * LUSID API
 *
 * Contact: info@finbourne.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

package com.finbourne.lusid.model;

import java.util.Objects;
import com.finbourne.lusid.model.DependencySourceFilter;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;
import java.time.OffsetDateTime;
import java.util.Arrays;
import org.openapitools.jackson.nullable.JsonNullable;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonArray;
import com.google.gson.JsonDeserializationContext;
import com.google.gson.JsonDeserializer;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParseException;
import com.google.gson.TypeAdapterFactory;
import com.google.gson.reflect.TypeToken;
import com.google.gson.TypeAdapter;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;

import java.lang.reflect.Type;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Map.Entry;
import java.util.Set;

import com.finbourne.lusid.JSON;

/**
 * Extends market data key rules to be able to catch dependencies depending on where the dependency comes from, as opposed to what the dependency is asking for.  For example, a market data rule might instruct all rates curves to be retrieved from a particular scope.  This class gives the ability to set different behaviour depending on what is requesting the rates curve.  Using two specific rules, one could instruct rates curves requested by bonds to be retrieved from a different scope than rates curves requested by swaps.
 */
@jakarta.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen")
public class MarketDataSpecificRule {
  public static final String SERIALIZED_NAME_KEY = "key";
  @SerializedName(SERIALIZED_NAME_KEY)
  private String key;

  public static final String SERIALIZED_NAME_SUPPLIER = "supplier";
  @SerializedName(SERIALIZED_NAME_SUPPLIER)
  private String supplier;

  public static final String SERIALIZED_NAME_DATA_SCOPE = "dataScope";
  @SerializedName(SERIALIZED_NAME_DATA_SCOPE)
  private String dataScope;

  /**
   * The available values are: Price, Spread, Rate, LogNormalVol, NormalVol, ParSpread, IsdaSpread, Upfront, Index, Ratio, Delta, PoolFactor, InflationAssumption, DirtyPrice, PrincipalWriteOff, InterestDeferred, InterestShortfall, ConstituentWeightFactor
   */
  @JsonAdapter(QuoteTypeEnum.Adapter.class)
  public enum QuoteTypeEnum {
    PRICE("Price"),
    
    SPREAD("Spread"),
    
    RATE("Rate"),
    
    LOGNORMALVOL("LogNormalVol"),
    
    NORMALVOL("NormalVol"),
    
    PARSPREAD("ParSpread"),
    
    ISDASPREAD("IsdaSpread"),
    
    UPFRONT("Upfront"),
    
    INDEX("Index"),
    
    RATIO("Ratio"),
    
    DELTA("Delta"),
    
    POOLFACTOR("PoolFactor"),
    
    INFLATIONASSUMPTION("InflationAssumption"),
    
    DIRTYPRICE("DirtyPrice"),
    
    PRINCIPALWRITEOFF("PrincipalWriteOff"),
    
    INTERESTDEFERRED("InterestDeferred"),
    
    INTERESTSHORTFALL("InterestShortfall"),
    
    CONSTITUENTWEIGHTFACTOR("ConstituentWeightFactor");

    private String value;

    QuoteTypeEnum(String value) {
      this.value = value;
    }

    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }

    public static QuoteTypeEnum fromValue(String value) {
      for (QuoteTypeEnum b : QuoteTypeEnum.values()) {
        if (b.value.equals(value)) {
          return b;
        }
      }
      throw new IllegalArgumentException("Unexpected value '" + value + "'");
    }

    public static class Adapter extends TypeAdapter<QuoteTypeEnum> {
      @Override
      public void write(final JsonWriter jsonWriter, final QuoteTypeEnum enumeration) throws IOException {
        jsonWriter.value(enumeration.getValue());
      }

      @Override
      public QuoteTypeEnum read(final JsonReader jsonReader) throws IOException {
        String value =  jsonReader.nextString();
        return QuoteTypeEnum.fromValue(value);
      }
    }
  }

  public static final String SERIALIZED_NAME_QUOTE_TYPE = "quoteType";
  @SerializedName(SERIALIZED_NAME_QUOTE_TYPE)
  private QuoteTypeEnum quoteType;

  public static final String SERIALIZED_NAME_FIELD = "field";
  @SerializedName(SERIALIZED_NAME_FIELD)
  private String field;

  public static final String SERIALIZED_NAME_QUOTE_INTERVAL = "quoteInterval";
  @SerializedName(SERIALIZED_NAME_QUOTE_INTERVAL)
  private String quoteInterval;

  public static final String SERIALIZED_NAME_AS_AT = "asAt";
  @SerializedName(SERIALIZED_NAME_AS_AT)
  private OffsetDateTime asAt;

  public static final String SERIALIZED_NAME_PRICE_SOURCE = "priceSource";
  @SerializedName(SERIALIZED_NAME_PRICE_SOURCE)
  private String priceSource;

  public static final String SERIALIZED_NAME_MASK = "mask";
  @SerializedName(SERIALIZED_NAME_MASK)
  private String mask;

  public static final String SERIALIZED_NAME_DEPENDENCY_SOURCE_FILTER = "dependencySourceFilter";
  @SerializedName(SERIALIZED_NAME_DEPENDENCY_SOURCE_FILTER)
  private DependencySourceFilter dependencySourceFilter;

  public static final String SERIALIZED_NAME_SOURCE_SYSTEM = "sourceSystem";
  @SerializedName(SERIALIZED_NAME_SOURCE_SYSTEM)
  private String sourceSystem;

  public static final String SERIALIZED_NAME_FALL_THROUGH_ON_ACCESS_DENIED = "fallThroughOnAccessDenied";
  @SerializedName(SERIALIZED_NAME_FALL_THROUGH_ON_ACCESS_DENIED)
  private Boolean fallThroughOnAccessDenied;

  public MarketDataSpecificRule() {
  }

  public MarketDataSpecificRule key(String key) {
    
    this.key = key;
    return this;
  }

   /**
   * The market data key pattern which this is a rule for. A dot separated string (A.B.C.D.*)
   * @return key
  **/
  @jakarta.annotation.Nonnull
  public String getKey() {
    return key;
  }


  public void setKey(String key) {
    this.key = key;
  }


  public MarketDataSpecificRule supplier(String supplier) {
    
    this.supplier = supplier;
    return this;
  }

   /**
   * The market data supplier (where the data comes from)
   * @return supplier
  **/
  @jakarta.annotation.Nonnull
  public String getSupplier() {
    return supplier;
  }


  public void setSupplier(String supplier) {
    this.supplier = supplier;
  }


  public MarketDataSpecificRule dataScope(String dataScope) {
    
    this.dataScope = dataScope;
    return this;
  }

   /**
   * The scope in which the data should be found when using this rule.
   * @return dataScope
  **/
  @jakarta.annotation.Nonnull
  public String getDataScope() {
    return dataScope;
  }


  public void setDataScope(String dataScope) {
    this.dataScope = dataScope;
  }


  public MarketDataSpecificRule quoteType(QuoteTypeEnum quoteType) {
    
    this.quoteType = quoteType;
    return this;
  }

   /**
   * The available values are: Price, Spread, Rate, LogNormalVol, NormalVol, ParSpread, IsdaSpread, Upfront, Index, Ratio, Delta, PoolFactor, InflationAssumption, DirtyPrice, PrincipalWriteOff, InterestDeferred, InterestShortfall, ConstituentWeightFactor
   * @return quoteType
  **/
  @jakarta.annotation.Nonnull
  public QuoteTypeEnum getQuoteType() {
    return quoteType;
  }


  public void setQuoteType(QuoteTypeEnum quoteType) {
    this.quoteType = quoteType;
  }


  public MarketDataSpecificRule field(String field) {
    
    this.field = field;
    return this;
  }

   /**
   * The conceptual qualification for the field, such as bid, mid, or ask.  The field must be one of a defined set for the given supplier, in the same way as it  is for the Finbourne.WebApi.Interface.Dto.Quotes.QuoteSeriesId
   * @return field
  **/
  @jakarta.annotation.Nonnull
  public String getField() {
    return field;
  }


  public void setField(String field) {
    this.field = field;
  }


  public MarketDataSpecificRule quoteInterval(String quoteInterval) {
    
    this.quoteInterval = quoteInterval;
    return this;
  }

   /**
   * Shorthand for the time interval used to select market data. This must be a dot-separated string   nominating a start and end date, for example &#39;5D.0D&#39; to look back 5 days from today (0 days ago). The syntax   is &lt;i&gt;int&lt;/i&gt;&lt;i&gt;char&lt;/i&gt;.&lt;i&gt;int&lt;/i&gt;&lt;i&gt;char&lt;/i&gt;, where &lt;i&gt;char&lt;/i&gt; is one of D(ay), W(eek), M(onth) or Y(ear).
   * @return quoteInterval
  **/
  @jakarta.annotation.Nullable
  public String getQuoteInterval() {
    return quoteInterval;
  }


  public void setQuoteInterval(String quoteInterval) {
    this.quoteInterval = quoteInterval;
  }


  public MarketDataSpecificRule asAt(OffsetDateTime asAt) {
    
    this.asAt = asAt;
    return this;
  }

   /**
   * Deprecated field which no longer has any effect on market data resolution.
   * @return asAt
  **/
  @jakarta.annotation.Nullable
  public OffsetDateTime getAsAt() {
    return asAt;
  }


  public void setAsAt(OffsetDateTime asAt) {
    this.asAt = asAt;
  }


  public MarketDataSpecificRule priceSource(String priceSource) {
    
    this.priceSource = priceSource;
    return this;
  }

   /**
   * The source of the quote. For a given provider/supplier of market data there may be an additional qualifier, e.g. the exchange or bank that provided the quote
   * @return priceSource
  **/
  @jakarta.annotation.Nullable
  public String getPriceSource() {
    return priceSource;
  }


  public void setPriceSource(String priceSource) {
    this.priceSource = priceSource;
  }


  public MarketDataSpecificRule mask(String mask) {
    
    this.mask = mask;
    return this;
  }

   /**
   * Allows for partial or complete override of the market asset resolved for a dependency  Either a named override or a dot separated string (A.B.C.D.*).  e.g. for Rates curve &#39;EUR.*&#39; will replace the resolve MarketAsset &#39;GBP/12M&#39;, &#39;GBP/3M&#39; with the EUR equivalent, if there  are no wildcards in the mask, the mask is taken as the MarketAsset for any dependency matching the rule.
   * @return mask
  **/
  @jakarta.annotation.Nullable
  public String getMask() {
    return mask;
  }


  public void setMask(String mask) {
    this.mask = mask;
  }


  public MarketDataSpecificRule dependencySourceFilter(DependencySourceFilter dependencySourceFilter) {
    
    this.dependencySourceFilter = dependencySourceFilter;
    return this;
  }

   /**
   * Get dependencySourceFilter
   * @return dependencySourceFilter
  **/
  @jakarta.annotation.Nonnull
  public DependencySourceFilter getDependencySourceFilter() {
    return dependencySourceFilter;
  }


  public void setDependencySourceFilter(DependencySourceFilter dependencySourceFilter) {
    this.dependencySourceFilter = dependencySourceFilter;
  }


  public MarketDataSpecificRule sourceSystem(String sourceSystem) {
    
    this.sourceSystem = sourceSystem;
    return this;
  }

   /**
   * Determines from where LUSID should attempt to find the data. Optional and, if omitted, will default to \&quot;Lusid\&quot;.  This means that data will be retrieved from the Quotes store and the ComplexMarketData store.  These can be populated using the Quotes and ComplexMarketData endpoints.
   * @return sourceSystem
  **/
  @jakarta.annotation.Nullable
  public String getSourceSystem() {
    return sourceSystem;
  }


  public void setSourceSystem(String sourceSystem) {
    this.sourceSystem = sourceSystem;
  }


  public MarketDataSpecificRule fallThroughOnAccessDenied(Boolean fallThroughOnAccessDenied) {
    
    this.fallThroughOnAccessDenied = fallThroughOnAccessDenied;
    return this;
  }

   /**
   * When a user attempts to use a rule to access data to which they are not entitled,  the rule will fail to resolve any market data.  By default, such an access denied failure will stop any further attempts to resolve market data.  This is so that differently entitled users always receive the same market data from market data resolution,  if they have sufficient entitlements to retrieve the required data.  If set to true, then an access denied failure will not stop further market data resolution,  and resolution will continue with the next specified MarketDataKeyRule.  Optional, and defaults to false.
   * @return fallThroughOnAccessDenied
  **/
  @jakarta.annotation.Nullable
  public Boolean getFallThroughOnAccessDenied() {
    return fallThroughOnAccessDenied;
  }


  public void setFallThroughOnAccessDenied(Boolean fallThroughOnAccessDenied) {
    this.fallThroughOnAccessDenied = fallThroughOnAccessDenied;
  }



  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    MarketDataSpecificRule marketDataSpecificRule = (MarketDataSpecificRule) o;
    return Objects.equals(this.key, marketDataSpecificRule.key) &&
        Objects.equals(this.supplier, marketDataSpecificRule.supplier) &&
        Objects.equals(this.dataScope, marketDataSpecificRule.dataScope) &&
        Objects.equals(this.quoteType, marketDataSpecificRule.quoteType) &&
        Objects.equals(this.field, marketDataSpecificRule.field) &&
        Objects.equals(this.quoteInterval, marketDataSpecificRule.quoteInterval) &&
        Objects.equals(this.asAt, marketDataSpecificRule.asAt) &&
        Objects.equals(this.priceSource, marketDataSpecificRule.priceSource) &&
        Objects.equals(this.mask, marketDataSpecificRule.mask) &&
        Objects.equals(this.dependencySourceFilter, marketDataSpecificRule.dependencySourceFilter) &&
        Objects.equals(this.sourceSystem, marketDataSpecificRule.sourceSystem) &&
        Objects.equals(this.fallThroughOnAccessDenied, marketDataSpecificRule.fallThroughOnAccessDenied);
  }

  private static <T> boolean equalsNullable(JsonNullable<T> a, JsonNullable<T> b) {
    return a == b || (a != null && b != null && a.isPresent() && b.isPresent() && Objects.deepEquals(a.get(), b.get()));
  }

  @Override
  public int hashCode() {
    return Objects.hash(key, supplier, dataScope, quoteType, field, quoteInterval, asAt, priceSource, mask, dependencySourceFilter, sourceSystem, fallThroughOnAccessDenied);
  }

  private static <T> int hashCodeNullable(JsonNullable<T> a) {
    if (a == null) {
      return 1;
    }
    return a.isPresent() ? Arrays.deepHashCode(new Object[]{a.get()}) : 31;
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class MarketDataSpecificRule {\n");
    sb.append("    key: ").append(toIndentedString(key)).append("\n");
    sb.append("    supplier: ").append(toIndentedString(supplier)).append("\n");
    sb.append("    dataScope: ").append(toIndentedString(dataScope)).append("\n");
    sb.append("    quoteType: ").append(toIndentedString(quoteType)).append("\n");
    sb.append("    field: ").append(toIndentedString(field)).append("\n");
    sb.append("    quoteInterval: ").append(toIndentedString(quoteInterval)).append("\n");
    sb.append("    asAt: ").append(toIndentedString(asAt)).append("\n");
    sb.append("    priceSource: ").append(toIndentedString(priceSource)).append("\n");
    sb.append("    mask: ").append(toIndentedString(mask)).append("\n");
    sb.append("    dependencySourceFilter: ").append(toIndentedString(dependencySourceFilter)).append("\n");
    sb.append("    sourceSystem: ").append(toIndentedString(sourceSystem)).append("\n");
    sb.append("    fallThroughOnAccessDenied: ").append(toIndentedString(fallThroughOnAccessDenied)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }


  public static HashSet<String> openapiFields;
  public static HashSet<String> openapiRequiredFields;

  static {
    // a set of all properties/fields (JSON key names)
    openapiFields = new HashSet<String>();
    openapiFields.add("key");
    openapiFields.add("supplier");
    openapiFields.add("dataScope");
    openapiFields.add("quoteType");
    openapiFields.add("field");
    openapiFields.add("quoteInterval");
    openapiFields.add("asAt");
    openapiFields.add("priceSource");
    openapiFields.add("mask");
    openapiFields.add("dependencySourceFilter");
    openapiFields.add("sourceSystem");
    openapiFields.add("fallThroughOnAccessDenied");

    // a set of required properties/fields (JSON key names)
    openapiRequiredFields = new HashSet<String>();
    openapiRequiredFields.add("key");
    openapiRequiredFields.add("supplier");
    openapiRequiredFields.add("dataScope");
    openapiRequiredFields.add("quoteType");
    openapiRequiredFields.add("field");
    openapiRequiredFields.add("dependencySourceFilter");
  }

 /**
  * Validates the JSON Element and throws an exception if issues found
  *
  * @param jsonElement JSON Element
  * @throws IOException if the JSON Element is invalid with respect to MarketDataSpecificRule
  */
  public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      if (jsonElement == null) {
        if (!MarketDataSpecificRule.openapiRequiredFields.isEmpty()) { // has required fields but JSON element is null
          throw new IllegalArgumentException(String.format("The required field(s) %s in MarketDataSpecificRule is not found in the empty JSON string", MarketDataSpecificRule.openapiRequiredFields.toString()));
        }
      }

      // check to make sure all required properties/fields are present in the JSON string
      for (String requiredField : MarketDataSpecificRule.openapiRequiredFields) {
        if (jsonElement.getAsJsonObject().get(requiredField) == null) {
          throw new IllegalArgumentException(String.format("The required field `%s` is not found in the JSON string: %s", requiredField, jsonElement.toString()));
        }
      }
        JsonObject jsonObj = jsonElement.getAsJsonObject();
      if (!jsonObj.get("key").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `key` to be a primitive type in the JSON string but got `%s`", jsonObj.get("key").toString()));
      }
      if (!jsonObj.get("supplier").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `supplier` to be a primitive type in the JSON string but got `%s`", jsonObj.get("supplier").toString()));
      }
      if (!jsonObj.get("dataScope").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `dataScope` to be a primitive type in the JSON string but got `%s`", jsonObj.get("dataScope").toString()));
      }
      if (!jsonObj.get("quoteType").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `quoteType` to be a primitive type in the JSON string but got `%s`", jsonObj.get("quoteType").toString()));
      }
      if (!jsonObj.get("field").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `field` to be a primitive type in the JSON string but got `%s`", jsonObj.get("field").toString()));
      }
      if ((jsonObj.get("quoteInterval") != null && !jsonObj.get("quoteInterval").isJsonNull()) && !jsonObj.get("quoteInterval").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `quoteInterval` to be a primitive type in the JSON string but got `%s`", jsonObj.get("quoteInterval").toString()));
      }
      if ((jsonObj.get("priceSource") != null && !jsonObj.get("priceSource").isJsonNull()) && !jsonObj.get("priceSource").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `priceSource` to be a primitive type in the JSON string but got `%s`", jsonObj.get("priceSource").toString()));
      }
      if ((jsonObj.get("mask") != null && !jsonObj.get("mask").isJsonNull()) && !jsonObj.get("mask").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `mask` to be a primitive type in the JSON string but got `%s`", jsonObj.get("mask").toString()));
      }
      // validate the required field `dependencySourceFilter`
      DependencySourceFilter.validateJsonElement(jsonObj.get("dependencySourceFilter"));
      if ((jsonObj.get("sourceSystem") != null && !jsonObj.get("sourceSystem").isJsonNull()) && !jsonObj.get("sourceSystem").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `sourceSystem` to be a primitive type in the JSON string but got `%s`", jsonObj.get("sourceSystem").toString()));
      }
  }

  public static class CustomTypeAdapterFactory implements TypeAdapterFactory {
    @SuppressWarnings("unchecked")
    @Override
    public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {
       if (!MarketDataSpecificRule.class.isAssignableFrom(type.getRawType())) {
         return null; // this class only serializes 'MarketDataSpecificRule' and its subtypes
       }
       final TypeAdapter<JsonElement> elementAdapter = gson.getAdapter(JsonElement.class);
       final TypeAdapter<MarketDataSpecificRule> thisAdapter
                        = gson.getDelegateAdapter(this, TypeToken.get(MarketDataSpecificRule.class));

       return (TypeAdapter<T>) new TypeAdapter<MarketDataSpecificRule>() {
           @Override
           public void write(JsonWriter out, MarketDataSpecificRule value) throws IOException {
             JsonObject obj = thisAdapter.toJsonTree(value).getAsJsonObject();
             elementAdapter.write(out, obj);
           }

           @Override
           public MarketDataSpecificRule read(JsonReader in) throws IOException {
             JsonElement jsonElement = elementAdapter.read(in);
             validateJsonElement(jsonElement);
             return thisAdapter.fromJsonTree(jsonElement);
           }

       }.nullSafe();
    }
  }

 /**
  * Create an instance of MarketDataSpecificRule given an JSON string
  *
  * @param jsonString JSON string
  * @return An instance of MarketDataSpecificRule
  * @throws IOException if the JSON string is invalid with respect to MarketDataSpecificRule
  */
  public static MarketDataSpecificRule fromJson(String jsonString) throws IOException {
    return JSON.getGson().fromJson(jsonString, MarketDataSpecificRule.class);
  }

 /**
  * Convert an instance of MarketDataSpecificRule to an JSON string
  *
  * @return JSON string
  */
  public String toJson() {
    return JSON.getGson().toJson(this);
  }
}
