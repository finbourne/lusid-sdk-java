/*
 * LUSID API
 *
 * Contact: info@finbourne.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

package com.finbourne.lusid.model;

import java.util.Objects;
import com.finbourne.lusid.model.AggregateSpec;
import com.finbourne.lusid.model.MarketDataOverrides;
import com.finbourne.lusid.model.OrderBySpec;
import com.finbourne.lusid.model.OrderFlowConfiguration;
import com.finbourne.lusid.model.PortfolioEntityId;
import com.finbourne.lusid.model.PropertyFilter;
import com.finbourne.lusid.model.ResourceId;
import com.finbourne.lusid.model.ValuationSchedule;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;
import java.time.OffsetDateTime;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import org.openapitools.jackson.nullable.JsonNullable;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonArray;
import com.google.gson.JsonDeserializationContext;
import com.google.gson.JsonDeserializer;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParseException;
import com.google.gson.TypeAdapterFactory;
import com.google.gson.reflect.TypeToken;
import com.google.gson.TypeAdapter;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;

import java.lang.reflect.Type;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Map.Entry;
import java.util.Set;

import com.finbourne.lusid.JSON;

/**
 * Specification object for the parameters of a valuation
 */
@jakarta.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen")
public class ValuationRequest {
  public static final String SERIALIZED_NAME_RECIPE_ID = "recipeId";
  @SerializedName(SERIALIZED_NAME_RECIPE_ID)
  private ResourceId recipeId;

  public static final String SERIALIZED_NAME_AS_AT = "asAt";
  @SerializedName(SERIALIZED_NAME_AS_AT)
  private OffsetDateTime asAt;

  public static final String SERIALIZED_NAME_METRICS = "metrics";
  @SerializedName(SERIALIZED_NAME_METRICS)
  private List<AggregateSpec> metrics = new ArrayList<>();

  public static final String SERIALIZED_NAME_GROUP_BY = "groupBy";
  @SerializedName(SERIALIZED_NAME_GROUP_BY)
  private List<String> groupBy;

  public static final String SERIALIZED_NAME_FILTERS = "filters";
  @SerializedName(SERIALIZED_NAME_FILTERS)
  private List<PropertyFilter> filters;

  public static final String SERIALIZED_NAME_SORT = "sort";
  @SerializedName(SERIALIZED_NAME_SORT)
  private List<OrderBySpec> sort;

  public static final String SERIALIZED_NAME_REPORT_CURRENCY = "reportCurrency";
  @SerializedName(SERIALIZED_NAME_REPORT_CURRENCY)
  private String reportCurrency;

  public static final String SERIALIZED_NAME_EQUIP_WITH_SUBTOTALS = "equipWithSubtotals";
  @SerializedName(SERIALIZED_NAME_EQUIP_WITH_SUBTOTALS)
  private Boolean equipWithSubtotals;

  public static final String SERIALIZED_NAME_RETURN_RESULT_AS_EXPANDED_TYPES = "returnResultAsExpandedTypes";
  @SerializedName(SERIALIZED_NAME_RETURN_RESULT_AS_EXPANDED_TYPES)
  private Boolean returnResultAsExpandedTypes;

  public static final String SERIALIZED_NAME_INCLUDE_ORDER_FLOW = "includeOrderFlow";
  @SerializedName(SERIALIZED_NAME_INCLUDE_ORDER_FLOW)
  private OrderFlowConfiguration includeOrderFlow;

  public static final String SERIALIZED_NAME_PORTFOLIO_ENTITY_IDS = "portfolioEntityIds";
  @SerializedName(SERIALIZED_NAME_PORTFOLIO_ENTITY_IDS)
  private List<PortfolioEntityId> portfolioEntityIds = new ArrayList<>();

  public static final String SERIALIZED_NAME_VALUATION_SCHEDULE = "valuationSchedule";
  @SerializedName(SERIALIZED_NAME_VALUATION_SCHEDULE)
  private ValuationSchedule valuationSchedule;

  public static final String SERIALIZED_NAME_MARKET_DATA_OVERRIDES = "marketDataOverrides";
  @SerializedName(SERIALIZED_NAME_MARKET_DATA_OVERRIDES)
  private MarketDataOverrides marketDataOverrides;

  public static final String SERIALIZED_NAME_CORPORATE_ACTION_SOURCE_ID = "corporateActionSourceId";
  @SerializedName(SERIALIZED_NAME_CORPORATE_ACTION_SOURCE_ID)
  private ResourceId corporateActionSourceId;

  public ValuationRequest() {
  }

  public ValuationRequest recipeId(ResourceId recipeId) {
    
    this.recipeId = recipeId;
    return this;
  }

   /**
   * Get recipeId
   * @return recipeId
  **/
  @jakarta.annotation.Nonnull
  public ResourceId getRecipeId() {
    return recipeId;
  }


  public void setRecipeId(ResourceId recipeId) {
    this.recipeId = recipeId;
  }


  public ValuationRequest asAt(OffsetDateTime asAt) {
    
    this.asAt = asAt;
    return this;
  }

   /**
   * The asAt date to use
   * @return asAt
  **/
  @jakarta.annotation.Nullable
  public OffsetDateTime getAsAt() {
    return asAt;
  }


  public void setAsAt(OffsetDateTime asAt) {
    this.asAt = asAt;
  }


  public ValuationRequest metrics(List<AggregateSpec> metrics) {
    
    this.metrics = metrics;
    return this;
  }

  public ValuationRequest addMetricsItem(AggregateSpec metricsItem) {
    if (this.metrics == null) {
      this.metrics = new ArrayList<>();
    }
    this.metrics.add(metricsItem);
    return this;
  }

   /**
   * The set of specifications to calculate or retrieve during the valuation and present in the results. For example:  AggregateSpec(&#39;Valuation/PV&#39;,&#39;Sum&#39;) for returning the PV (present value) of holdings  AggregateSpec(&#39;Holding/default/Units&#39;,&#39;Sum&#39;) for returning the units of holidays  AggregateSpec(&#39;Instrument/default/LusidInstrumentId&#39;,&#39;Value&#39;) for returning the Lusid Instrument identifier
   * @return metrics
  **/
  @jakarta.annotation.Nonnull
  public List<AggregateSpec> getMetrics() {
    return metrics;
  }


  public void setMetrics(List<AggregateSpec> metrics) {
    this.metrics = metrics;
  }


  public ValuationRequest groupBy(List<String> groupBy) {
    
    this.groupBy = groupBy;
    return this;
  }

  public ValuationRequest addGroupByItem(String groupByItem) {
    if (this.groupBy == null) {
      this.groupBy = new ArrayList<>();
    }
    this.groupBy.add(groupByItem);
    return this;
  }

   /**
   * The set of items by which to perform grouping. This primarily matters when one or more of the metric operators is a mapping  that reduces set size, e.g. sum or proportion. The group-by statement determines the set of keys by which to break the results out.
   * @return groupBy
  **/
  @jakarta.annotation.Nullable
  public List<String> getGroupBy() {
    return groupBy;
  }


  public void setGroupBy(List<String> groupBy) {
    this.groupBy = groupBy;
  }


  public ValuationRequest filters(List<PropertyFilter> filters) {
    
    this.filters = filters;
    return this;
  }

  public ValuationRequest addFiltersItem(PropertyFilter filtersItem) {
    if (this.filters == null) {
      this.filters = new ArrayList<>();
    }
    this.filters.add(filtersItem);
    return this;
  }

   /**
   * A set of filters to use to reduce the data found in a request. Equivalent to the &#39;where ...&#39; part of a Sql select statement.  For example, filter a set of values within a given range or matching a particular value.
   * @return filters
  **/
  @jakarta.annotation.Nullable
  public List<PropertyFilter> getFilters() {
    return filters;
  }


  public void setFilters(List<PropertyFilter> filters) {
    this.filters = filters;
  }


  public ValuationRequest sort(List<OrderBySpec> sort) {
    
    this.sort = sort;
    return this;
  }

  public ValuationRequest addSortItem(OrderBySpec sortItem) {
    if (this.sort == null) {
      this.sort = new ArrayList<>();
    }
    this.sort.add(sortItem);
    return this;
  }

   /**
   * A (possibly empty/null) set of specifications for how to order the results.
   * @return sort
  **/
  @jakarta.annotation.Nullable
  public List<OrderBySpec> getSort() {
    return sort;
  }


  public void setSort(List<OrderBySpec> sort) {
    this.sort = sort;
  }


  public ValuationRequest reportCurrency(String reportCurrency) {
    
    this.reportCurrency = reportCurrency;
    return this;
  }

   /**
   * Three letter ISO currency string indicating what currency to report in for ReportCurrency denominated queries.  If not present, then the currency of the relevant portfolio will be used in its place.
   * @return reportCurrency
  **/
  @jakarta.annotation.Nullable
  public String getReportCurrency() {
    return reportCurrency;
  }


  public void setReportCurrency(String reportCurrency) {
    this.reportCurrency = reportCurrency;
  }


  public ValuationRequest equipWithSubtotals(Boolean equipWithSubtotals) {
    
    this.equipWithSubtotals = equipWithSubtotals;
    return this;
  }

   /**
   * Flag directing the Valuation call to populate the results with subtotals of aggregates.
   * @return equipWithSubtotals
  **/
  @jakarta.annotation.Nullable
  public Boolean getEquipWithSubtotals() {
    return equipWithSubtotals;
  }


  public void setEquipWithSubtotals(Boolean equipWithSubtotals) {
    this.equipWithSubtotals = equipWithSubtotals;
  }


  public ValuationRequest returnResultAsExpandedTypes(Boolean returnResultAsExpandedTypes) {
    
    this.returnResultAsExpandedTypes = returnResultAsExpandedTypes;
    return this;
  }

   /**
   * Financially meaningful results can be presented as either simple flat types or more complex expanded types.  For example, the present value (PV) of a holding could be represented either as a simple decimal (with currency implied)  or as a decimal-currency pair. This flag allows either representation to be returned. In the PV example,  the returned value would be the decimal-currency pair if this flag is true, or the decimal only if this flag is false.
   * @return returnResultAsExpandedTypes
  **/
  @jakarta.annotation.Nullable
  public Boolean getReturnResultAsExpandedTypes() {
    return returnResultAsExpandedTypes;
  }


  public void setReturnResultAsExpandedTypes(Boolean returnResultAsExpandedTypes) {
    this.returnResultAsExpandedTypes = returnResultAsExpandedTypes;
  }


  public ValuationRequest includeOrderFlow(OrderFlowConfiguration includeOrderFlow) {
    
    this.includeOrderFlow = includeOrderFlow;
    return this;
  }

   /**
   * Get includeOrderFlow
   * @return includeOrderFlow
  **/
  @jakarta.annotation.Nullable
  public OrderFlowConfiguration getIncludeOrderFlow() {
    return includeOrderFlow;
  }


  public void setIncludeOrderFlow(OrderFlowConfiguration includeOrderFlow) {
    this.includeOrderFlow = includeOrderFlow;
  }


  public ValuationRequest portfolioEntityIds(List<PortfolioEntityId> portfolioEntityIds) {
    
    this.portfolioEntityIds = portfolioEntityIds;
    return this;
  }

  public ValuationRequest addPortfolioEntityIdsItem(PortfolioEntityId portfolioEntityIdsItem) {
    if (this.portfolioEntityIds == null) {
      this.portfolioEntityIds = new ArrayList<>();
    }
    this.portfolioEntityIds.add(portfolioEntityIdsItem);
    return this;
  }

   /**
   * The set of portfolio or portfolio group identifier(s) that is to be valued.
   * @return portfolioEntityIds
  **/
  @jakarta.annotation.Nonnull
  public List<PortfolioEntityId> getPortfolioEntityIds() {
    return portfolioEntityIds;
  }


  public void setPortfolioEntityIds(List<PortfolioEntityId> portfolioEntityIds) {
    this.portfolioEntityIds = portfolioEntityIds;
  }


  public ValuationRequest valuationSchedule(ValuationSchedule valuationSchedule) {
    
    this.valuationSchedule = valuationSchedule;
    return this;
  }

   /**
   * Get valuationSchedule
   * @return valuationSchedule
  **/
  @jakarta.annotation.Nonnull
  public ValuationSchedule getValuationSchedule() {
    return valuationSchedule;
  }


  public void setValuationSchedule(ValuationSchedule valuationSchedule) {
    this.valuationSchedule = valuationSchedule;
  }


  public ValuationRequest marketDataOverrides(MarketDataOverrides marketDataOverrides) {
    
    this.marketDataOverrides = marketDataOverrides;
    return this;
  }

   /**
   * Get marketDataOverrides
   * @return marketDataOverrides
  **/
  @jakarta.annotation.Nullable
  public MarketDataOverrides getMarketDataOverrides() {
    return marketDataOverrides;
  }


  public void setMarketDataOverrides(MarketDataOverrides marketDataOverrides) {
    this.marketDataOverrides = marketDataOverrides;
  }


  public ValuationRequest corporateActionSourceId(ResourceId corporateActionSourceId) {
    
    this.corporateActionSourceId = corporateActionSourceId;
    return this;
  }

   /**
   * Get corporateActionSourceId
   * @return corporateActionSourceId
  **/
  @jakarta.annotation.Nullable
  public ResourceId getCorporateActionSourceId() {
    return corporateActionSourceId;
  }


  public void setCorporateActionSourceId(ResourceId corporateActionSourceId) {
    this.corporateActionSourceId = corporateActionSourceId;
  }



  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    ValuationRequest valuationRequest = (ValuationRequest) o;
    return Objects.equals(this.recipeId, valuationRequest.recipeId) &&
        Objects.equals(this.asAt, valuationRequest.asAt) &&
        Objects.equals(this.metrics, valuationRequest.metrics) &&
        Objects.equals(this.groupBy, valuationRequest.groupBy) &&
        Objects.equals(this.filters, valuationRequest.filters) &&
        Objects.equals(this.sort, valuationRequest.sort) &&
        Objects.equals(this.reportCurrency, valuationRequest.reportCurrency) &&
        Objects.equals(this.equipWithSubtotals, valuationRequest.equipWithSubtotals) &&
        Objects.equals(this.returnResultAsExpandedTypes, valuationRequest.returnResultAsExpandedTypes) &&
        Objects.equals(this.includeOrderFlow, valuationRequest.includeOrderFlow) &&
        Objects.equals(this.portfolioEntityIds, valuationRequest.portfolioEntityIds) &&
        Objects.equals(this.valuationSchedule, valuationRequest.valuationSchedule) &&
        Objects.equals(this.marketDataOverrides, valuationRequest.marketDataOverrides) &&
        Objects.equals(this.corporateActionSourceId, valuationRequest.corporateActionSourceId);
  }

  private static <T> boolean equalsNullable(JsonNullable<T> a, JsonNullable<T> b) {
    return a == b || (a != null && b != null && a.isPresent() && b.isPresent() && Objects.deepEquals(a.get(), b.get()));
  }

  @Override
  public int hashCode() {
    return Objects.hash(recipeId, asAt, metrics, groupBy, filters, sort, reportCurrency, equipWithSubtotals, returnResultAsExpandedTypes, includeOrderFlow, portfolioEntityIds, valuationSchedule, marketDataOverrides, corporateActionSourceId);
  }

  private static <T> int hashCodeNullable(JsonNullable<T> a) {
    if (a == null) {
      return 1;
    }
    return a.isPresent() ? Arrays.deepHashCode(new Object[]{a.get()}) : 31;
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class ValuationRequest {\n");
    sb.append("    recipeId: ").append(toIndentedString(recipeId)).append("\n");
    sb.append("    asAt: ").append(toIndentedString(asAt)).append("\n");
    sb.append("    metrics: ").append(toIndentedString(metrics)).append("\n");
    sb.append("    groupBy: ").append(toIndentedString(groupBy)).append("\n");
    sb.append("    filters: ").append(toIndentedString(filters)).append("\n");
    sb.append("    sort: ").append(toIndentedString(sort)).append("\n");
    sb.append("    reportCurrency: ").append(toIndentedString(reportCurrency)).append("\n");
    sb.append("    equipWithSubtotals: ").append(toIndentedString(equipWithSubtotals)).append("\n");
    sb.append("    returnResultAsExpandedTypes: ").append(toIndentedString(returnResultAsExpandedTypes)).append("\n");
    sb.append("    includeOrderFlow: ").append(toIndentedString(includeOrderFlow)).append("\n");
    sb.append("    portfolioEntityIds: ").append(toIndentedString(portfolioEntityIds)).append("\n");
    sb.append("    valuationSchedule: ").append(toIndentedString(valuationSchedule)).append("\n");
    sb.append("    marketDataOverrides: ").append(toIndentedString(marketDataOverrides)).append("\n");
    sb.append("    corporateActionSourceId: ").append(toIndentedString(corporateActionSourceId)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }


  public static HashSet<String> openapiFields;
  public static HashSet<String> openapiRequiredFields;

  static {
    // a set of all properties/fields (JSON key names)
    openapiFields = new HashSet<String>();
    openapiFields.add("recipeId");
    openapiFields.add("asAt");
    openapiFields.add("metrics");
    openapiFields.add("groupBy");
    openapiFields.add("filters");
    openapiFields.add("sort");
    openapiFields.add("reportCurrency");
    openapiFields.add("equipWithSubtotals");
    openapiFields.add("returnResultAsExpandedTypes");
    openapiFields.add("includeOrderFlow");
    openapiFields.add("portfolioEntityIds");
    openapiFields.add("valuationSchedule");
    openapiFields.add("marketDataOverrides");
    openapiFields.add("corporateActionSourceId");

    // a set of required properties/fields (JSON key names)
    openapiRequiredFields = new HashSet<String>();
    openapiRequiredFields.add("recipeId");
    openapiRequiredFields.add("metrics");
    openapiRequiredFields.add("portfolioEntityIds");
    openapiRequiredFields.add("valuationSchedule");
  }

 /**
  * Validates the JSON Element and throws an exception if issues found
  *
  * @param jsonElement JSON Element
  * @throws IOException if the JSON Element is invalid with respect to ValuationRequest
  */
  public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      if (jsonElement == null) {
        if (!ValuationRequest.openapiRequiredFields.isEmpty()) { // has required fields but JSON element is null
          throw new IllegalArgumentException(String.format("The required field(s) %s in ValuationRequest is not found in the empty JSON string", ValuationRequest.openapiRequiredFields.toString()));
        }
      }

      // check to make sure all required properties/fields are present in the JSON string
      for (String requiredField : ValuationRequest.openapiRequiredFields) {
        if (jsonElement.getAsJsonObject().get(requiredField) == null) {
          throw new IllegalArgumentException(String.format("The required field `%s` is not found in the JSON string: %s", requiredField, jsonElement.toString()));
        }
      }
        JsonObject jsonObj = jsonElement.getAsJsonObject();
      // validate the required field `recipeId`
      ResourceId.validateJsonElement(jsonObj.get("recipeId"));
      // ensure the json data is an array
      if (!jsonObj.get("metrics").isJsonArray()) {
        throw new IllegalArgumentException(String.format("Expected the field `metrics` to be an array in the JSON string but got `%s`", jsonObj.get("metrics").toString()));
      }

      JsonArray jsonArraymetrics = jsonObj.getAsJsonArray("metrics");
      // validate the required field `metrics` (array)
      for (int i = 0; i < jsonArraymetrics.size(); i++) {
        AggregateSpec.validateJsonElement(jsonArraymetrics.get(i));
      };
      // ensure the optional json data is an array if present
      if (jsonObj.get("groupBy") != null && !jsonObj.get("groupBy").isJsonNull() && !jsonObj.get("groupBy").isJsonArray()) {
        throw new IllegalArgumentException(String.format("Expected the field `groupBy` to be an array in the JSON string but got `%s`", jsonObj.get("groupBy").toString()));
      }
      if (jsonObj.get("filters") != null && !jsonObj.get("filters").isJsonNull()) {
        JsonArray jsonArrayfilters = jsonObj.getAsJsonArray("filters");
        if (jsonArrayfilters != null) {
          // ensure the json data is an array
          if (!jsonObj.get("filters").isJsonArray()) {
            throw new IllegalArgumentException(String.format("Expected the field `filters` to be an array in the JSON string but got `%s`", jsonObj.get("filters").toString()));
          }

          // validate the optional field `filters` (array)
          for (int i = 0; i < jsonArrayfilters.size(); i++) {
            PropertyFilter.validateJsonElement(jsonArrayfilters.get(i));
          };
        }
      }
      if (jsonObj.get("sort") != null && !jsonObj.get("sort").isJsonNull()) {
        JsonArray jsonArraysort = jsonObj.getAsJsonArray("sort");
        if (jsonArraysort != null) {
          // ensure the json data is an array
          if (!jsonObj.get("sort").isJsonArray()) {
            throw new IllegalArgumentException(String.format("Expected the field `sort` to be an array in the JSON string but got `%s`", jsonObj.get("sort").toString()));
          }

          // validate the optional field `sort` (array)
          for (int i = 0; i < jsonArraysort.size(); i++) {
            OrderBySpec.validateJsonElement(jsonArraysort.get(i));
          };
        }
      }
      if ((jsonObj.get("reportCurrency") != null && !jsonObj.get("reportCurrency").isJsonNull()) && !jsonObj.get("reportCurrency").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `reportCurrency` to be a primitive type in the JSON string but got `%s`", jsonObj.get("reportCurrency").toString()));
      }
      // validate the optional field `includeOrderFlow`
      if (jsonObj.get("includeOrderFlow") != null && !jsonObj.get("includeOrderFlow").isJsonNull()) {
        OrderFlowConfiguration.validateJsonElement(jsonObj.get("includeOrderFlow"));
      }
      // ensure the json data is an array
      if (!jsonObj.get("portfolioEntityIds").isJsonArray()) {
        throw new IllegalArgumentException(String.format("Expected the field `portfolioEntityIds` to be an array in the JSON string but got `%s`", jsonObj.get("portfolioEntityIds").toString()));
      }

      JsonArray jsonArrayportfolioEntityIds = jsonObj.getAsJsonArray("portfolioEntityIds");
      // validate the required field `portfolioEntityIds` (array)
      for (int i = 0; i < jsonArrayportfolioEntityIds.size(); i++) {
        PortfolioEntityId.validateJsonElement(jsonArrayportfolioEntityIds.get(i));
      };
      // validate the required field `valuationSchedule`
      ValuationSchedule.validateJsonElement(jsonObj.get("valuationSchedule"));
      // validate the optional field `marketDataOverrides`
      if (jsonObj.get("marketDataOverrides") != null && !jsonObj.get("marketDataOverrides").isJsonNull()) {
        MarketDataOverrides.validateJsonElement(jsonObj.get("marketDataOverrides"));
      }
      // validate the optional field `corporateActionSourceId`
      if (jsonObj.get("corporateActionSourceId") != null && !jsonObj.get("corporateActionSourceId").isJsonNull()) {
        ResourceId.validateJsonElement(jsonObj.get("corporateActionSourceId"));
      }
  }

  public static class CustomTypeAdapterFactory implements TypeAdapterFactory {
    @SuppressWarnings("unchecked")
    @Override
    public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {
       if (!ValuationRequest.class.isAssignableFrom(type.getRawType())) {
         return null; // this class only serializes 'ValuationRequest' and its subtypes
       }
       final TypeAdapter<JsonElement> elementAdapter = gson.getAdapter(JsonElement.class);
       final TypeAdapter<ValuationRequest> thisAdapter
                        = gson.getDelegateAdapter(this, TypeToken.get(ValuationRequest.class));

       return (TypeAdapter<T>) new TypeAdapter<ValuationRequest>() {
           @Override
           public void write(JsonWriter out, ValuationRequest value) throws IOException {
             JsonObject obj = thisAdapter.toJsonTree(value).getAsJsonObject();
             elementAdapter.write(out, obj);
           }

           @Override
           public ValuationRequest read(JsonReader in) throws IOException {
             JsonElement jsonElement = elementAdapter.read(in);
             validateJsonElement(jsonElement);
             return thisAdapter.fromJsonTree(jsonElement);
           }

       }.nullSafe();
    }
  }

 /**
  * Create an instance of ValuationRequest given an JSON string
  *
  * @param jsonString JSON string
  * @return An instance of ValuationRequest
  * @throws IOException if the JSON string is invalid with respect to ValuationRequest
  */
  public static ValuationRequest fromJson(String jsonString) throws IOException {
    return JSON.getGson().fromJson(jsonString, ValuationRequest.class);
  }

 /**
  * Convert an instance of ValuationRequest to an JSON string
  *
  * @return JSON string
  */
  public String toJson() {
    return JSON.getGson().toJson(this);
  }
}
