/*
 * LUSID API
 *
 * Contact: info@finbourne.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

package com.finbourne.lusid.model;

import java.util.Objects;
import com.finbourne.lusid.model.EarlyRedemptionElection;
import com.finbourne.lusid.model.InstrumentEvent;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;
import java.time.OffsetDateTime;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import org.openapitools.jackson.nullable.JsonNullable;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonArray;
import com.google.gson.JsonDeserializationContext;
import com.google.gson.JsonDeserializer;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParseException;
import com.google.gson.TypeAdapterFactory;
import com.google.gson.reflect.TypeToken;
import com.google.gson.TypeAdapter;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;

import java.lang.reflect.Type;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Map.Entry;
import java.util.Set;

import com.finbourne.lusid.JSON;

/**
 * Early redemption as a consequence of a bond being called or putted.
 */
@jakarta.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen")
public class EarlyRedemptionEvent extends InstrumentEvent {
  public static final String SERIALIZED_NAME_EFFECTIVE_DATE = "effectiveDate";
  @SerializedName(SERIALIZED_NAME_EFFECTIVE_DATE)
  private OffsetDateTime effectiveDate;

  public static final String SERIALIZED_NAME_CURRENCY = "currency";
  @SerializedName(SERIALIZED_NAME_CURRENCY)
  private String currency;

  public static final String SERIALIZED_NAME_EARLY_REDEMPTION_ELECTIONS = "earlyRedemptionElections";
  @SerializedName(SERIALIZED_NAME_EARLY_REDEMPTION_ELECTIONS)
  private List<EarlyRedemptionElection> earlyRedemptionElections = new ArrayList<>();

  public static final String SERIALIZED_NAME_REDEMPTION_PERCENTAGE = "redemptionPercentage";
  @SerializedName(SERIALIZED_NAME_REDEMPTION_PERCENTAGE)
  private java.math.BigDecimal redemptionPercentage;

  public static final String SERIALIZED_NAME_PRICE_PER_UNIT = "pricePerUnit";
  @SerializedName(SERIALIZED_NAME_PRICE_PER_UNIT)
  private java.math.BigDecimal pricePerUnit;

  public static final String SERIALIZED_NAME_ACCRUED_INTEREST_PER_UNIT = "accruedInterestPerUnit";
  @SerializedName(SERIALIZED_NAME_ACCRUED_INTEREST_PER_UNIT)
  private java.math.BigDecimal accruedInterestPerUnit;

  public EarlyRedemptionEvent() {
    // this.instrumentEventType = this.getClass().getSimpleName();
  }

  public EarlyRedemptionEvent effectiveDate(OffsetDateTime effectiveDate) {
    
    this.effectiveDate = effectiveDate;
    return this;
  }

   /**
   * Date of redemption. For internally generated European callables, this is set to the exercise date. For internally generated American callables, this is set to the start of the exercise period.
   * @return effectiveDate
  **/
  @jakarta.annotation.Nullable
  public OffsetDateTime getEffectiveDate() {
    return effectiveDate;
  }


  public void setEffectiveDate(OffsetDateTime effectiveDate) {
    this.effectiveDate = effectiveDate;
  }


  public EarlyRedemptionEvent currency(String currency) {
    
    this.currency = currency;
    return this;
  }

   /**
   * Currency of the redemption.
   * @return currency
  **/
  @jakarta.annotation.Nonnull
  public String getCurrency() {
    return currency;
  }


  public void setCurrency(String currency) {
    this.currency = currency;
  }


  public EarlyRedemptionEvent earlyRedemptionElections(List<EarlyRedemptionElection> earlyRedemptionElections) {
    
    this.earlyRedemptionElections = earlyRedemptionElections;
    return this;
  }

  public EarlyRedemptionEvent addEarlyRedemptionElectionsItem(EarlyRedemptionElection earlyRedemptionElectionsItem) {
    if (this.earlyRedemptionElections == null) {
      this.earlyRedemptionElections = new ArrayList<>();
    }
    this.earlyRedemptionElections.add(earlyRedemptionElectionsItem);
    return this;
  }

   /**
   * EarlyRedemptionElection for the redemption. Used to trigger the redemption.
   * @return earlyRedemptionElections
  **/
  @jakarta.annotation.Nonnull
  public List<EarlyRedemptionElection> getEarlyRedemptionElections() {
    return earlyRedemptionElections;
  }


  public void setEarlyRedemptionElections(List<EarlyRedemptionElection> earlyRedemptionElections) {
    this.earlyRedemptionElections = earlyRedemptionElections;
  }


  public EarlyRedemptionEvent redemptionPercentage(java.math.BigDecimal redemptionPercentage) {
    
    this.redemptionPercentage = redemptionPercentage;
    return this;
  }

   /**
   * Percentage of the original issue that is redeemed, where 0.5 implies 50%. Defaults to 1 if not set. Must be between 0 and 1.
   * @return redemptionPercentage
  **/
  @jakarta.annotation.Nullable
  public java.math.BigDecimal getRedemptionPercentage() {
    return redemptionPercentage;
  }


  public void setRedemptionPercentage(java.math.BigDecimal redemptionPercentage) {
    this.redemptionPercentage = redemptionPercentage;
  }


  public EarlyRedemptionEvent pricePerUnit(java.math.BigDecimal pricePerUnit) {
    
    this.pricePerUnit = pricePerUnit;
    return this;
  }

   /**
   * The price, or strike, that each unit is redeemed at.
   * @return pricePerUnit
  **/
  @jakarta.annotation.Nullable
  public java.math.BigDecimal getPricePerUnit() {
    return pricePerUnit;
  }


  public void setPricePerUnit(java.math.BigDecimal pricePerUnit) {
    this.pricePerUnit = pricePerUnit;
  }


  public EarlyRedemptionEvent accruedInterestPerUnit(java.math.BigDecimal accruedInterestPerUnit) {
    
    this.accruedInterestPerUnit = accruedInterestPerUnit;
    return this;
  }

   /**
   * Unpaid accrued interest also repaid as part of the redemption, per unit. Optional field. If left empty, will be resolved internally by calculating the accrued owed on the EffectiveDate. This process may require additional market data.
   * @return accruedInterestPerUnit
  **/
  @jakarta.annotation.Nullable
  public java.math.BigDecimal getAccruedInterestPerUnit() {
    return accruedInterestPerUnit;
  }


  public void setAccruedInterestPerUnit(java.math.BigDecimal accruedInterestPerUnit) {
    this.accruedInterestPerUnit = accruedInterestPerUnit;
  }



  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    EarlyRedemptionEvent earlyRedemptionEvent = (EarlyRedemptionEvent) o;
    return Objects.equals(this.effectiveDate, earlyRedemptionEvent.effectiveDate) &&
        Objects.equals(this.currency, earlyRedemptionEvent.currency) &&
        Objects.equals(this.earlyRedemptionElections, earlyRedemptionEvent.earlyRedemptionElections) &&
        (this.redemptionPercentage.compareTo(earlyRedemptionEvent.getRedemptionPercentage()) == 0) &&
        (this.pricePerUnit.compareTo(earlyRedemptionEvent.getPricePerUnit()) == 0) &&
        (this.accruedInterestPerUnit.compareTo(earlyRedemptionEvent.getAccruedInterestPerUnit()) == 0) &&
        super.equals(o);
  }

  private static <T> boolean equalsNullable(JsonNullable<T> a, JsonNullable<T> b) {
    return a == b || (a != null && b != null && a.isPresent() && b.isPresent() && Objects.deepEquals(a.get(), b.get()));
  }

  @Override
  public int hashCode() {
    return Objects.hash(effectiveDate, currency, earlyRedemptionElections, redemptionPercentage, pricePerUnit, accruedInterestPerUnit, super.hashCode());
  }

  private static <T> int hashCodeNullable(JsonNullable<T> a) {
    if (a == null) {
      return 1;
    }
    return a.isPresent() ? Arrays.deepHashCode(new Object[]{a.get()}) : 31;
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class EarlyRedemptionEvent {\n");
    sb.append("    ").append(toIndentedString(super.toString())).append("\n");
    sb.append("    effectiveDate: ").append(toIndentedString(effectiveDate)).append("\n");
    sb.append("    currency: ").append(toIndentedString(currency)).append("\n");
    sb.append("    earlyRedemptionElections: ").append(toIndentedString(earlyRedemptionElections)).append("\n");
    sb.append("    redemptionPercentage: ").append(toIndentedString(redemptionPercentage)).append("\n");
    sb.append("    pricePerUnit: ").append(toIndentedString(pricePerUnit)).append("\n");
    sb.append("    accruedInterestPerUnit: ").append(toIndentedString(accruedInterestPerUnit)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }


  public static HashSet<String> openapiFields;
  public static HashSet<String> openapiRequiredFields;

  static {
    // a set of all properties/fields (JSON key names)
    openapiFields = new HashSet<String>();
    openapiFields.add("instrumentEventType");
    openapiFields.add("effectiveDate");
    openapiFields.add("currency");
    openapiFields.add("earlyRedemptionElections");
    openapiFields.add("redemptionPercentage");
    openapiFields.add("pricePerUnit");
    openapiFields.add("accruedInterestPerUnit");

    // a set of required properties/fields (JSON key names)
    openapiRequiredFields = new HashSet<String>();
    openapiRequiredFields.add("currency");
    openapiRequiredFields.add("earlyRedemptionElections");
    openapiRequiredFields.add("instrumentEventType");
  }

 /**
  * Validates the JSON Element and throws an exception if issues found
  *
  * @param jsonElement JSON Element
  * @throws IOException if the JSON Element is invalid with respect to EarlyRedemptionEvent
  */
  public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      if (jsonElement == null) {
        if (!EarlyRedemptionEvent.openapiRequiredFields.isEmpty()) { // has required fields but JSON element is null
          throw new IllegalArgumentException(String.format("The required field(s) %s in EarlyRedemptionEvent is not found in the empty JSON string", EarlyRedemptionEvent.openapiRequiredFields.toString()));
        }
      }

      // check to make sure all required properties/fields are present in the JSON string
      for (String requiredField : EarlyRedemptionEvent.openapiRequiredFields) {
        if (jsonElement.getAsJsonObject().get(requiredField) == null) {
          throw new IllegalArgumentException(String.format("The required field `%s` is not found in the JSON string: %s", requiredField, jsonElement.toString()));
        }
      }
  }

  public static class CustomTypeAdapterFactory implements TypeAdapterFactory {
    @SuppressWarnings("unchecked")
    @Override
    public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {
       if (!EarlyRedemptionEvent.class.isAssignableFrom(type.getRawType())) {
         return null; // this class only serializes 'EarlyRedemptionEvent' and its subtypes
       }
       final TypeAdapter<JsonElement> elementAdapter = gson.getAdapter(JsonElement.class);
       final TypeAdapter<EarlyRedemptionEvent> thisAdapter
                        = gson.getDelegateAdapter(this, TypeToken.get(EarlyRedemptionEvent.class));

       return (TypeAdapter<T>) new TypeAdapter<EarlyRedemptionEvent>() {
           @Override
           public void write(JsonWriter out, EarlyRedemptionEvent value) throws IOException {
             JsonObject obj = thisAdapter.toJsonTree(value).getAsJsonObject();
             elementAdapter.write(out, obj);
           }

           @Override
           public EarlyRedemptionEvent read(JsonReader in) throws IOException {
             JsonElement jsonElement = elementAdapter.read(in);
             validateJsonElement(jsonElement);
             return thisAdapter.fromJsonTree(jsonElement);
           }

       }.nullSafe();
    }
  }

 /**
  * Create an instance of EarlyRedemptionEvent given an JSON string
  *
  * @param jsonString JSON string
  * @return An instance of EarlyRedemptionEvent
  * @throws IOException if the JSON string is invalid with respect to EarlyRedemptionEvent
  */
  public static EarlyRedemptionEvent fromJson(String jsonString) throws IOException {
    return JSON.getGson().fromJson(jsonString, EarlyRedemptionEvent.class);
  }

 /**
  * Convert an instance of EarlyRedemptionEvent to an JSON string
  *
  * @return JSON string
  */
  public String toJson() {
    return JSON.getGson().toJson(this);
  }
}
