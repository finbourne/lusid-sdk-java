/*
 * LUSID API
 *
 * Contact: info@finbourne.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

package com.finbourne.lusid.model;

import java.util.Objects;
import com.finbourne.lusid.model.ExDividendConfiguration;
import com.finbourne.lusid.model.FlowConventions;
import com.finbourne.lusid.model.LusidInstrument;
import com.finbourne.lusid.model.RoundingConvention;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;
import java.time.OffsetDateTime;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import org.openapitools.jackson.nullable.JsonNullable;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonArray;
import com.google.gson.JsonDeserializationContext;
import com.google.gson.JsonDeserializer;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParseException;
import com.google.gson.TypeAdapterFactory;
import com.google.gson.reflect.TypeToken;
import com.google.gson.TypeAdapter;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;

import java.lang.reflect.Type;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Map.Entry;
import java.util.Set;

import com.finbourne.lusid.JSON;

/**
 * LUSID representation of a Vanilla Fixed Rate Bond.
 */
@jakarta.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen")
public class Bond extends LusidInstrument {
  public static final String SERIALIZED_NAME_START_DATE = "startDate";
  @SerializedName(SERIALIZED_NAME_START_DATE)
  private OffsetDateTime startDate;

  public static final String SERIALIZED_NAME_MATURITY_DATE = "maturityDate";
  @SerializedName(SERIALIZED_NAME_MATURITY_DATE)
  private OffsetDateTime maturityDate;

  public static final String SERIALIZED_NAME_DOM_CCY = "domCcy";
  @SerializedName(SERIALIZED_NAME_DOM_CCY)
  private String domCcy;

  public static final String SERIALIZED_NAME_FLOW_CONVENTIONS = "flowConventions";
  @SerializedName(SERIALIZED_NAME_FLOW_CONVENTIONS)
  private FlowConventions flowConventions;

  public static final String SERIALIZED_NAME_PRINCIPAL = "principal";
  @SerializedName(SERIALIZED_NAME_PRINCIPAL)
  private java.math.BigDecimal principal;

  public static final String SERIALIZED_NAME_COUPON_RATE = "couponRate";
  @SerializedName(SERIALIZED_NAME_COUPON_RATE)
  private java.math.BigDecimal couponRate;

  public static final String SERIALIZED_NAME_IDENTIFIERS = "identifiers";
  @SerializedName(SERIALIZED_NAME_IDENTIFIERS)
  private Map<String, String> identifiers;

  public static final String SERIALIZED_NAME_EX_DIVIDEND_DAYS = "exDividendDays";
  @SerializedName(SERIALIZED_NAME_EX_DIVIDEND_DAYS)
  private Integer exDividendDays;

  public static final String SERIALIZED_NAME_INITIAL_COUPON_DATE = "initialCouponDate";
  @SerializedName(SERIALIZED_NAME_INITIAL_COUPON_DATE)
  private OffsetDateTime initialCouponDate;

  public static final String SERIALIZED_NAME_FIRST_COUPON_PAY_DATE = "firstCouponPayDate";
  @SerializedName(SERIALIZED_NAME_FIRST_COUPON_PAY_DATE)
  private OffsetDateTime firstCouponPayDate;

  public static final String SERIALIZED_NAME_CALCULATION_TYPE = "calculationType";
  @SerializedName(SERIALIZED_NAME_CALCULATION_TYPE)
  private String calculationType;

  public static final String SERIALIZED_NAME_ROUNDING_CONVENTIONS = "roundingConventions";
  @SerializedName(SERIALIZED_NAME_ROUNDING_CONVENTIONS)
  private List<RoundingConvention> roundingConventions;

  public static final String SERIALIZED_NAME_EX_DIVIDEND_CONFIGURATION = "exDividendConfiguration";
  @SerializedName(SERIALIZED_NAME_EX_DIVIDEND_CONFIGURATION)
  private ExDividendConfiguration exDividendConfiguration;

  public static final String SERIALIZED_NAME_ORIGINAL_ISSUE_PRICE = "originalIssuePrice";
  @SerializedName(SERIALIZED_NAME_ORIGINAL_ISSUE_PRICE)
  private java.math.BigDecimal originalIssuePrice;

  public Bond() {
    // this.instrumentType = this.getClass().getSimpleName();
  }

  public Bond startDate(OffsetDateTime startDate) {
    
    this.startDate = startDate;
    return this;
  }

   /**
   * The Start date of the bond, this is normally when accrual of the first coupon begins.
   * @return startDate
  **/
  @jakarta.annotation.Nonnull
  public OffsetDateTime getStartDate() {
    return startDate;
  }


  public void setStartDate(OffsetDateTime startDate) {
    this.startDate = startDate;
  }


  public Bond maturityDate(OffsetDateTime maturityDate) {
    
    this.maturityDate = maturityDate;
    return this;
  }

   /**
   * The Maturity date of the bond, this is when the last coupon accrual period ends.  Note that while most bonds have their last payment on this date there are some cases where the final payment is the next working day.
   * @return maturityDate
  **/
  @jakarta.annotation.Nonnull
  public OffsetDateTime getMaturityDate() {
    return maturityDate;
  }


  public void setMaturityDate(OffsetDateTime maturityDate) {
    this.maturityDate = maturityDate;
  }


  public Bond domCcy(String domCcy) {
    
    this.domCcy = domCcy;
    return this;
  }

   /**
   * The domestic currency of the instrument. This should be the same as the Currency set on the FlowConventions.
   * @return domCcy
  **/
  @jakarta.annotation.Nonnull
  public String getDomCcy() {
    return domCcy;
  }


  public void setDomCcy(String domCcy) {
    this.domCcy = domCcy;
  }


  public Bond flowConventions(FlowConventions flowConventions) {
    
    this.flowConventions = flowConventions;
    return this;
  }

   /**
   * Get flowConventions
   * @return flowConventions
  **/
  @jakarta.annotation.Nonnull
  public FlowConventions getFlowConventions() {
    return flowConventions;
  }


  public void setFlowConventions(FlowConventions flowConventions) {
    this.flowConventions = flowConventions;
  }


  public Bond principal(java.math.BigDecimal principal) {
    
    this.principal = principal;
    return this;
  }

   /**
   * The face-value or principal for the bond at outset.  This might be reduced through its lifetime in the event of amortisation or similar.
   * @return principal
  **/
  @jakarta.annotation.Nonnull
  public java.math.BigDecimal getPrincipal() {
    return principal;
  }


  public void setPrincipal(java.math.BigDecimal principal) {
    this.principal = principal;
  }


  public Bond couponRate(java.math.BigDecimal couponRate) {
    
    this.couponRate = couponRate;
    return this;
  }

   /**
   * Simple coupon rate.
   * @return couponRate
  **/
  @jakarta.annotation.Nonnull
  public java.math.BigDecimal getCouponRate() {
    return couponRate;
  }


  public void setCouponRate(java.math.BigDecimal couponRate) {
    this.couponRate = couponRate;
  }


  public Bond identifiers(Map<String, String> identifiers) {
    
    this.identifiers = identifiers;
    return this;
  }

  public Bond putIdentifiersItem(String key, String identifiersItem) {
    if (this.identifiers == null) {
      this.identifiers = new HashMap<>();
    }
    this.identifiers.put(key, identifiersItem);
    return this;
  }

   /**
   * External market codes and identifiers for the bond, e.g. ISIN.
   * @return identifiers
  **/
  @jakarta.annotation.Nullable
  public Map<String, String> getIdentifiers() {
    return identifiers;
  }


  public void setIdentifiers(Map<String, String> identifiers) {
    this.identifiers = identifiers;
  }


  public Bond exDividendDays(Integer exDividendDays) {
    
    this.exDividendDays = exDividendDays;
    return this;
  }

   /**
   * Optional. Number of calendar days in the ex-dividend period.  If the settlement date falls in the ex-dividend period then the coupon paid is zero and the accrued interest is negative.  If set, this must be a non-negative number.  If not set, or set to 0, then there is no ex-dividend period.     NOTE: This field is deprecated. If you wish to set the ExDividendDays on a bond, please use the ExDividendConfiguration.
   * @return exDividendDays
  **/
  @jakarta.annotation.Nullable
  public Integer getExDividendDays() {
    return exDividendDays;
  }


  public void setExDividendDays(Integer exDividendDays) {
    this.exDividendDays = exDividendDays;
  }


  public Bond initialCouponDate(OffsetDateTime initialCouponDate) {
    
    this.initialCouponDate = initialCouponDate;
    return this;
  }

   /**
   * Optional and to be DEPRECATED. If set, this is the date at which the bond begins to accrue interest. Instead, this information should be entered in the field StartDate.
   * @return initialCouponDate
  **/
  @jakarta.annotation.Nullable
  public OffsetDateTime getInitialCouponDate() {
    return initialCouponDate;
  }


  public void setInitialCouponDate(OffsetDateTime initialCouponDate) {
    this.initialCouponDate = initialCouponDate;
  }


  public Bond firstCouponPayDate(OffsetDateTime firstCouponPayDate) {
    
    this.firstCouponPayDate = firstCouponPayDate;
    return this;
  }

   /**
   * The date that the first coupon of the bond is paid. This is required for bonds that have a long first coupon or short first coupon. The first coupon pay date is used  as an anchor to compare with the start date and determine if this is a long/short coupon period.
   * @return firstCouponPayDate
  **/
  @jakarta.annotation.Nullable
  public OffsetDateTime getFirstCouponPayDate() {
    return firstCouponPayDate;
  }


  public void setFirstCouponPayDate(OffsetDateTime firstCouponPayDate) {
    this.firstCouponPayDate = firstCouponPayDate;
  }


  public Bond calculationType(String calculationType) {
    
    this.calculationType = calculationType;
    return this;
  }

   /**
   * The calculation type applied to the bond coupon amount. This is required for bonds that have a particular type of computing the period coupon, such as simple compounding,  irregular coupons etc.  The default CalculationType is &#x60;Standard&#x60;, which returns a coupon amount equal to Principal generate justfile test_sdk Coupon Rate / Coupon Frequency. Coupon Frequency is 12M / Payment Frequency.  Payment Frequency can be 1M, 3M, 6M, 12M etc. So Coupon Frequency can be 12, 4, 2, 1 respectively.    Supported string (enumeration) values are: [Standard, DayCountCoupon, NoCalculationFloater, BrazilFixedCoupon].
   * @return calculationType
  **/
  @jakarta.annotation.Nullable
  public String getCalculationType() {
    return calculationType;
  }


  public void setCalculationType(String calculationType) {
    this.calculationType = calculationType;
  }


  public Bond roundingConventions(List<RoundingConvention> roundingConventions) {
    
    this.roundingConventions = roundingConventions;
    return this;
  }

  public Bond addRoundingConventionsItem(RoundingConvention roundingConventionsItem) {
    if (this.roundingConventions == null) {
      this.roundingConventions = new ArrayList<>();
    }
    this.roundingConventions.add(roundingConventionsItem);
    return this;
  }

   /**
   * Rounding conventions for analytics, if any.
   * @return roundingConventions
  **/
  @jakarta.annotation.Nullable
  public List<RoundingConvention> getRoundingConventions() {
    return roundingConventions;
  }


  public void setRoundingConventions(List<RoundingConvention> roundingConventions) {
    this.roundingConventions = roundingConventions;
  }


  public Bond exDividendConfiguration(ExDividendConfiguration exDividendConfiguration) {
    
    this.exDividendConfiguration = exDividendConfiguration;
    return this;
  }

   /**
   * Get exDividendConfiguration
   * @return exDividendConfiguration
  **/
  @jakarta.annotation.Nullable
  public ExDividendConfiguration getExDividendConfiguration() {
    return exDividendConfiguration;
  }


  public void setExDividendConfiguration(ExDividendConfiguration exDividendConfiguration) {
    this.exDividendConfiguration = exDividendConfiguration;
  }


  public Bond originalIssuePrice(java.math.BigDecimal originalIssuePrice) {
    
    this.originalIssuePrice = originalIssuePrice;
    return this;
  }

   /**
   * The price the bond was issued at. This is to be entered as a percentage of par, for example a value of 98.5 would represent 98.5%.
   * @return originalIssuePrice
  **/
  @jakarta.annotation.Nullable
  public java.math.BigDecimal getOriginalIssuePrice() {
    return originalIssuePrice;
  }


  public void setOriginalIssuePrice(java.math.BigDecimal originalIssuePrice) {
    this.originalIssuePrice = originalIssuePrice;
  }



  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    Bond bond = (Bond) o;
    return Objects.equals(this.startDate, bond.startDate) &&
        Objects.equals(this.maturityDate, bond.maturityDate) &&
        Objects.equals(this.domCcy, bond.domCcy) &&
        Objects.equals(this.flowConventions, bond.flowConventions) &&
        (this.principal.compareTo(bond.getPrincipal()) == 0) &&
        (this.couponRate.compareTo(bond.getCouponRate()) == 0) &&
        Objects.equals(this.identifiers, bond.identifiers) &&
        Objects.equals(this.exDividendDays, bond.exDividendDays) &&
        Objects.equals(this.initialCouponDate, bond.initialCouponDate) &&
        Objects.equals(this.firstCouponPayDate, bond.firstCouponPayDate) &&
        Objects.equals(this.calculationType, bond.calculationType) &&
        Objects.equals(this.roundingConventions, bond.roundingConventions) &&
        Objects.equals(this.exDividendConfiguration, bond.exDividendConfiguration) &&
        (this.originalIssuePrice.compareTo(bond.getOriginalIssuePrice()) == 0) &&
        super.equals(o);
  }

  private static <T> boolean equalsNullable(JsonNullable<T> a, JsonNullable<T> b) {
    return a == b || (a != null && b != null && a.isPresent() && b.isPresent() && Objects.deepEquals(a.get(), b.get()));
  }

  @Override
  public int hashCode() {
    return Objects.hash(startDate, maturityDate, domCcy, flowConventions, principal, couponRate, identifiers, exDividendDays, initialCouponDate, firstCouponPayDate, calculationType, roundingConventions, exDividendConfiguration, originalIssuePrice, super.hashCode());
  }

  private static <T> int hashCodeNullable(JsonNullable<T> a) {
    if (a == null) {
      return 1;
    }
    return a.isPresent() ? Arrays.deepHashCode(new Object[]{a.get()}) : 31;
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class Bond {\n");
    sb.append("    ").append(toIndentedString(super.toString())).append("\n");
    sb.append("    startDate: ").append(toIndentedString(startDate)).append("\n");
    sb.append("    maturityDate: ").append(toIndentedString(maturityDate)).append("\n");
    sb.append("    domCcy: ").append(toIndentedString(domCcy)).append("\n");
    sb.append("    flowConventions: ").append(toIndentedString(flowConventions)).append("\n");
    sb.append("    principal: ").append(toIndentedString(principal)).append("\n");
    sb.append("    couponRate: ").append(toIndentedString(couponRate)).append("\n");
    sb.append("    identifiers: ").append(toIndentedString(identifiers)).append("\n");
    sb.append("    exDividendDays: ").append(toIndentedString(exDividendDays)).append("\n");
    sb.append("    initialCouponDate: ").append(toIndentedString(initialCouponDate)).append("\n");
    sb.append("    firstCouponPayDate: ").append(toIndentedString(firstCouponPayDate)).append("\n");
    sb.append("    calculationType: ").append(toIndentedString(calculationType)).append("\n");
    sb.append("    roundingConventions: ").append(toIndentedString(roundingConventions)).append("\n");
    sb.append("    exDividendConfiguration: ").append(toIndentedString(exDividendConfiguration)).append("\n");
    sb.append("    originalIssuePrice: ").append(toIndentedString(originalIssuePrice)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }


  public static HashSet<String> openapiFields;
  public static HashSet<String> openapiRequiredFields;

  static {
    // a set of all properties/fields (JSON key names)
    openapiFields = new HashSet<String>();
    openapiFields.add("instrumentType");
    openapiFields.add("startDate");
    openapiFields.add("maturityDate");
    openapiFields.add("domCcy");
    openapiFields.add("flowConventions");
    openapiFields.add("principal");
    openapiFields.add("couponRate");
    openapiFields.add("identifiers");
    openapiFields.add("exDividendDays");
    openapiFields.add("initialCouponDate");
    openapiFields.add("firstCouponPayDate");
    openapiFields.add("calculationType");
    openapiFields.add("roundingConventions");
    openapiFields.add("exDividendConfiguration");
    openapiFields.add("originalIssuePrice");

    // a set of required properties/fields (JSON key names)
    openapiRequiredFields = new HashSet<String>();
    openapiRequiredFields.add("startDate");
    openapiRequiredFields.add("maturityDate");
    openapiRequiredFields.add("domCcy");
    openapiRequiredFields.add("flowConventions");
    openapiRequiredFields.add("principal");
    openapiRequiredFields.add("couponRate");
    openapiRequiredFields.add("instrumentType");
  }

 /**
  * Validates the JSON Element and throws an exception if issues found
  *
  * @param jsonElement JSON Element
  * @throws IOException if the JSON Element is invalid with respect to Bond
  */
  public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      if (jsonElement == null) {
        if (!Bond.openapiRequiredFields.isEmpty()) { // has required fields but JSON element is null
          throw new IllegalArgumentException(String.format("The required field(s) %s in Bond is not found in the empty JSON string", Bond.openapiRequiredFields.toString()));
        }
      }

      // check to make sure all required properties/fields are present in the JSON string
      for (String requiredField : Bond.openapiRequiredFields) {
        if (jsonElement.getAsJsonObject().get(requiredField) == null) {
          throw new IllegalArgumentException(String.format("The required field `%s` is not found in the JSON string: %s", requiredField, jsonElement.toString()));
        }
      }
  }

  public static class CustomTypeAdapterFactory implements TypeAdapterFactory {
    @SuppressWarnings("unchecked")
    @Override
    public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {
       if (!Bond.class.isAssignableFrom(type.getRawType())) {
         return null; // this class only serializes 'Bond' and its subtypes
       }
       final TypeAdapter<JsonElement> elementAdapter = gson.getAdapter(JsonElement.class);
       final TypeAdapter<Bond> thisAdapter
                        = gson.getDelegateAdapter(this, TypeToken.get(Bond.class));

       return (TypeAdapter<T>) new TypeAdapter<Bond>() {
           @Override
           public void write(JsonWriter out, Bond value) throws IOException {
             JsonObject obj = thisAdapter.toJsonTree(value).getAsJsonObject();
             elementAdapter.write(out, obj);
           }

           @Override
           public Bond read(JsonReader in) throws IOException {
             JsonElement jsonElement = elementAdapter.read(in);
             validateJsonElement(jsonElement);
             return thisAdapter.fromJsonTree(jsonElement);
           }

       }.nullSafe();
    }
  }

 /**
  * Create an instance of Bond given an JSON string
  *
  * @param jsonString JSON string
  * @return An instance of Bond
  * @throws IOException if the JSON string is invalid with respect to Bond
  */
  public static Bond fromJson(String jsonString) throws IOException {
    return JSON.getGson().fromJson(jsonString, Bond.class);
  }

 /**
  * Convert an instance of Bond to an JSON string
  *
  * @return JSON string
  */
  public String toJson() {
    return JSON.getGson().toJson(this);
  }
}
