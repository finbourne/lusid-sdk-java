/*
 * LUSID API
 *
 * Contact: info@finbourne.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

package com.finbourne.lusid.model;

import java.util.Objects;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;
import java.time.OffsetDateTime;
import java.util.Arrays;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonArray;
import com.google.gson.JsonDeserializationContext;
import com.google.gson.JsonDeserializer;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParseException;
import com.google.gson.TypeAdapterFactory;
import com.google.gson.reflect.TypeToken;
import com.google.gson.TypeAdapter;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;

import java.lang.reflect.Type;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Map.Entry;
import java.util.Set;

import com.finbourne.lusid.JSON;

/**
 * ComplianceRunInfo
 */
@jakarta.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen")
public class ComplianceRunInfo {
  public static final String SERIALIZED_NAME_RUN_ID = "runId";
  @SerializedName(SERIALIZED_NAME_RUN_ID)
  private String runId;

  public static final String SERIALIZED_NAME_INSTIGATED_AT = "instigatedAt";
  @SerializedName(SERIALIZED_NAME_INSTIGATED_AT)
  private OffsetDateTime instigatedAt;

  public static final String SERIALIZED_NAME_COMPLETED_AT = "completedAt";
  @SerializedName(SERIALIZED_NAME_COMPLETED_AT)
  private OffsetDateTime completedAt;

  public static final String SERIALIZED_NAME_SCHEDULE = "schedule";
  @SerializedName(SERIALIZED_NAME_SCHEDULE)
  private String schedule;

  public static final String SERIALIZED_NAME_ALL_RULES_PASSED = "allRulesPassed";
  @SerializedName(SERIALIZED_NAME_ALL_RULES_PASSED)
  private Boolean allRulesPassed;

  public static final String SERIALIZED_NAME_HAS_RESULTS = "hasResults";
  @SerializedName(SERIALIZED_NAME_HAS_RESULTS)
  private Boolean hasResults;

  public static final String SERIALIZED_NAME_AS_AT = "asAt";
  @SerializedName(SERIALIZED_NAME_AS_AT)
  private OffsetDateTime asAt;

  public ComplianceRunInfo() {
  }

  public ComplianceRunInfo runId(String runId) {
    
    this.runId = runId;
    return this;
  }

   /**
   * The unique identifier of a compliance run
   * @return runId
  **/
  @jakarta.annotation.Nonnull
  public String getRunId() {
    return runId;
  }


  public void setRunId(String runId) {
    this.runId = runId;
  }


  public ComplianceRunInfo instigatedAt(OffsetDateTime instigatedAt) {
    
    this.instigatedAt = instigatedAt;
    return this;
  }

   /**
   * The time the compliance run was launched (e.g. button pressed). Currently it is also both the as at and effective at time in whichthe rule set and portfolio data (including any pending trades if the run is pretrade) is taken for the caluation, although it may be possible to run compliance for historical effective at and as at dates in the future.
   * @return instigatedAt
  **/
  @jakarta.annotation.Nonnull
  public OffsetDateTime getInstigatedAt() {
    return instigatedAt;
  }


  public void setInstigatedAt(OffsetDateTime instigatedAt) {
    this.instigatedAt = instigatedAt;
  }


  public ComplianceRunInfo completedAt(OffsetDateTime completedAt) {
    
    this.completedAt = completedAt;
    return this;
  }

   /**
   * The time the compliance run calculation was completed
   * @return completedAt
  **/
  @jakarta.annotation.Nonnull
  public OffsetDateTime getCompletedAt() {
    return completedAt;
  }


  public void setCompletedAt(OffsetDateTime completedAt) {
    this.completedAt = completedAt;
  }


  public ComplianceRunInfo schedule(String schedule) {
    
    this.schedule = schedule;
    return this;
  }

   /**
   * Whether the compliance run was pre or post trade
   * @return schedule
  **/
  @jakarta.annotation.Nonnull
  public String getSchedule() {
    return schedule;
  }


  public void setSchedule(String schedule) {
    this.schedule = schedule;
  }


  public ComplianceRunInfo allRulesPassed(Boolean allRulesPassed) {
    
    this.allRulesPassed = allRulesPassed;
    return this;
  }

   /**
   * True if all rules passed, for all the portfolios they were assigned to
   * @return allRulesPassed
  **/
  @jakarta.annotation.Nonnull
  public Boolean getAllRulesPassed() {
    return allRulesPassed;
  }


  public void setAllRulesPassed(Boolean allRulesPassed) {
    this.allRulesPassed = allRulesPassed;
  }


  public ComplianceRunInfo hasResults(Boolean hasResults) {
    
    this.hasResults = hasResults;
    return this;
  }

   /**
   * False when no results have been returned eg. when no rules exist
   * @return hasResults
  **/
  @jakarta.annotation.Nonnull
  public Boolean getHasResults() {
    return hasResults;
  }


  public void setHasResults(Boolean hasResults) {
    this.hasResults = hasResults;
  }


  public ComplianceRunInfo asAt(OffsetDateTime asAt) {
    
    this.asAt = asAt;
    return this;
  }

   /**
   * Legacy AsAt time for backwards compatibility
   * @return asAt
  **/
  @jakarta.annotation.Nonnull
  public OffsetDateTime getAsAt() {
    return asAt;
  }


  public void setAsAt(OffsetDateTime asAt) {
    this.asAt = asAt;
  }



  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    ComplianceRunInfo complianceRunInfo = (ComplianceRunInfo) o;
    return Objects.equals(this.runId, complianceRunInfo.runId) &&
        Objects.equals(this.instigatedAt, complianceRunInfo.instigatedAt) &&
        Objects.equals(this.completedAt, complianceRunInfo.completedAt) &&
        Objects.equals(this.schedule, complianceRunInfo.schedule) &&
        Objects.equals(this.allRulesPassed, complianceRunInfo.allRulesPassed) &&
        Objects.equals(this.hasResults, complianceRunInfo.hasResults) &&
        Objects.equals(this.asAt, complianceRunInfo.asAt);
  }

  @Override
  public int hashCode() {
    return Objects.hash(runId, instigatedAt, completedAt, schedule, allRulesPassed, hasResults, asAt);
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class ComplianceRunInfo {\n");
    sb.append("    runId: ").append(toIndentedString(runId)).append("\n");
    sb.append("    instigatedAt: ").append(toIndentedString(instigatedAt)).append("\n");
    sb.append("    completedAt: ").append(toIndentedString(completedAt)).append("\n");
    sb.append("    schedule: ").append(toIndentedString(schedule)).append("\n");
    sb.append("    allRulesPassed: ").append(toIndentedString(allRulesPassed)).append("\n");
    sb.append("    hasResults: ").append(toIndentedString(hasResults)).append("\n");
    sb.append("    asAt: ").append(toIndentedString(asAt)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }


  public static HashSet<String> openapiFields;
  public static HashSet<String> openapiRequiredFields;

  static {
    // a set of all properties/fields (JSON key names)
    openapiFields = new HashSet<String>();
    openapiFields.add("runId");
    openapiFields.add("instigatedAt");
    openapiFields.add("completedAt");
    openapiFields.add("schedule");
    openapiFields.add("allRulesPassed");
    openapiFields.add("hasResults");
    openapiFields.add("asAt");

    // a set of required properties/fields (JSON key names)
    openapiRequiredFields = new HashSet<String>();
    openapiRequiredFields.add("runId");
    openapiRequiredFields.add("instigatedAt");
    openapiRequiredFields.add("completedAt");
    openapiRequiredFields.add("schedule");
    openapiRequiredFields.add("allRulesPassed");
    openapiRequiredFields.add("hasResults");
    openapiRequiredFields.add("asAt");
  }

 /**
  * Validates the JSON Object and throws an exception if issues found
  *
  * @param jsonObj JSON Object
  * @throws IOException if the JSON Object is invalid with respect to ComplianceRunInfo
  */
  public static void validateJsonObject(JsonObject jsonObj) throws IOException {
      if (jsonObj == null) {
        if (!ComplianceRunInfo.openapiRequiredFields.isEmpty()) { // has required fields but JSON object is null
          throw new IllegalArgumentException(String.format("The required field(s) %s in ComplianceRunInfo is not found in the empty JSON string", ComplianceRunInfo.openapiRequiredFields.toString()));
        }
      }

      Set<Entry<String, JsonElement>> entries = jsonObj.entrySet();
      // check to see if the JSON string contains additional fields
      for (Entry<String, JsonElement> entry : entries) {
        if (!ComplianceRunInfo.openapiFields.contains(entry.getKey())) {
          throw new IllegalArgumentException(String.format("The field `%s` in the JSON string is not defined in the `ComplianceRunInfo` properties. JSON: %s", entry.getKey(), jsonObj.toString()));
        }
      }

      // check to make sure all required properties/fields are present in the JSON string
      for (String requiredField : ComplianceRunInfo.openapiRequiredFields) {
        if (jsonObj.get(requiredField) == null) {
          throw new IllegalArgumentException(String.format("The required field `%s` is not found in the JSON string: %s", requiredField, jsonObj.toString()));
        }
      }
      if (!jsonObj.get("runId").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `runId` to be a primitive type in the JSON string but got `%s`", jsonObj.get("runId").toString()));
      }
      if (!jsonObj.get("schedule").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `schedule` to be a primitive type in the JSON string but got `%s`", jsonObj.get("schedule").toString()));
      }
  }

  public static class CustomTypeAdapterFactory implements TypeAdapterFactory {
    @SuppressWarnings("unchecked")
    @Override
    public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {
       if (!ComplianceRunInfo.class.isAssignableFrom(type.getRawType())) {
         return null; // this class only serializes 'ComplianceRunInfo' and its subtypes
       }
       final TypeAdapter<JsonElement> elementAdapter = gson.getAdapter(JsonElement.class);
       final TypeAdapter<ComplianceRunInfo> thisAdapter
                        = gson.getDelegateAdapter(this, TypeToken.get(ComplianceRunInfo.class));

       return (TypeAdapter<T>) new TypeAdapter<ComplianceRunInfo>() {
           @Override
           public void write(JsonWriter out, ComplianceRunInfo value) throws IOException {
             JsonObject obj = thisAdapter.toJsonTree(value).getAsJsonObject();
             elementAdapter.write(out, obj);
           }

           @Override
           public ComplianceRunInfo read(JsonReader in) throws IOException {
             JsonObject jsonObj = elementAdapter.read(in).getAsJsonObject();
             validateJsonObject(jsonObj);
             return thisAdapter.fromJsonTree(jsonObj);
           }

       }.nullSafe();
    }
  }

 /**
  * Create an instance of ComplianceRunInfo given an JSON string
  *
  * @param jsonString JSON string
  * @return An instance of ComplianceRunInfo
  * @throws IOException if the JSON string is invalid with respect to ComplianceRunInfo
  */
  public static ComplianceRunInfo fromJson(String jsonString) throws IOException {
    return JSON.getGson().fromJson(jsonString, ComplianceRunInfo.class);
  }

 /**
  * Convert an instance of ComplianceRunInfo to an JSON string
  *
  * @return JSON string
  */
  public String toJson() {
    return JSON.getGson().toJson(this);
  }
}
