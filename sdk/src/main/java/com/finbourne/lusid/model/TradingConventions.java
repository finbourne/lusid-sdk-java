/*
 * LUSID API
 *
 * Contact: info@finbourne.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

package com.finbourne.lusid.model;

import java.util.Objects;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;
import java.util.Arrays;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonArray;
import com.google.gson.JsonDeserializationContext;
import com.google.gson.JsonDeserializer;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParseException;
import com.google.gson.TypeAdapterFactory;
import com.google.gson.reflect.TypeToken;
import com.google.gson.TypeAdapter;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;

import java.lang.reflect.Type;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Map.Entry;
import java.util.Set;

import com.finbourne.lusid.JSON;

/**
 * Common Trading details for exchange traded instruments like Futures and Bonds
 */
@jakarta.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen")
public class TradingConventions {
  public static final String SERIALIZED_NAME_PRICE_SCALE_FACTOR = "priceScaleFactor";
  @SerializedName(SERIALIZED_NAME_PRICE_SCALE_FACTOR)
  private java.math.BigDecimal priceScaleFactor;

  public static final String SERIALIZED_NAME_MINIMUM_ORDER_SIZE = "minimumOrderSize";
  @SerializedName(SERIALIZED_NAME_MINIMUM_ORDER_SIZE)
  private java.math.BigDecimal minimumOrderSize;

  public static final String SERIALIZED_NAME_MINIMUM_ORDER_INCREMENT = "minimumOrderIncrement";
  @SerializedName(SERIALIZED_NAME_MINIMUM_ORDER_INCREMENT)
  private java.math.BigDecimal minimumOrderIncrement;

  public TradingConventions() {
  }

  public TradingConventions priceScaleFactor(java.math.BigDecimal priceScaleFactor) {
    
    this.priceScaleFactor = priceScaleFactor;
    return this;
  }

   /**
   * The factor used to scale prices for the instrument. Currently used by LUSID when calculating cost  and notional amounts on transactions. Note this factor does not yet impact Valuation, PV, exposure,  all of which use the scale factor attached to the price quotes in the QuoteStore.  Must be positive and defaults to 1 if not set.
   * @return priceScaleFactor
  **/
  @jakarta.annotation.Nullable
  public java.math.BigDecimal getPriceScaleFactor() {
    return priceScaleFactor;
  }


  public void setPriceScaleFactor(java.math.BigDecimal priceScaleFactor) {
    this.priceScaleFactor = priceScaleFactor;
  }


  public TradingConventions minimumOrderSize(java.math.BigDecimal minimumOrderSize) {
    
    this.minimumOrderSize = minimumOrderSize;
    return this;
  }

   /**
   * The Minimum Order Size  Must be non-negative and defaults to 0 if not set.
   * @return minimumOrderSize
  **/
  @jakarta.annotation.Nullable
  public java.math.BigDecimal getMinimumOrderSize() {
    return minimumOrderSize;
  }


  public void setMinimumOrderSize(java.math.BigDecimal minimumOrderSize) {
    this.minimumOrderSize = minimumOrderSize;
  }


  public TradingConventions minimumOrderIncrement(java.math.BigDecimal minimumOrderIncrement) {
    
    this.minimumOrderIncrement = minimumOrderIncrement;
    return this;
  }

   /**
   * The Minimum Order Increment  Must be non-negative and defaults to 0 if not set.
   * @return minimumOrderIncrement
  **/
  @jakarta.annotation.Nullable
  public java.math.BigDecimal getMinimumOrderIncrement() {
    return minimumOrderIncrement;
  }


  public void setMinimumOrderIncrement(java.math.BigDecimal minimumOrderIncrement) {
    this.minimumOrderIncrement = minimumOrderIncrement;
  }



  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    TradingConventions tradingConventions = (TradingConventions) o;
    return (this.priceScaleFactor.compareTo(tradingConventions.getPriceScaleFactor()) == 0) &&
        (this.minimumOrderSize.compareTo(tradingConventions.getMinimumOrderSize()) == 0) &&
        (this.minimumOrderIncrement.compareTo(tradingConventions.getMinimumOrderIncrement()) == 0);
  }

  @Override
  public int hashCode() {
    return Objects.hash(priceScaleFactor, minimumOrderSize, minimumOrderIncrement);
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class TradingConventions {\n");
    sb.append("    priceScaleFactor: ").append(toIndentedString(priceScaleFactor)).append("\n");
    sb.append("    minimumOrderSize: ").append(toIndentedString(minimumOrderSize)).append("\n");
    sb.append("    minimumOrderIncrement: ").append(toIndentedString(minimumOrderIncrement)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }


  public static HashSet<String> openapiFields;
  public static HashSet<String> openapiRequiredFields;

  static {
    // a set of all properties/fields (JSON key names)
    openapiFields = new HashSet<String>();
    openapiFields.add("priceScaleFactor");
    openapiFields.add("minimumOrderSize");
    openapiFields.add("minimumOrderIncrement");

    // a set of required properties/fields (JSON key names)
    openapiRequiredFields = new HashSet<String>();
  }

 /**
  * Validates the JSON Element and throws an exception if issues found
  *
  * @param jsonElement JSON Element
  * @throws IOException if the JSON Element is invalid with respect to TradingConventions
  */
  public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      if (jsonElement == null) {
        if (!TradingConventions.openapiRequiredFields.isEmpty()) { // has required fields but JSON element is null
          throw new IllegalArgumentException(String.format("The required field(s) %s in TradingConventions is not found in the empty JSON string", TradingConventions.openapiRequiredFields.toString()));
        }
      }
        JsonObject jsonObj = jsonElement.getAsJsonObject();
  }

  public static class CustomTypeAdapterFactory implements TypeAdapterFactory {
    @SuppressWarnings("unchecked")
    @Override
    public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {
       if (!TradingConventions.class.isAssignableFrom(type.getRawType())) {
         return null; // this class only serializes 'TradingConventions' and its subtypes
       }
       final TypeAdapter<JsonElement> elementAdapter = gson.getAdapter(JsonElement.class);
       final TypeAdapter<TradingConventions> thisAdapter
                        = gson.getDelegateAdapter(this, TypeToken.get(TradingConventions.class));

       return (TypeAdapter<T>) new TypeAdapter<TradingConventions>() {
           @Override
           public void write(JsonWriter out, TradingConventions value) throws IOException {
             JsonObject obj = thisAdapter.toJsonTree(value).getAsJsonObject();
             elementAdapter.write(out, obj);
           }

           @Override
           public TradingConventions read(JsonReader in) throws IOException {
             JsonElement jsonElement = elementAdapter.read(in);
             validateJsonElement(jsonElement);
             return thisAdapter.fromJsonTree(jsonElement);
           }

       }.nullSafe();
    }
  }

 /**
  * Create an instance of TradingConventions given an JSON string
  *
  * @param jsonString JSON string
  * @return An instance of TradingConventions
  * @throws IOException if the JSON string is invalid with respect to TradingConventions
  */
  public static TradingConventions fromJson(String jsonString) throws IOException {
    return JSON.getGson().fromJson(jsonString, TradingConventions.class);
  }

 /**
  * Convert an instance of TradingConventions to an JSON string
  *
  * @return JSON string
  */
  public String toJson() {
    return JSON.getGson().toJson(this);
  }
}
