/*
 * LUSID API
 *
 * Contact: info@finbourne.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

package com.finbourne.lusid.model;

import java.util.Objects;
import com.finbourne.lusid.model.InstrumentEvent;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;
import java.time.OffsetDateTime;
import java.util.Arrays;
import org.openapitools.jackson.nullable.JsonNullable;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonArray;
import com.google.gson.JsonDeserializationContext;
import com.google.gson.JsonDeserializer;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParseException;
import com.google.gson.TypeAdapterFactory;
import com.google.gson.reflect.TypeToken;
import com.google.gson.TypeAdapter;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;

import java.lang.reflect.Type;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Map.Entry;
import java.util.Set;

import com.finbourne.lusid.JSON;

/**
 * Definition of FlexibleRepoCashFlowEvent which represents a cash transfer as part of a repo contract modelled  as a FlexibleRepo, either as part of the purchase leg or repurchase leg, or any early closure.
 */
@jakarta.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen")
public class FlexibleRepoCashFlowEvent extends InstrumentEvent {
  public static final String SERIALIZED_NAME_SETTLEMENT_DATE = "settlementDate";
  @SerializedName(SERIALIZED_NAME_SETTLEMENT_DATE)
  private OffsetDateTime settlementDate;

  public static final String SERIALIZED_NAME_ENTITLEMENT_DATE = "entitlementDate";
  @SerializedName(SERIALIZED_NAME_ENTITLEMENT_DATE)
  private OffsetDateTime entitlementDate;

  public static final String SERIALIZED_NAME_CURRENCY = "currency";
  @SerializedName(SERIALIZED_NAME_CURRENCY)
  private String currency;

  public static final String SERIALIZED_NAME_CASH_FLOW_PER_UNIT = "cashFlowPerUnit";
  @SerializedName(SERIALIZED_NAME_CASH_FLOW_PER_UNIT)
  private java.math.BigDecimal cashFlowPerUnit;

  public FlexibleRepoCashFlowEvent() {
    // this.instrumentEventType = this.getClass().getSimpleName();
  }

  public FlexibleRepoCashFlowEvent settlementDate(OffsetDateTime settlementDate) {
    
    this.settlementDate = settlementDate;
    return this;
  }

   /**
   * Date that the cash payment settles. This is a required field.
   * @return settlementDate
  **/
  @jakarta.annotation.Nullable
  public OffsetDateTime getSettlementDate() {
    return settlementDate;
  }


  public void setSettlementDate(OffsetDateTime settlementDate) {
    this.settlementDate = settlementDate;
  }


  public FlexibleRepoCashFlowEvent entitlementDate(OffsetDateTime entitlementDate) {
    
    this.entitlementDate = entitlementDate;
    return this;
  }

   /**
   * Date the recipient of the cash payment is entitled to receive the cash. This is a required field.
   * @return entitlementDate
  **/
  @jakarta.annotation.Nullable
  public OffsetDateTime getEntitlementDate() {
    return entitlementDate;
  }


  public void setEntitlementDate(OffsetDateTime entitlementDate) {
    this.entitlementDate = entitlementDate;
  }


  public FlexibleRepoCashFlowEvent currency(String currency) {
    
    this.currency = currency;
    return this;
  }

   /**
   * Currency of the payment. This is a required field.
   * @return currency
  **/
  @jakarta.annotation.Nonnull
  public String getCurrency() {
    return currency;
  }


  public void setCurrency(String currency) {
    this.currency = currency;
  }


  public FlexibleRepoCashFlowEvent cashFlowPerUnit(java.math.BigDecimal cashFlowPerUnit) {
    
    this.cashFlowPerUnit = cashFlowPerUnit;
    return this;
  }

   /**
   * Amount of cash to be paid per unit of the instrument.  This amount is signed to indicate direction of the payment, i.e. as part of the purchase leg vs the repurchase leg.  This field is optional. If not specified, the system will not generate a virtual transaction for this event.
   * @return cashFlowPerUnit
  **/
  @jakarta.annotation.Nullable
  public java.math.BigDecimal getCashFlowPerUnit() {
    return cashFlowPerUnit;
  }


  public void setCashFlowPerUnit(java.math.BigDecimal cashFlowPerUnit) {
    this.cashFlowPerUnit = cashFlowPerUnit;
  }



  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    FlexibleRepoCashFlowEvent flexibleRepoCashFlowEvent = (FlexibleRepoCashFlowEvent) o;
    return Objects.equals(this.settlementDate, flexibleRepoCashFlowEvent.settlementDate) &&
        Objects.equals(this.entitlementDate, flexibleRepoCashFlowEvent.entitlementDate) &&
        Objects.equals(this.currency, flexibleRepoCashFlowEvent.currency) &&
        (this.cashFlowPerUnit.compareTo(flexibleRepoCashFlowEvent.getCashFlowPerUnit()) == 0) &&
        super.equals(o);
  }

  private static <T> boolean equalsNullable(JsonNullable<T> a, JsonNullable<T> b) {
    return a == b || (a != null && b != null && a.isPresent() && b.isPresent() && Objects.deepEquals(a.get(), b.get()));
  }

  @Override
  public int hashCode() {
    return Objects.hash(settlementDate, entitlementDate, currency, cashFlowPerUnit, super.hashCode());
  }

  private static <T> int hashCodeNullable(JsonNullable<T> a) {
    if (a == null) {
      return 1;
    }
    return a.isPresent() ? Arrays.deepHashCode(new Object[]{a.get()}) : 31;
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class FlexibleRepoCashFlowEvent {\n");
    sb.append("    ").append(toIndentedString(super.toString())).append("\n");
    sb.append("    settlementDate: ").append(toIndentedString(settlementDate)).append("\n");
    sb.append("    entitlementDate: ").append(toIndentedString(entitlementDate)).append("\n");
    sb.append("    currency: ").append(toIndentedString(currency)).append("\n");
    sb.append("    cashFlowPerUnit: ").append(toIndentedString(cashFlowPerUnit)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }


  public static HashSet<String> openapiFields;
  public static HashSet<String> openapiRequiredFields;

  static {
    // a set of all properties/fields (JSON key names)
    openapiFields = new HashSet<String>();
    openapiFields.add("instrumentEventType");
    openapiFields.add("settlementDate");
    openapiFields.add("entitlementDate");
    openapiFields.add("currency");
    openapiFields.add("cashFlowPerUnit");

    // a set of required properties/fields (JSON key names)
    openapiRequiredFields = new HashSet<String>();
    openapiRequiredFields.add("currency");
    openapiRequiredFields.add("instrumentEventType");
  }

 /**
  * Validates the JSON Element and throws an exception if issues found
  *
  * @param jsonElement JSON Element
  * @throws IOException if the JSON Element is invalid with respect to FlexibleRepoCashFlowEvent
  */
  public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      if (jsonElement == null) {
        if (!FlexibleRepoCashFlowEvent.openapiRequiredFields.isEmpty()) { // has required fields but JSON element is null
          throw new IllegalArgumentException(String.format("The required field(s) %s in FlexibleRepoCashFlowEvent is not found in the empty JSON string", FlexibleRepoCashFlowEvent.openapiRequiredFields.toString()));
        }
      }

      // check to make sure all required properties/fields are present in the JSON string
      for (String requiredField : FlexibleRepoCashFlowEvent.openapiRequiredFields) {
        if (jsonElement.getAsJsonObject().get(requiredField) == null) {
          throw new IllegalArgumentException(String.format("The required field `%s` is not found in the JSON string: %s", requiredField, jsonElement.toString()));
        }
      }
  }

  public static class CustomTypeAdapterFactory implements TypeAdapterFactory {
    @SuppressWarnings("unchecked")
    @Override
    public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {
       if (!FlexibleRepoCashFlowEvent.class.isAssignableFrom(type.getRawType())) {
         return null; // this class only serializes 'FlexibleRepoCashFlowEvent' and its subtypes
       }
       final TypeAdapter<JsonElement> elementAdapter = gson.getAdapter(JsonElement.class);
       final TypeAdapter<FlexibleRepoCashFlowEvent> thisAdapter
                        = gson.getDelegateAdapter(this, TypeToken.get(FlexibleRepoCashFlowEvent.class));

       return (TypeAdapter<T>) new TypeAdapter<FlexibleRepoCashFlowEvent>() {
           @Override
           public void write(JsonWriter out, FlexibleRepoCashFlowEvent value) throws IOException {
             JsonObject obj = thisAdapter.toJsonTree(value).getAsJsonObject();
             elementAdapter.write(out, obj);
           }

           @Override
           public FlexibleRepoCashFlowEvent read(JsonReader in) throws IOException {
             JsonElement jsonElement = elementAdapter.read(in);
             validateJsonElement(jsonElement);
             return thisAdapter.fromJsonTree(jsonElement);
           }

       }.nullSafe();
    }
  }

 /**
  * Create an instance of FlexibleRepoCashFlowEvent given an JSON string
  *
  * @param jsonString JSON string
  * @return An instance of FlexibleRepoCashFlowEvent
  * @throws IOException if the JSON string is invalid with respect to FlexibleRepoCashFlowEvent
  */
  public static FlexibleRepoCashFlowEvent fromJson(String jsonString) throws IOException {
    return JSON.getGson().fromJson(jsonString, FlexibleRepoCashFlowEvent.class);
  }

 /**
  * Convert an instance of FlexibleRepoCashFlowEvent to an JSON string
  *
  * @return JSON string
  */
  public String toJson() {
    return JSON.getGson().toJson(this);
  }
}
