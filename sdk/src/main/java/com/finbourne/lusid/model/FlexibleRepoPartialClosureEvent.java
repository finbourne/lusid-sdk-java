/*
 * LUSID API
 *
 * Contact: info@finbourne.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

package com.finbourne.lusid.model;

import java.util.Objects;
import com.finbourne.lusid.model.InstrumentEvent;
import com.finbourne.lusid.model.PartialClosureConstituent;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;
import java.time.OffsetDateTime;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonArray;
import com.google.gson.JsonDeserializationContext;
import com.google.gson.JsonDeserializer;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParseException;
import com.google.gson.TypeAdapterFactory;
import com.google.gson.reflect.TypeToken;
import com.google.gson.TypeAdapter;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;

import java.lang.reflect.Type;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Map.Entry;
import java.util.Set;

import com.finbourne.lusid.JSON;

/**
 * Event representing the partial closure of a repurchase  agreement. Each event reduces the outstanding notional  and generates a corresponding receive-leg cashflow. The  final maturity cashflow is adjusted accordingly. If multiple events are created, their effects compound.  Once the total repaid amount reaches the original purchase  price, no further receive-leg cashflows are generated. Any  event exceeding the remaining notional is marked with a  diagnostic to indicate it is invalid due to excessive repayment. For example, for a repo with a 5% rate, 1% haircut and  collateral value of 100 (purchase price &#x3D; 99), a partial  closure of cash amount 10 followed by one of 100 results in  only the first event producing a cashflow. The second,  exceeding the remaining balance, is ignored and flagged  with a diagnostic. The remaining balance is settled at  maturity of the repurchase agreement. Specific to a instrument.
 */
@jakarta.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen")
public class FlexibleRepoPartialClosureEvent extends InstrumentEvent {
  public static final String SERIALIZED_NAME_ENTITLEMENT_DATE = "entitlementDate";
  @SerializedName(SERIALIZED_NAME_ENTITLEMENT_DATE)
  private OffsetDateTime entitlementDate;

  public static final String SERIALIZED_NAME_SETTLEMENT_DATE = "settlementDate";
  @SerializedName(SERIALIZED_NAME_SETTLEMENT_DATE)
  private OffsetDateTime settlementDate;

  public static final String SERIALIZED_NAME_AMOUNT = "amount";
  @SerializedName(SERIALIZED_NAME_AMOUNT)
  private java.math.BigDecimal amount;

  public static final String SERIALIZED_NAME_AMOUNT_TYPE = "amountType";
  @SerializedName(SERIALIZED_NAME_AMOUNT_TYPE)
  private String amountType;

  public static final String SERIALIZED_NAME_PARTIAL_CLOSURE_CONSTITUENTS = "partialClosureConstituents";
  @SerializedName(SERIALIZED_NAME_PARTIAL_CLOSURE_CONSTITUENTS)
  private List<PartialClosureConstituent> partialClosureConstituents = new ArrayList<>();

  public FlexibleRepoPartialClosureEvent() {
    // this.instrumentEventType = this.getClass().getSimpleName();
  }

  public FlexibleRepoPartialClosureEvent entitlementDate(OffsetDateTime entitlementDate) {
    
    this.entitlementDate = entitlementDate;
    return this;
  }

   /**
   * Required property. The date on which the counterparties become entitled  to exchange cash as part of a partial closure of the  repurchase agreement. The date must be before or on  the settlement date, and on or before the maturity  date of the repo.
   * @return entitlementDate
  **/
  @jakarta.annotation.Nullable
  public OffsetDateTime getEntitlementDate() {
    return entitlementDate;
  }


  public void setEntitlementDate(OffsetDateTime entitlementDate) {
    this.entitlementDate = entitlementDate;
  }


  public FlexibleRepoPartialClosureEvent settlementDate(OffsetDateTime settlementDate) {
    
    this.settlementDate = settlementDate;
    return this;
  }

   /**
   * Required property. The date on which the exchange of cash is settled.  The date must be on or after the entitlement date, and on or before the maturity date of the repo.
   * @return settlementDate
  **/
  @jakarta.annotation.Nullable
  public OffsetDateTime getSettlementDate() {
    return settlementDate;
  }


  public void setSettlementDate(OffsetDateTime settlementDate) {
    this.settlementDate = settlementDate;
  }


  public FlexibleRepoPartialClosureEvent amount(java.math.BigDecimal amount) {
    
    this.amount = amount;
    return this;
  }

   /**
   * The amount of cash to be exchanged as part of a partial closure of the repurchase agreement. Either the absolute cash amount or a percentage of the remaining amount, depending on the AmountType.
   * @return amount
  **/
  @jakarta.annotation.Nonnull
  public java.math.BigDecimal getAmount() {
    return amount;
  }


  public void setAmount(java.math.BigDecimal amount) {
    this.amount = amount;
  }


  public FlexibleRepoPartialClosureEvent amountType(String amountType) {
    
    this.amountType = amountType;
    return this;
  }

   /**
   * AmountType of the cash amount to be exchanged as part of a partial closure of the repurchase agreement. Either percentage or absolute cash amount.  Supported string (enumeration) values are: [Percentage, Units].
   * @return amountType
  **/
  @jakarta.annotation.Nonnull
  public String getAmountType() {
    return amountType;
  }


  public void setAmountType(String amountType) {
    this.amountType = amountType;
  }


  public FlexibleRepoPartialClosureEvent partialClosureConstituents(List<PartialClosureConstituent> partialClosureConstituents) {
    
    this.partialClosureConstituents = partialClosureConstituents;
    return this;
  }

  public FlexibleRepoPartialClosureEvent addPartialClosureConstituentsItem(PartialClosureConstituent partialClosureConstituentsItem) {
    if (this.partialClosureConstituents == null) {
      this.partialClosureConstituents = new ArrayList<>();
    }
    this.partialClosureConstituents.add(partialClosureConstituentsItem);
    return this;
  }

   /**
   * List of the collateral instruments involved in this partial closure, along with how they are affected.
   * @return partialClosureConstituents
  **/
  @jakarta.annotation.Nonnull
  public List<PartialClosureConstituent> getPartialClosureConstituents() {
    return partialClosureConstituents;
  }


  public void setPartialClosureConstituents(List<PartialClosureConstituent> partialClosureConstituents) {
    this.partialClosureConstituents = partialClosureConstituents;
  }



  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    FlexibleRepoPartialClosureEvent flexibleRepoPartialClosureEvent = (FlexibleRepoPartialClosureEvent) o;
    return Objects.equals(this.entitlementDate, flexibleRepoPartialClosureEvent.entitlementDate) &&
        Objects.equals(this.settlementDate, flexibleRepoPartialClosureEvent.settlementDate) &&
        (this.amount.compareTo(flexibleRepoPartialClosureEvent.getAmount()) == 0) &&
        Objects.equals(this.amountType, flexibleRepoPartialClosureEvent.amountType) &&
        Objects.equals(this.partialClosureConstituents, flexibleRepoPartialClosureEvent.partialClosureConstituents) &&
        super.equals(o);
  }

  @Override
  public int hashCode() {
    return Objects.hash(entitlementDate, settlementDate, amount, amountType, partialClosureConstituents, super.hashCode());
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class FlexibleRepoPartialClosureEvent {\n");
    sb.append("    ").append(toIndentedString(super.toString())).append("\n");
    sb.append("    entitlementDate: ").append(toIndentedString(entitlementDate)).append("\n");
    sb.append("    settlementDate: ").append(toIndentedString(settlementDate)).append("\n");
    sb.append("    amount: ").append(toIndentedString(amount)).append("\n");
    sb.append("    amountType: ").append(toIndentedString(amountType)).append("\n");
    sb.append("    partialClosureConstituents: ").append(toIndentedString(partialClosureConstituents)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }


  public static HashSet<String> openapiFields;
  public static HashSet<String> openapiRequiredFields;

  static {
    // a set of all properties/fields (JSON key names)
    openapiFields = new HashSet<String>();
    openapiFields.add("instrumentEventType");
    openapiFields.add("entitlementDate");
    openapiFields.add("settlementDate");
    openapiFields.add("amount");
    openapiFields.add("amountType");
    openapiFields.add("partialClosureConstituents");

    // a set of required properties/fields (JSON key names)
    openapiRequiredFields = new HashSet<String>();
    openapiRequiredFields.add("amount");
    openapiRequiredFields.add("amountType");
    openapiRequiredFields.add("partialClosureConstituents");
    openapiRequiredFields.add("instrumentEventType");
  }

 /**
  * Validates the JSON Element and throws an exception if issues found
  *
  * @param jsonElement JSON Element
  * @throws IOException if the JSON Element is invalid with respect to FlexibleRepoPartialClosureEvent
  */
  public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      if (jsonElement == null) {
        if (!FlexibleRepoPartialClosureEvent.openapiRequiredFields.isEmpty()) { // has required fields but JSON element is null
          throw new IllegalArgumentException(String.format("The required field(s) %s in FlexibleRepoPartialClosureEvent is not found in the empty JSON string", FlexibleRepoPartialClosureEvent.openapiRequiredFields.toString()));
        }
      }

      // check to make sure all required properties/fields are present in the JSON string
      for (String requiredField : FlexibleRepoPartialClosureEvent.openapiRequiredFields) {
        if (jsonElement.getAsJsonObject().get(requiredField) == null) {
          throw new IllegalArgumentException(String.format("The required field `%s` is not found in the JSON string: %s", requiredField, jsonElement.toString()));
        }
      }
  }

  public static class CustomTypeAdapterFactory implements TypeAdapterFactory {
    @SuppressWarnings("unchecked")
    @Override
    public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {
       if (!FlexibleRepoPartialClosureEvent.class.isAssignableFrom(type.getRawType())) {
         return null; // this class only serializes 'FlexibleRepoPartialClosureEvent' and its subtypes
       }
       final TypeAdapter<JsonElement> elementAdapter = gson.getAdapter(JsonElement.class);
       final TypeAdapter<FlexibleRepoPartialClosureEvent> thisAdapter
                        = gson.getDelegateAdapter(this, TypeToken.get(FlexibleRepoPartialClosureEvent.class));

       return (TypeAdapter<T>) new TypeAdapter<FlexibleRepoPartialClosureEvent>() {
           @Override
           public void write(JsonWriter out, FlexibleRepoPartialClosureEvent value) throws IOException {
             JsonObject obj = thisAdapter.toJsonTree(value).getAsJsonObject();
             elementAdapter.write(out, obj);
           }

           @Override
           public FlexibleRepoPartialClosureEvent read(JsonReader in) throws IOException {
             JsonElement jsonElement = elementAdapter.read(in);
             validateJsonElement(jsonElement);
             return thisAdapter.fromJsonTree(jsonElement);
           }

       }.nullSafe();
    }
  }

 /**
  * Create an instance of FlexibleRepoPartialClosureEvent given an JSON string
  *
  * @param jsonString JSON string
  * @return An instance of FlexibleRepoPartialClosureEvent
  * @throws IOException if the JSON string is invalid with respect to FlexibleRepoPartialClosureEvent
  */
  public static FlexibleRepoPartialClosureEvent fromJson(String jsonString) throws IOException {
    return JSON.getGson().fromJson(jsonString, FlexibleRepoPartialClosureEvent.class);
  }

 /**
  * Convert an instance of FlexibleRepoPartialClosureEvent to an JSON string
  *
  * @return JSON string
  */
  public String toJson() {
    return JSON.getGson().toJson(this);
  }
}
