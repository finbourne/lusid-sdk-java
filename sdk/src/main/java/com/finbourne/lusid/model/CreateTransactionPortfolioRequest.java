/*
 * LUSID API
 *
 * Contact: info@finbourne.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

package com.finbourne.lusid.model;

import java.util.Objects;
import com.finbourne.lusid.model.Property;
import com.finbourne.lusid.model.ResourceId;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;
import java.time.OffsetDateTime;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import org.openapitools.jackson.nullable.JsonNullable;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonArray;
import com.google.gson.JsonDeserializationContext;
import com.google.gson.JsonDeserializer;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParseException;
import com.google.gson.TypeAdapterFactory;
import com.google.gson.reflect.TypeToken;
import com.google.gson.TypeAdapter;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;

import java.lang.reflect.Type;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Map.Entry;
import java.util.Set;

import com.finbourne.lusid.JSON;

/**
 * CreateTransactionPortfolioRequest
 */
@jakarta.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen")
public class CreateTransactionPortfolioRequest {
  public static final String SERIALIZED_NAME_DISPLAY_NAME = "displayName";
  @SerializedName(SERIALIZED_NAME_DISPLAY_NAME)
  private String displayName;

  public static final String SERIALIZED_NAME_DESCRIPTION = "description";
  @SerializedName(SERIALIZED_NAME_DESCRIPTION)
  private String description;

  public static final String SERIALIZED_NAME_CODE = "code";
  @SerializedName(SERIALIZED_NAME_CODE)
  private String code;

  public static final String SERIALIZED_NAME_CREATED = "created";
  @SerializedName(SERIALIZED_NAME_CREATED)
  private OffsetDateTime created;

  public static final String SERIALIZED_NAME_BASE_CURRENCY = "baseCurrency";
  @SerializedName(SERIALIZED_NAME_BASE_CURRENCY)
  private String baseCurrency;

  public static final String SERIALIZED_NAME_CORPORATE_ACTION_SOURCE_ID = "corporateActionSourceId";
  @SerializedName(SERIALIZED_NAME_CORPORATE_ACTION_SOURCE_ID)
  private ResourceId corporateActionSourceId;

  /**
   * . The available values are: Default, AverageCost, FirstInFirstOut, LastInFirstOut, HighestCostFirst, LowestCostFirst
   */
  @JsonAdapter(AccountingMethodEnum.Adapter.class)
  public enum AccountingMethodEnum {
    DEFAULT("Default"),
    
    AVERAGECOST("AverageCost"),
    
    FIRSTINFIRSTOUT("FirstInFirstOut"),
    
    LASTINFIRSTOUT("LastInFirstOut"),
    
    HIGHESTCOSTFIRST("HighestCostFirst"),
    
    LOWESTCOSTFIRST("LowestCostFirst");

    private String value;

    AccountingMethodEnum(String value) {
      this.value = value;
    }

    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }

    public static AccountingMethodEnum fromValue(String value) {
      for (AccountingMethodEnum b : AccountingMethodEnum.values()) {
        if (b.value.equals(value)) {
          return b;
        }
      }
      throw new IllegalArgumentException("Unexpected value '" + value + "'");
    }

    public static class Adapter extends TypeAdapter<AccountingMethodEnum> {
      @Override
      public void write(final JsonWriter jsonWriter, final AccountingMethodEnum enumeration) throws IOException {
        jsonWriter.value(enumeration.getValue());
      }

      @Override
      public AccountingMethodEnum read(final JsonReader jsonReader) throws IOException {
        String value =  jsonReader.nextString();
        return AccountingMethodEnum.fromValue(value);
      }
    }
  }

  public static final String SERIALIZED_NAME_ACCOUNTING_METHOD = "accountingMethod";
  @SerializedName(SERIALIZED_NAME_ACCOUNTING_METHOD)
  private AccountingMethodEnum accountingMethod;

  public static final String SERIALIZED_NAME_SUB_HOLDING_KEYS = "subHoldingKeys";
  @SerializedName(SERIALIZED_NAME_SUB_HOLDING_KEYS)
  private List<String> subHoldingKeys;

  public static final String SERIALIZED_NAME_PROPERTIES = "properties";
  @SerializedName(SERIALIZED_NAME_PROPERTIES)
  private Map<String, Property> properties;

  public static final String SERIALIZED_NAME_INSTRUMENT_SCOPES = "instrumentScopes";
  @SerializedName(SERIALIZED_NAME_INSTRUMENT_SCOPES)
  private List<String> instrumentScopes;

  public static final String SERIALIZED_NAME_AMORTISATION_METHOD = "amortisationMethod";
  @SerializedName(SERIALIZED_NAME_AMORTISATION_METHOD)
  private String amortisationMethod;

  public static final String SERIALIZED_NAME_TRANSACTION_TYPE_SCOPE = "transactionTypeScope";
  @SerializedName(SERIALIZED_NAME_TRANSACTION_TYPE_SCOPE)
  private String transactionTypeScope;

  public CreateTransactionPortfolioRequest() {
  }

  public CreateTransactionPortfolioRequest displayName(String displayName) {
    
    this.displayName = displayName;
    return this;
  }

   /**
   * The name of the transaction portfolio.
   * @return displayName
  **/
  @jakarta.annotation.Nonnull
  public String getDisplayName() {
    return displayName;
  }


  public void setDisplayName(String displayName) {
    this.displayName = displayName;
  }


  public CreateTransactionPortfolioRequest description(String description) {
    
    this.description = description;
    return this;
  }

   /**
   * A description for the transaction portfolio.
   * @return description
  **/
  @jakarta.annotation.Nullable
  public String getDescription() {
    return description;
  }


  public void setDescription(String description) {
    this.description = description;
  }


  public CreateTransactionPortfolioRequest code(String code) {
    
    this.code = code;
    return this;
  }

   /**
   * The code of the transaction portfolio. Together with the scope this uniquely identifies the transaction portfolio.
   * @return code
  **/
  @jakarta.annotation.Nonnull
  public String getCode() {
    return code;
  }


  public void setCode(String code) {
    this.code = code;
  }


  public CreateTransactionPortfolioRequest created(OffsetDateTime created) {
    
    this.created = created;
    return this;
  }

   /**
   * The effective datetime at which to create the transaction portfolio. No transactions can be added to the transaction portfolio before this date. Defaults to the current LUSID system datetime if not specified.
   * @return created
  **/
  @jakarta.annotation.Nullable
  public OffsetDateTime getCreated() {
    return created;
  }


  public void setCreated(OffsetDateTime created) {
    this.created = created;
  }


  public CreateTransactionPortfolioRequest baseCurrency(String baseCurrency) {
    
    this.baseCurrency = baseCurrency;
    return this;
  }

   /**
   * The base currency of the transaction portfolio in ISO 4217 currency code format.
   * @return baseCurrency
  **/
  @jakarta.annotation.Nonnull
  public String getBaseCurrency() {
    return baseCurrency;
  }


  public void setBaseCurrency(String baseCurrency) {
    this.baseCurrency = baseCurrency;
  }


  public CreateTransactionPortfolioRequest corporateActionSourceId(ResourceId corporateActionSourceId) {
    
    this.corporateActionSourceId = corporateActionSourceId;
    return this;
  }

   /**
   * Get corporateActionSourceId
   * @return corporateActionSourceId
  **/
  @jakarta.annotation.Nullable
  public ResourceId getCorporateActionSourceId() {
    return corporateActionSourceId;
  }


  public void setCorporateActionSourceId(ResourceId corporateActionSourceId) {
    this.corporateActionSourceId = corporateActionSourceId;
  }


  public CreateTransactionPortfolioRequest accountingMethod(AccountingMethodEnum accountingMethod) {
    
    this.accountingMethod = accountingMethod;
    return this;
  }

   /**
   * . The available values are: Default, AverageCost, FirstInFirstOut, LastInFirstOut, HighestCostFirst, LowestCostFirst
   * @return accountingMethod
  **/
  @jakarta.annotation.Nullable
  public AccountingMethodEnum getAccountingMethod() {
    return accountingMethod;
  }


  public void setAccountingMethod(AccountingMethodEnum accountingMethod) {
    this.accountingMethod = accountingMethod;
  }


  public CreateTransactionPortfolioRequest subHoldingKeys(List<String> subHoldingKeys) {
    
    this.subHoldingKeys = subHoldingKeys;
    return this;
  }

  public CreateTransactionPortfolioRequest addSubHoldingKeysItem(String subHoldingKeysItem) {
    if (this.subHoldingKeys == null) {
      this.subHoldingKeys = new ArrayList<>();
    }
    this.subHoldingKeys.add(subHoldingKeysItem);
    return this;
  }

   /**
   * A set of unique transaction properties to group the transaction portfolio&#39;s holdings by, perhaps for strategy tagging. Each property must be from the &#39;Transaction&#39; domain and identified by a key in the format {domain}/{scope}/{code}, for example &#39;Transaction/strategies/quantsignal&#39;. See https://support.lusid.com/knowledgebase/article/KA-01879/en-us for more information.
   * @return subHoldingKeys
  **/
  @jakarta.annotation.Nullable
  public List<String> getSubHoldingKeys() {
    return subHoldingKeys;
  }


  public void setSubHoldingKeys(List<String> subHoldingKeys) {
    this.subHoldingKeys = subHoldingKeys;
  }


  public CreateTransactionPortfolioRequest properties(Map<String, Property> properties) {
    
    this.properties = properties;
    return this;
  }

  public CreateTransactionPortfolioRequest putPropertiesItem(String key, Property propertiesItem) {
    if (this.properties == null) {
      this.properties = new HashMap<>();
    }
    this.properties.put(key, propertiesItem);
    return this;
  }

   /**
   * A set of unique portfolio properties to add custom data to the transaction portfolio. Each property must be from the &#39;Portfolio&#39; domain and identified by a key in the format {domain}/{scope}/{code}, for example &#39;Portfolio/Manager/Id&#39;. Note these properties must be pre-defined.
   * @return properties
  **/
  @jakarta.annotation.Nullable
  public Map<String, Property> getProperties() {
    return properties;
  }


  public void setProperties(Map<String, Property> properties) {
    this.properties = properties;
  }


  public CreateTransactionPortfolioRequest instrumentScopes(List<String> instrumentScopes) {
    
    this.instrumentScopes = instrumentScopes;
    return this;
  }

  public CreateTransactionPortfolioRequest addInstrumentScopesItem(String instrumentScopesItem) {
    if (this.instrumentScopes == null) {
      this.instrumentScopes = new ArrayList<>();
    }
    this.instrumentScopes.add(instrumentScopesItem);
    return this;
  }

   /**
   * The resolution strategy used to resolve instruments of transactions/holdings upserted to this portfolio.
   * @return instrumentScopes
  **/
  @jakarta.annotation.Nullable
  public List<String> getInstrumentScopes() {
    return instrumentScopes;
  }


  public void setInstrumentScopes(List<String> instrumentScopes) {
    this.instrumentScopes = instrumentScopes;
  }


  public CreateTransactionPortfolioRequest amortisationMethod(String amortisationMethod) {
    
    this.amortisationMethod = amortisationMethod;
    return this;
  }

   /**
   * The amortisation method the portfolio is using in the calculation. This can be &#39;NoAmortisation&#39;, &#39;StraightLine&#39; or &#39;EffectiveYield&#39;.
   * @return amortisationMethod
  **/
  @jakarta.annotation.Nullable
  public String getAmortisationMethod() {
    return amortisationMethod;
  }


  public void setAmortisationMethod(String amortisationMethod) {
    this.amortisationMethod = amortisationMethod;
  }


  public CreateTransactionPortfolioRequest transactionTypeScope(String transactionTypeScope) {
    
    this.transactionTypeScope = transactionTypeScope;
    return this;
  }

   /**
   * The scope of the transaction types.
   * @return transactionTypeScope
  **/
  @jakarta.annotation.Nullable
  public String getTransactionTypeScope() {
    return transactionTypeScope;
  }


  public void setTransactionTypeScope(String transactionTypeScope) {
    this.transactionTypeScope = transactionTypeScope;
  }



  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    CreateTransactionPortfolioRequest createTransactionPortfolioRequest = (CreateTransactionPortfolioRequest) o;
    return Objects.equals(this.displayName, createTransactionPortfolioRequest.displayName) &&
        Objects.equals(this.description, createTransactionPortfolioRequest.description) &&
        Objects.equals(this.code, createTransactionPortfolioRequest.code) &&
        Objects.equals(this.created, createTransactionPortfolioRequest.created) &&
        Objects.equals(this.baseCurrency, createTransactionPortfolioRequest.baseCurrency) &&
        Objects.equals(this.corporateActionSourceId, createTransactionPortfolioRequest.corporateActionSourceId) &&
        Objects.equals(this.accountingMethod, createTransactionPortfolioRequest.accountingMethod) &&
        Objects.equals(this.subHoldingKeys, createTransactionPortfolioRequest.subHoldingKeys) &&
        Objects.equals(this.properties, createTransactionPortfolioRequest.properties) &&
        Objects.equals(this.instrumentScopes, createTransactionPortfolioRequest.instrumentScopes) &&
        Objects.equals(this.amortisationMethod, createTransactionPortfolioRequest.amortisationMethod) &&
        Objects.equals(this.transactionTypeScope, createTransactionPortfolioRequest.transactionTypeScope);
  }

  private static <T> boolean equalsNullable(JsonNullable<T> a, JsonNullable<T> b) {
    return a == b || (a != null && b != null && a.isPresent() && b.isPresent() && Objects.deepEquals(a.get(), b.get()));
  }

  @Override
  public int hashCode() {
    return Objects.hash(displayName, description, code, created, baseCurrency, corporateActionSourceId, accountingMethod, subHoldingKeys, properties, instrumentScopes, amortisationMethod, transactionTypeScope);
  }

  private static <T> int hashCodeNullable(JsonNullable<T> a) {
    if (a == null) {
      return 1;
    }
    return a.isPresent() ? Arrays.deepHashCode(new Object[]{a.get()}) : 31;
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class CreateTransactionPortfolioRequest {\n");
    sb.append("    displayName: ").append(toIndentedString(displayName)).append("\n");
    sb.append("    description: ").append(toIndentedString(description)).append("\n");
    sb.append("    code: ").append(toIndentedString(code)).append("\n");
    sb.append("    created: ").append(toIndentedString(created)).append("\n");
    sb.append("    baseCurrency: ").append(toIndentedString(baseCurrency)).append("\n");
    sb.append("    corporateActionSourceId: ").append(toIndentedString(corporateActionSourceId)).append("\n");
    sb.append("    accountingMethod: ").append(toIndentedString(accountingMethod)).append("\n");
    sb.append("    subHoldingKeys: ").append(toIndentedString(subHoldingKeys)).append("\n");
    sb.append("    properties: ").append(toIndentedString(properties)).append("\n");
    sb.append("    instrumentScopes: ").append(toIndentedString(instrumentScopes)).append("\n");
    sb.append("    amortisationMethod: ").append(toIndentedString(amortisationMethod)).append("\n");
    sb.append("    transactionTypeScope: ").append(toIndentedString(transactionTypeScope)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }


  public static HashSet<String> openapiFields;
  public static HashSet<String> openapiRequiredFields;

  static {
    // a set of all properties/fields (JSON key names)
    openapiFields = new HashSet<String>();
    openapiFields.add("displayName");
    openapiFields.add("description");
    openapiFields.add("code");
    openapiFields.add("created");
    openapiFields.add("baseCurrency");
    openapiFields.add("corporateActionSourceId");
    openapiFields.add("accountingMethod");
    openapiFields.add("subHoldingKeys");
    openapiFields.add("properties");
    openapiFields.add("instrumentScopes");
    openapiFields.add("amortisationMethod");
    openapiFields.add("transactionTypeScope");

    // a set of required properties/fields (JSON key names)
    openapiRequiredFields = new HashSet<String>();
    openapiRequiredFields.add("displayName");
    openapiRequiredFields.add("code");
    openapiRequiredFields.add("baseCurrency");
  }

 /**
  * Validates the JSON Element and throws an exception if issues found
  *
  * @param jsonElement JSON Element
  * @throws IOException if the JSON Element is invalid with respect to CreateTransactionPortfolioRequest
  */
  public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      if (jsonElement == null) {
        if (!CreateTransactionPortfolioRequest.openapiRequiredFields.isEmpty()) { // has required fields but JSON element is null
          throw new IllegalArgumentException(String.format("The required field(s) %s in CreateTransactionPortfolioRequest is not found in the empty JSON string", CreateTransactionPortfolioRequest.openapiRequiredFields.toString()));
        }
      }

      // check to make sure all required properties/fields are present in the JSON string
      for (String requiredField : CreateTransactionPortfolioRequest.openapiRequiredFields) {
        if (jsonElement.getAsJsonObject().get(requiredField) == null) {
          throw new IllegalArgumentException(String.format("The required field `%s` is not found in the JSON string: %s", requiredField, jsonElement.toString()));
        }
      }
        JsonObject jsonObj = jsonElement.getAsJsonObject();
      if (!jsonObj.get("displayName").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `displayName` to be a primitive type in the JSON string but got `%s`", jsonObj.get("displayName").toString()));
      }
      if ((jsonObj.get("description") != null && !jsonObj.get("description").isJsonNull()) && !jsonObj.get("description").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `description` to be a primitive type in the JSON string but got `%s`", jsonObj.get("description").toString()));
      }
      if (!jsonObj.get("code").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `code` to be a primitive type in the JSON string but got `%s`", jsonObj.get("code").toString()));
      }
      if (!jsonObj.get("baseCurrency").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `baseCurrency` to be a primitive type in the JSON string but got `%s`", jsonObj.get("baseCurrency").toString()));
      }
      // validate the optional field `corporateActionSourceId`
      if (jsonObj.get("corporateActionSourceId") != null && !jsonObj.get("corporateActionSourceId").isJsonNull()) {
        ResourceId.validateJsonElement(jsonObj.get("corporateActionSourceId"));
      }
      if ((jsonObj.get("accountingMethod") != null && !jsonObj.get("accountingMethod").isJsonNull()) && !jsonObj.get("accountingMethod").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `accountingMethod` to be a primitive type in the JSON string but got `%s`", jsonObj.get("accountingMethod").toString()));
      }
      // ensure the optional json data is an array if present
      if (jsonObj.get("subHoldingKeys") != null && !jsonObj.get("subHoldingKeys").isJsonNull() && !jsonObj.get("subHoldingKeys").isJsonArray()) {
        throw new IllegalArgumentException(String.format("Expected the field `subHoldingKeys` to be an array in the JSON string but got `%s`", jsonObj.get("subHoldingKeys").toString()));
      }
      // ensure the optional json data is an array if present
      if (jsonObj.get("instrumentScopes") != null && !jsonObj.get("instrumentScopes").isJsonNull() && !jsonObj.get("instrumentScopes").isJsonArray()) {
        throw new IllegalArgumentException(String.format("Expected the field `instrumentScopes` to be an array in the JSON string but got `%s`", jsonObj.get("instrumentScopes").toString()));
      }
      if ((jsonObj.get("amortisationMethod") != null && !jsonObj.get("amortisationMethod").isJsonNull()) && !jsonObj.get("amortisationMethod").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `amortisationMethod` to be a primitive type in the JSON string but got `%s`", jsonObj.get("amortisationMethod").toString()));
      }
      if ((jsonObj.get("transactionTypeScope") != null && !jsonObj.get("transactionTypeScope").isJsonNull()) && !jsonObj.get("transactionTypeScope").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `transactionTypeScope` to be a primitive type in the JSON string but got `%s`", jsonObj.get("transactionTypeScope").toString()));
      }
  }

  public static class CustomTypeAdapterFactory implements TypeAdapterFactory {
    @SuppressWarnings("unchecked")
    @Override
    public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {
       if (!CreateTransactionPortfolioRequest.class.isAssignableFrom(type.getRawType())) {
         return null; // this class only serializes 'CreateTransactionPortfolioRequest' and its subtypes
       }
       final TypeAdapter<JsonElement> elementAdapter = gson.getAdapter(JsonElement.class);
       final TypeAdapter<CreateTransactionPortfolioRequest> thisAdapter
                        = gson.getDelegateAdapter(this, TypeToken.get(CreateTransactionPortfolioRequest.class));

       return (TypeAdapter<T>) new TypeAdapter<CreateTransactionPortfolioRequest>() {
           @Override
           public void write(JsonWriter out, CreateTransactionPortfolioRequest value) throws IOException {
             JsonObject obj = thisAdapter.toJsonTree(value).getAsJsonObject();
             elementAdapter.write(out, obj);
           }

           @Override
           public CreateTransactionPortfolioRequest read(JsonReader in) throws IOException {
             JsonElement jsonElement = elementAdapter.read(in);
             validateJsonElement(jsonElement);
             return thisAdapter.fromJsonTree(jsonElement);
           }

       }.nullSafe();
    }
  }

 /**
  * Create an instance of CreateTransactionPortfolioRequest given an JSON string
  *
  * @param jsonString JSON string
  * @return An instance of CreateTransactionPortfolioRequest
  * @throws IOException if the JSON string is invalid with respect to CreateTransactionPortfolioRequest
  */
  public static CreateTransactionPortfolioRequest fromJson(String jsonString) throws IOException {
    return JSON.getGson().fromJson(jsonString, CreateTransactionPortfolioRequest.class);
  }

 /**
  * Convert an instance of CreateTransactionPortfolioRequest to an JSON string
  *
  * @return JSON string
  */
  public String toJson() {
    return JSON.getGson().toJson(this);
  }
}
