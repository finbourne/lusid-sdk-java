/*
 * LUSID API
 *
 * Contact: info@finbourne.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

package com.finbourne.lusid.model;

import java.util.Objects;
import com.finbourne.lusid.model.ExDividendConfiguration;
import com.finbourne.lusid.model.FlowConventionName;
import com.finbourne.lusid.model.FlowConventions;
import com.finbourne.lusid.model.IndexConvention;
import com.finbourne.lusid.model.Schedule;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;
import java.time.OffsetDateTime;
import java.util.Arrays;
import org.openapitools.jackson.nullable.JsonNullable;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonArray;
import com.google.gson.JsonDeserializationContext;
import com.google.gson.JsonDeserializer;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParseException;
import com.google.gson.TypeAdapterFactory;
import com.google.gson.reflect.TypeToken;
import com.google.gson.TypeAdapter;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;

import java.lang.reflect.Type;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Map.Entry;
import java.util.Set;

import com.finbourne.lusid.JSON;

/**
 * Schedule for fixed coupon payments
 */
@jakarta.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen")
public class FloatSchedule extends Schedule {
  public static final String SERIALIZED_NAME_START_DATE = "startDate";
  @SerializedName(SERIALIZED_NAME_START_DATE)
  private OffsetDateTime startDate;

  public static final String SERIALIZED_NAME_MATURITY_DATE = "maturityDate";
  @SerializedName(SERIALIZED_NAME_MATURITY_DATE)
  private OffsetDateTime maturityDate;

  public static final String SERIALIZED_NAME_FLOW_CONVENTIONS = "flowConventions";
  @SerializedName(SERIALIZED_NAME_FLOW_CONVENTIONS)
  private FlowConventions flowConventions;

  public static final String SERIALIZED_NAME_CONVENTION_NAME = "conventionName";
  @SerializedName(SERIALIZED_NAME_CONVENTION_NAME)
  private FlowConventionName conventionName;

  public static final String SERIALIZED_NAME_EX_DIVIDEND_DAYS = "exDividendDays";
  @SerializedName(SERIALIZED_NAME_EX_DIVIDEND_DAYS)
  private Integer exDividendDays;

  public static final String SERIALIZED_NAME_INDEX_CONVENTION_NAME = "indexConventionName";
  @SerializedName(SERIALIZED_NAME_INDEX_CONVENTION_NAME)
  private FlowConventionName indexConventionName;

  public static final String SERIALIZED_NAME_INDEX_CONVENTIONS = "indexConventions";
  @SerializedName(SERIALIZED_NAME_INDEX_CONVENTIONS)
  private IndexConvention indexConventions;

  public static final String SERIALIZED_NAME_NOTIONAL = "notional";
  @SerializedName(SERIALIZED_NAME_NOTIONAL)
  private java.math.BigDecimal notional;

  public static final String SERIALIZED_NAME_PAYMENT_CURRENCY = "paymentCurrency";
  @SerializedName(SERIALIZED_NAME_PAYMENT_CURRENCY)
  private String paymentCurrency;

  public static final String SERIALIZED_NAME_SPREAD = "spread";
  @SerializedName(SERIALIZED_NAME_SPREAD)
  private java.math.BigDecimal spread;

  public static final String SERIALIZED_NAME_STUB_TYPE = "stubType";
  @SerializedName(SERIALIZED_NAME_STUB_TYPE)
  private String stubType;

  public static final String SERIALIZED_NAME_EX_DIVIDEND_CONFIGURATION = "exDividendConfiguration";
  @SerializedName(SERIALIZED_NAME_EX_DIVIDEND_CONFIGURATION)
  private ExDividendConfiguration exDividendConfiguration;

  public FloatSchedule() {
    // this.scheduleType = this.getClass().getSimpleName();
  }

  public FloatSchedule startDate(OffsetDateTime startDate) {
    
    this.startDate = startDate;
    return this;
  }

   /**
   * Date to start generate from
   * @return startDate
  **/
  @jakarta.annotation.Nullable
  public OffsetDateTime getStartDate() {
    return startDate;
  }


  public void setStartDate(OffsetDateTime startDate) {
    this.startDate = startDate;
  }


  public FloatSchedule maturityDate(OffsetDateTime maturityDate) {
    
    this.maturityDate = maturityDate;
    return this;
  }

   /**
   * Date to generate to
   * @return maturityDate
  **/
  @jakarta.annotation.Nullable
  public OffsetDateTime getMaturityDate() {
    return maturityDate;
  }


  public void setMaturityDate(OffsetDateTime maturityDate) {
    this.maturityDate = maturityDate;
  }


  public FloatSchedule flowConventions(FlowConventions flowConventions) {
    
    this.flowConventions = flowConventions;
    return this;
  }

   /**
   * Get flowConventions
   * @return flowConventions
  **/
  @jakarta.annotation.Nullable
  public FlowConventions getFlowConventions() {
    return flowConventions;
  }


  public void setFlowConventions(FlowConventions flowConventions) {
    this.flowConventions = flowConventions;
  }


  public FloatSchedule conventionName(FlowConventionName conventionName) {
    
    this.conventionName = conventionName;
    return this;
  }

   /**
   * Get conventionName
   * @return conventionName
  **/
  @jakarta.annotation.Nullable
  public FlowConventionName getConventionName() {
    return conventionName;
  }


  public void setConventionName(FlowConventionName conventionName) {
    this.conventionName = conventionName;
  }


  public FloatSchedule exDividendDays(Integer exDividendDays) {
    
    this.exDividendDays = exDividendDays;
    return this;
  }

   /**
   * Optional. Number of calendar days in the ex-dividend period.  If the settlement date falls in the ex-dividend period then the coupon paid is zero and the accrued interest is negative.  If set, this must be a non-negative number.  If not set, or set to 0, then there is no ex-dividend period.                NOTE: This field is deprecated.  If you wish to set the ExDividendDays on a bond, please use the ExDividendConfiguration.
   * @return exDividendDays
  **/
  @jakarta.annotation.Nullable
  public Integer getExDividendDays() {
    return exDividendDays;
  }


  public void setExDividendDays(Integer exDividendDays) {
    this.exDividendDays = exDividendDays;
  }


  public FloatSchedule indexConventionName(FlowConventionName indexConventionName) {
    
    this.indexConventionName = indexConventionName;
    return this;
  }

   /**
   * Get indexConventionName
   * @return indexConventionName
  **/
  @jakarta.annotation.Nullable
  public FlowConventionName getIndexConventionName() {
    return indexConventionName;
  }


  public void setIndexConventionName(FlowConventionName indexConventionName) {
    this.indexConventionName = indexConventionName;
  }


  public FloatSchedule indexConventions(IndexConvention indexConventions) {
    
    this.indexConventions = indexConventions;
    return this;
  }

   /**
   * Get indexConventions
   * @return indexConventions
  **/
  @jakarta.annotation.Nullable
  public IndexConvention getIndexConventions() {
    return indexConventions;
  }


  public void setIndexConventions(IndexConvention indexConventions) {
    this.indexConventions = indexConventions;
  }


  public FloatSchedule notional(java.math.BigDecimal notional) {
    
    this.notional = notional;
    return this;
  }

   /**
   * Scaling factor, the quantity outstanding on which the rate will be paid.
   * @return notional
  **/
  @jakarta.annotation.Nullable
  public java.math.BigDecimal getNotional() {
    return notional;
  }


  public void setNotional(java.math.BigDecimal notional) {
    this.notional = notional;
  }


  public FloatSchedule paymentCurrency(String paymentCurrency) {
    
    this.paymentCurrency = paymentCurrency;
    return this;
  }

   /**
   * Payment currency. This does not have to be the same as the nominal bond or observation/reset currency.
   * @return paymentCurrency
  **/
  @jakarta.annotation.Nullable
  public String getPaymentCurrency() {
    return paymentCurrency;
  }


  public void setPaymentCurrency(String paymentCurrency) {
    this.paymentCurrency = paymentCurrency;
  }


  public FloatSchedule spread(java.math.BigDecimal spread) {
    
    this.spread = spread;
    return this;
  }

   /**
   * Spread over floating rate given as a fraction.
   * @return spread
  **/
  @jakarta.annotation.Nullable
  public java.math.BigDecimal getSpread() {
    return spread;
  }


  public void setSpread(java.math.BigDecimal spread) {
    this.spread = spread;
  }


  public FloatSchedule stubType(String stubType) {
    
    this.stubType = stubType;
    return this;
  }

   /**
   * StubType required of the schedule    Supported string (enumeration) values are: [ShortFront, ShortBack, LongBack, LongFront, Both].
   * @return stubType
  **/
  @jakarta.annotation.Nullable
  public String getStubType() {
    return stubType;
  }


  public void setStubType(String stubType) {
    this.stubType = stubType;
  }


  public FloatSchedule exDividendConfiguration(ExDividendConfiguration exDividendConfiguration) {
    
    this.exDividendConfiguration = exDividendConfiguration;
    return this;
  }

   /**
   * Get exDividendConfiguration
   * @return exDividendConfiguration
  **/
  @jakarta.annotation.Nullable
  public ExDividendConfiguration getExDividendConfiguration() {
    return exDividendConfiguration;
  }


  public void setExDividendConfiguration(ExDividendConfiguration exDividendConfiguration) {
    this.exDividendConfiguration = exDividendConfiguration;
  }



  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    FloatSchedule floatSchedule = (FloatSchedule) o;
    return Objects.equals(this.startDate, floatSchedule.startDate) &&
        Objects.equals(this.maturityDate, floatSchedule.maturityDate) &&
        Objects.equals(this.flowConventions, floatSchedule.flowConventions) &&
        Objects.equals(this.conventionName, floatSchedule.conventionName) &&
        Objects.equals(this.exDividendDays, floatSchedule.exDividendDays) &&
        Objects.equals(this.indexConventionName, floatSchedule.indexConventionName) &&
        Objects.equals(this.indexConventions, floatSchedule.indexConventions) &&
        (this.notional.compareTo(floatSchedule.getNotional()) == 0) &&
        Objects.equals(this.paymentCurrency, floatSchedule.paymentCurrency) &&
        (this.spread.compareTo(floatSchedule.getSpread()) == 0) &&
        Objects.equals(this.stubType, floatSchedule.stubType) &&
        Objects.equals(this.exDividendConfiguration, floatSchedule.exDividendConfiguration) &&
        super.equals(o);
  }

  private static <T> boolean equalsNullable(JsonNullable<T> a, JsonNullable<T> b) {
    return a == b || (a != null && b != null && a.isPresent() && b.isPresent() && Objects.deepEquals(a.get(), b.get()));
  }

  @Override
  public int hashCode() {
    return Objects.hash(startDate, maturityDate, flowConventions, conventionName, exDividendDays, indexConventionName, indexConventions, notional, paymentCurrency, spread, stubType, exDividendConfiguration, super.hashCode());
  }

  private static <T> int hashCodeNullable(JsonNullable<T> a) {
    if (a == null) {
      return 1;
    }
    return a.isPresent() ? Arrays.deepHashCode(new Object[]{a.get()}) : 31;
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class FloatSchedule {\n");
    sb.append("    ").append(toIndentedString(super.toString())).append("\n");
    sb.append("    startDate: ").append(toIndentedString(startDate)).append("\n");
    sb.append("    maturityDate: ").append(toIndentedString(maturityDate)).append("\n");
    sb.append("    flowConventions: ").append(toIndentedString(flowConventions)).append("\n");
    sb.append("    conventionName: ").append(toIndentedString(conventionName)).append("\n");
    sb.append("    exDividendDays: ").append(toIndentedString(exDividendDays)).append("\n");
    sb.append("    indexConventionName: ").append(toIndentedString(indexConventionName)).append("\n");
    sb.append("    indexConventions: ").append(toIndentedString(indexConventions)).append("\n");
    sb.append("    notional: ").append(toIndentedString(notional)).append("\n");
    sb.append("    paymentCurrency: ").append(toIndentedString(paymentCurrency)).append("\n");
    sb.append("    spread: ").append(toIndentedString(spread)).append("\n");
    sb.append("    stubType: ").append(toIndentedString(stubType)).append("\n");
    sb.append("    exDividendConfiguration: ").append(toIndentedString(exDividendConfiguration)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }


  public static HashSet<String> openapiFields;
  public static HashSet<String> openapiRequiredFields;

  static {
    // a set of all properties/fields (JSON key names)
    openapiFields = new HashSet<String>();
    openapiFields.add("scheduleType");
    openapiFields.add("startDate");
    openapiFields.add("maturityDate");
    openapiFields.add("flowConventions");
    openapiFields.add("conventionName");
    openapiFields.add("exDividendDays");
    openapiFields.add("indexConventionName");
    openapiFields.add("indexConventions");
    openapiFields.add("notional");
    openapiFields.add("paymentCurrency");
    openapiFields.add("spread");
    openapiFields.add("stubType");
    openapiFields.add("exDividendConfiguration");

    // a set of required properties/fields (JSON key names)
    openapiRequiredFields = new HashSet<String>();
    openapiRequiredFields.add("scheduleType");
  }

 /**
  * Validates the JSON Object and throws an exception if issues found
  *
  * @param jsonObj JSON Object
  * @throws IOException if the JSON Object is invalid with respect to FloatSchedule
  */
  public static void validateJsonObject(JsonObject jsonObj) throws IOException {
      if (jsonObj == null) {
        if (!FloatSchedule.openapiRequiredFields.isEmpty()) { // has required fields but JSON object is null
          throw new IllegalArgumentException(String.format("The required field(s) %s in FloatSchedule is not found in the empty JSON string", FloatSchedule.openapiRequiredFields.toString()));
        }
      }

      Set<Entry<String, JsonElement>> entries = jsonObj.entrySet();
      // check to see if the JSON string contains additional fields
      for (Entry<String, JsonElement> entry : entries) {
        if (!FloatSchedule.openapiFields.contains(entry.getKey())) {
          throw new IllegalArgumentException(String.format("The field `%s` in the JSON string is not defined in the `FloatSchedule` properties. JSON: %s", entry.getKey(), jsonObj.toString()));
        }
      }

      // check to make sure all required properties/fields are present in the JSON string
      for (String requiredField : FloatSchedule.openapiRequiredFields) {
        if (jsonObj.get(requiredField) == null) {
          throw new IllegalArgumentException(String.format("The required field `%s` is not found in the JSON string: %s", requiredField, jsonObj.toString()));
        }
      }
  }

  public static class CustomTypeAdapterFactory implements TypeAdapterFactory {
    @SuppressWarnings("unchecked")
    @Override
    public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {
       if (!FloatSchedule.class.isAssignableFrom(type.getRawType())) {
         return null; // this class only serializes 'FloatSchedule' and its subtypes
       }
       final TypeAdapter<JsonElement> elementAdapter = gson.getAdapter(JsonElement.class);
       final TypeAdapter<FloatSchedule> thisAdapter
                        = gson.getDelegateAdapter(this, TypeToken.get(FloatSchedule.class));

       return (TypeAdapter<T>) new TypeAdapter<FloatSchedule>() {
           @Override
           public void write(JsonWriter out, FloatSchedule value) throws IOException {
             JsonObject obj = thisAdapter.toJsonTree(value).getAsJsonObject();
             elementAdapter.write(out, obj);
           }

           @Override
           public FloatSchedule read(JsonReader in) throws IOException {
             JsonObject jsonObj = elementAdapter.read(in).getAsJsonObject();
             validateJsonObject(jsonObj);
             return thisAdapter.fromJsonTree(jsonObj);
           }

       }.nullSafe();
    }
  }

 /**
  * Create an instance of FloatSchedule given an JSON string
  *
  * @param jsonString JSON string
  * @return An instance of FloatSchedule
  * @throws IOException if the JSON string is invalid with respect to FloatSchedule
  */
  public static FloatSchedule fromJson(String jsonString) throws IOException {
    return JSON.getGson().fromJson(jsonString, FloatSchedule.class);
  }

 /**
  * Convert an instance of FloatSchedule to an JSON string
  *
  * @return JSON string
  */
  public String toJson() {
    return JSON.getGson().toJson(this);
  }
}
