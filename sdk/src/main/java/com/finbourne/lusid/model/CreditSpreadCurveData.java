/*
 * LUSID API
 *
 * Contact: info@finbourne.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

package com.finbourne.lusid.model;

import java.util.Objects;
import com.finbourne.lusid.model.ComplexMarketData;
import com.finbourne.lusid.model.MarketDataOptions;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;
import java.time.OffsetDateTime;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import org.openapitools.jackson.nullable.JsonNullable;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonArray;
import com.google.gson.JsonDeserializationContext;
import com.google.gson.JsonDeserializer;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParseException;
import com.google.gson.TypeAdapterFactory;
import com.google.gson.reflect.TypeToken;
import com.google.gson.TypeAdapter;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;

import java.lang.reflect.Type;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Map.Entry;
import java.util.Set;

import com.finbourne.lusid.JSON;

/**
 * A credit spread curve matching tenors against par spread quotes
 */
@jakarta.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen")
public class CreditSpreadCurveData extends ComplexMarketData {
  public static final String SERIALIZED_NAME_BASE_DATE = "baseDate";
  @SerializedName(SERIALIZED_NAME_BASE_DATE)
  private OffsetDateTime baseDate;

  public static final String SERIALIZED_NAME_DOM_CCY = "domCcy";
  @SerializedName(SERIALIZED_NAME_DOM_CCY)
  private String domCcy;

  public static final String SERIALIZED_NAME_TENORS = "tenors";
  @SerializedName(SERIALIZED_NAME_TENORS)
  private List<String> tenors = new ArrayList<>();

  public static final String SERIALIZED_NAME_SPREADS = "spreads";
  @SerializedName(SERIALIZED_NAME_SPREADS)
  private List<java.math.BigDecimal> spreads = new ArrayList<>();

  public static final String SERIALIZED_NAME_RECOVERY_RATE = "recoveryRate";
  @SerializedName(SERIALIZED_NAME_RECOVERY_RATE)
  private java.math.BigDecimal recoveryRate;

  public static final String SERIALIZED_NAME_REFERENCE_DATE = "referenceDate";
  @SerializedName(SERIALIZED_NAME_REFERENCE_DATE)
  private OffsetDateTime referenceDate;

  public static final String SERIALIZED_NAME_MATURITIES = "maturities";
  @SerializedName(SERIALIZED_NAME_MATURITIES)
  private List<OffsetDateTime> maturities;

  public static final String SERIALIZED_NAME_LINEAGE = "lineage";
  @SerializedName(SERIALIZED_NAME_LINEAGE)
  private String lineage;

  public static final String SERIALIZED_NAME_MARKET_DATA_OPTIONS = "marketDataOptions";
  @SerializedName(SERIALIZED_NAME_MARKET_DATA_OPTIONS)
  private MarketDataOptions marketDataOptions;

  public CreditSpreadCurveData() {
    // this.marketDataType = this.getClass().getSimpleName();
  }

  public CreditSpreadCurveData baseDate(OffsetDateTime baseDate) {
    
    this.baseDate = baseDate;
    return this;
  }

   /**
   * EffectiveAt date of the quoted rates
   * @return baseDate
  **/
  @jakarta.annotation.Nonnull
  public OffsetDateTime getBaseDate() {
    return baseDate;
  }


  public void setBaseDate(OffsetDateTime baseDate) {
    this.baseDate = baseDate;
  }


  public CreditSpreadCurveData domCcy(String domCcy) {
    
    this.domCcy = domCcy;
    return this;
  }

   /**
   * Domestic currency of the curve
   * @return domCcy
  **/
  @jakarta.annotation.Nonnull
  public String getDomCcy() {
    return domCcy;
  }


  public void setDomCcy(String domCcy) {
    this.domCcy = domCcy;
  }


  public CreditSpreadCurveData tenors(List<String> tenors) {
    
    this.tenors = tenors;
    return this;
  }

  public CreditSpreadCurveData addTenorsItem(String tenorsItem) {
    if (this.tenors == null) {
      this.tenors = new ArrayList<>();
    }
    this.tenors.add(tenorsItem);
    return this;
  }

   /**
   * The tenors for which the rates apply For more information on tenors, see [knowledge base article KA-02097](https://support.lusid.com/knowledgebase/article/KA-02097)
   * @return tenors
  **/
  @jakarta.annotation.Nonnull
  public List<String> getTenors() {
    return tenors;
  }


  public void setTenors(List<String> tenors) {
    this.tenors = tenors;
  }


  public CreditSpreadCurveData spreads(List<java.math.BigDecimal> spreads) {
    
    this.spreads = spreads;
    return this;
  }

  public CreditSpreadCurveData addSpreadsItem(java.math.BigDecimal spreadsItem) {
    if (this.spreads == null) {
      this.spreads = new ArrayList<>();
    }
    this.spreads.add(spreadsItem);
    return this;
  }

   /**
   * Par spread quotes corresponding to the tenors.
   * @return spreads
  **/
  @jakarta.annotation.Nonnull
  public List<java.math.BigDecimal> getSpreads() {
    return spreads;
  }


  public void setSpreads(List<java.math.BigDecimal> spreads) {
    this.spreads = spreads;
  }


  public CreditSpreadCurveData recoveryRate(java.math.BigDecimal recoveryRate) {
    
    this.recoveryRate = recoveryRate;
    return this;
  }

   /**
   * The recovery rate in default.
   * @return recoveryRate
  **/
  @jakarta.annotation.Nonnull
  public java.math.BigDecimal getRecoveryRate() {
    return recoveryRate;
  }


  public void setRecoveryRate(java.math.BigDecimal recoveryRate) {
    this.recoveryRate = recoveryRate;
  }


  public CreditSpreadCurveData referenceDate(OffsetDateTime referenceDate) {
    
    this.referenceDate = referenceDate;
    return this;
  }

   /**
   * If tenors are provided, this is the date against which the tenors will be resolved. This is of importance to CDX spread quotes, which are usually quoted in tenors relative to the CDX start date. In this case, the ReferenceDate would be equal to the CDX start date, and the BaseDate would be the date for which the spreads are valid. If not provided, this defaults to the BaseDate of the curve.
   * @return referenceDate
  **/
  @jakarta.annotation.Nullable
  public OffsetDateTime getReferenceDate() {
    return referenceDate;
  }


  public void setReferenceDate(OffsetDateTime referenceDate) {
    this.referenceDate = referenceDate;
  }


  public CreditSpreadCurveData maturities(List<OffsetDateTime> maturities) {
    
    this.maturities = maturities;
    return this;
  }

  public CreditSpreadCurveData addMaturitiesItem(OffsetDateTime maturitiesItem) {
    if (this.maturities == null) {
      this.maturities = new ArrayList<>();
    }
    this.maturities.add(maturitiesItem);
    return this;
  }

   /**
   * The maturity dates for which the rates apply. Either tenors or maturities should be provided, not both.
   * @return maturities
  **/
  @jakarta.annotation.Nullable
  public List<OffsetDateTime> getMaturities() {
    return maturities;
  }


  public void setMaturities(List<OffsetDateTime> maturities) {
    this.maturities = maturities;
  }


  public CreditSpreadCurveData lineage(String lineage) {
    
    this.lineage = lineage;
    return this;
  }

   /**
   * Description of the complex market data&#39;s lineage e.g. &#39;FundAccountant_GreenQuality&#39;.
   * @return lineage
  **/
  @jakarta.annotation.Nullable
  public String getLineage() {
    return lineage;
  }


  public void setLineage(String lineage) {
    this.lineage = lineage;
  }


  public CreditSpreadCurveData marketDataOptions(MarketDataOptions marketDataOptions) {
    
    this.marketDataOptions = marketDataOptions;
    return this;
  }

   /**
   * Get marketDataOptions
   * @return marketDataOptions
  **/
  @jakarta.annotation.Nullable
  public MarketDataOptions getMarketDataOptions() {
    return marketDataOptions;
  }


  public void setMarketDataOptions(MarketDataOptions marketDataOptions) {
    this.marketDataOptions = marketDataOptions;
  }



  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    CreditSpreadCurveData creditSpreadCurveData = (CreditSpreadCurveData) o;
    return Objects.equals(this.baseDate, creditSpreadCurveData.baseDate) &&
        Objects.equals(this.domCcy, creditSpreadCurveData.domCcy) &&
        Objects.equals(this.tenors, creditSpreadCurveData.tenors) &&
        Objects.equals(this.spreads, creditSpreadCurveData.spreads) &&
        (this.recoveryRate.compareTo(creditSpreadCurveData.getRecoveryRate()) == 0) &&
        Objects.equals(this.referenceDate, creditSpreadCurveData.referenceDate) &&
        Objects.equals(this.maturities, creditSpreadCurveData.maturities) &&
        Objects.equals(this.lineage, creditSpreadCurveData.lineage) &&
        Objects.equals(this.marketDataOptions, creditSpreadCurveData.marketDataOptions) &&
        super.equals(o);
  }

  private static <T> boolean equalsNullable(JsonNullable<T> a, JsonNullable<T> b) {
    return a == b || (a != null && b != null && a.isPresent() && b.isPresent() && Objects.deepEquals(a.get(), b.get()));
  }

  @Override
  public int hashCode() {
    return Objects.hash(baseDate, domCcy, tenors, spreads, recoveryRate, referenceDate, maturities, lineage, marketDataOptions, super.hashCode());
  }

  private static <T> int hashCodeNullable(JsonNullable<T> a) {
    if (a == null) {
      return 1;
    }
    return a.isPresent() ? Arrays.deepHashCode(new Object[]{a.get()}) : 31;
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class CreditSpreadCurveData {\n");
    sb.append("    ").append(toIndentedString(super.toString())).append("\n");
    sb.append("    baseDate: ").append(toIndentedString(baseDate)).append("\n");
    sb.append("    domCcy: ").append(toIndentedString(domCcy)).append("\n");
    sb.append("    tenors: ").append(toIndentedString(tenors)).append("\n");
    sb.append("    spreads: ").append(toIndentedString(spreads)).append("\n");
    sb.append("    recoveryRate: ").append(toIndentedString(recoveryRate)).append("\n");
    sb.append("    referenceDate: ").append(toIndentedString(referenceDate)).append("\n");
    sb.append("    maturities: ").append(toIndentedString(maturities)).append("\n");
    sb.append("    lineage: ").append(toIndentedString(lineage)).append("\n");
    sb.append("    marketDataOptions: ").append(toIndentedString(marketDataOptions)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }


  public static HashSet<String> openapiFields;
  public static HashSet<String> openapiRequiredFields;

  static {
    // a set of all properties/fields (JSON key names)
    openapiFields = new HashSet<String>();
    openapiFields.add("marketDataType");
    openapiFields.add("baseDate");
    openapiFields.add("domCcy");
    openapiFields.add("tenors");
    openapiFields.add("spreads");
    openapiFields.add("recoveryRate");
    openapiFields.add("referenceDate");
    openapiFields.add("maturities");
    openapiFields.add("lineage");
    openapiFields.add("marketDataOptions");

    // a set of required properties/fields (JSON key names)
    openapiRequiredFields = new HashSet<String>();
    openapiRequiredFields.add("baseDate");
    openapiRequiredFields.add("domCcy");
    openapiRequiredFields.add("tenors");
    openapiRequiredFields.add("spreads");
    openapiRequiredFields.add("recoveryRate");
    openapiRequiredFields.add("marketDataType");
  }

 /**
  * Validates the JSON Element and throws an exception if issues found
  *
  * @param jsonElement JSON Element
  * @throws IOException if the JSON Element is invalid with respect to CreditSpreadCurveData
  */
  public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      if (jsonElement == null) {
        if (!CreditSpreadCurveData.openapiRequiredFields.isEmpty()) { // has required fields but JSON element is null
          throw new IllegalArgumentException(String.format("The required field(s) %s in CreditSpreadCurveData is not found in the empty JSON string", CreditSpreadCurveData.openapiRequiredFields.toString()));
        }
      }

      // check to make sure all required properties/fields are present in the JSON string
      for (String requiredField : CreditSpreadCurveData.openapiRequiredFields) {
        if (jsonElement.getAsJsonObject().get(requiredField) == null) {
          throw new IllegalArgumentException(String.format("The required field `%s` is not found in the JSON string: %s", requiredField, jsonElement.toString()));
        }
      }
  }

  public static class CustomTypeAdapterFactory implements TypeAdapterFactory {
    @SuppressWarnings("unchecked")
    @Override
    public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {
       if (!CreditSpreadCurveData.class.isAssignableFrom(type.getRawType())) {
         return null; // this class only serializes 'CreditSpreadCurveData' and its subtypes
       }
       final TypeAdapter<JsonElement> elementAdapter = gson.getAdapter(JsonElement.class);
       final TypeAdapter<CreditSpreadCurveData> thisAdapter
                        = gson.getDelegateAdapter(this, TypeToken.get(CreditSpreadCurveData.class));

       return (TypeAdapter<T>) new TypeAdapter<CreditSpreadCurveData>() {
           @Override
           public void write(JsonWriter out, CreditSpreadCurveData value) throws IOException {
             JsonObject obj = thisAdapter.toJsonTree(value).getAsJsonObject();
             elementAdapter.write(out, obj);
           }

           @Override
           public CreditSpreadCurveData read(JsonReader in) throws IOException {
             JsonElement jsonElement = elementAdapter.read(in);
             validateJsonElement(jsonElement);
             return thisAdapter.fromJsonTree(jsonElement);
           }

       }.nullSafe();
    }
  }

 /**
  * Create an instance of CreditSpreadCurveData given an JSON string
  *
  * @param jsonString JSON string
  * @return An instance of CreditSpreadCurveData
  * @throws IOException if the JSON string is invalid with respect to CreditSpreadCurveData
  */
  public static CreditSpreadCurveData fromJson(String jsonString) throws IOException {
    return JSON.getGson().fromJson(jsonString, CreditSpreadCurveData.class);
  }

 /**
  * Convert an instance of CreditSpreadCurveData to an JSON string
  *
  * @return JSON string
  */
  public String toJson() {
    return JSON.getGson().toJson(this);
  }
}
