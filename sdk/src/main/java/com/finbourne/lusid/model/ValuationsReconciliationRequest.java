/*
 * LUSID API
 *
 * Contact: info@finbourne.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

package com.finbourne.lusid.model;

import java.util.Objects;
import com.finbourne.lusid.model.ReconciliationLeftRightAddressKeyPair;
import com.finbourne.lusid.model.ValuationRequest;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import org.openapitools.jackson.nullable.JsonNullable;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonArray;
import com.google.gson.JsonDeserializationContext;
import com.google.gson.JsonDeserializer;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParseException;
import com.google.gson.TypeAdapterFactory;
import com.google.gson.reflect.TypeToken;
import com.google.gson.TypeAdapter;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;

import java.lang.reflect.Type;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Map.Entry;
import java.util.Set;

import com.finbourne.lusid.JSON;

/**
 * Specification for the reconciliation request. Left and Right hand sides are constructed. Each consists of a valuation of a portfolio using an aggregation request. The results of this can then be compared to each other. The difference, which is effectively a risk based difference allows comparison of the effects of changing a recipe, valuation date, or (though it may or may not make logical sense) a portfolio. For instance, one might look at the difference in risk caused by the addition of transaction to a portfolio, or through changing the valuation methodology or system.
 */
@jakarta.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen")
public class ValuationsReconciliationRequest {
  public static final String SERIALIZED_NAME_LEFT = "left";
  @SerializedName(SERIALIZED_NAME_LEFT)
  private ValuationRequest left;

  public static final String SERIALIZED_NAME_RIGHT = "right";
  @SerializedName(SERIALIZED_NAME_RIGHT)
  private ValuationRequest right;

  public static final String SERIALIZED_NAME_LEFT_TO_RIGHT_MAPPING = "leftToRightMapping";
  @SerializedName(SERIALIZED_NAME_LEFT_TO_RIGHT_MAPPING)
  private List<ReconciliationLeftRightAddressKeyPair> leftToRightMapping;

  public static final String SERIALIZED_NAME_PRESERVE_KEYS = "preserveKeys";
  @SerializedName(SERIALIZED_NAME_PRESERVE_KEYS)
  private List<String> preserveKeys;

  public ValuationsReconciliationRequest() {
  }

  public ValuationsReconciliationRequest left(ValuationRequest left) {
    
    this.left = left;
    return this;
  }

   /**
   * Get left
   * @return left
  **/
  @jakarta.annotation.Nonnull
  public ValuationRequest getLeft() {
    return left;
  }


  public void setLeft(ValuationRequest left) {
    this.left = left;
  }


  public ValuationsReconciliationRequest right(ValuationRequest right) {
    
    this.right = right;
    return this;
  }

   /**
   * Get right
   * @return right
  **/
  @jakarta.annotation.Nonnull
  public ValuationRequest getRight() {
    return right;
  }


  public void setRight(ValuationRequest right) {
    this.right = right;
  }


  public ValuationsReconciliationRequest leftToRightMapping(List<ReconciliationLeftRightAddressKeyPair> leftToRightMapping) {
    
    this.leftToRightMapping = leftToRightMapping;
    return this;
  }

  public ValuationsReconciliationRequest addLeftToRightMappingItem(ReconciliationLeftRightAddressKeyPair leftToRightMappingItem) {
    if (this.leftToRightMapping == null) {
      this.leftToRightMapping = new ArrayList<>();
    }
    this.leftToRightMapping.add(leftToRightMappingItem);
    return this;
  }

   /**
   * The mapping from property keys requested by left aggregation to property keys on right hand side
   * @return leftToRightMapping
  **/
  @jakarta.annotation.Nullable
  public List<ReconciliationLeftRightAddressKeyPair> getLeftToRightMapping() {
    return leftToRightMapping;
  }


  public void setLeftToRightMapping(List<ReconciliationLeftRightAddressKeyPair> leftToRightMapping) {
    this.leftToRightMapping = leftToRightMapping;
  }


  public ValuationsReconciliationRequest preserveKeys(List<String> preserveKeys) {
    
    this.preserveKeys = preserveKeys;
    return this;
  }

  public ValuationsReconciliationRequest addPreserveKeysItem(String preserveKeysItem) {
    if (this.preserveKeys == null) {
      this.preserveKeys = new ArrayList<>();
    }
    this.preserveKeys.add(preserveKeysItem);
    return this;
  }

   /**
   * List of keys to preserve (from rhs) in the diff. Used in conjunction with filtering/grouping. If two values are equal, for a given key then the value is elided from the results. Setting it here will preserve it (takes the values from the RHS and puts it into the line by line results).
   * @return preserveKeys
  **/
  @jakarta.annotation.Nullable
  public List<String> getPreserveKeys() {
    return preserveKeys;
  }


  public void setPreserveKeys(List<String> preserveKeys) {
    this.preserveKeys = preserveKeys;
  }



  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    ValuationsReconciliationRequest valuationsReconciliationRequest = (ValuationsReconciliationRequest) o;
    return Objects.equals(this.left, valuationsReconciliationRequest.left) &&
        Objects.equals(this.right, valuationsReconciliationRequest.right) &&
        Objects.equals(this.leftToRightMapping, valuationsReconciliationRequest.leftToRightMapping) &&
        Objects.equals(this.preserveKeys, valuationsReconciliationRequest.preserveKeys);
  }

  private static <T> boolean equalsNullable(JsonNullable<T> a, JsonNullable<T> b) {
    return a == b || (a != null && b != null && a.isPresent() && b.isPresent() && Objects.deepEquals(a.get(), b.get()));
  }

  @Override
  public int hashCode() {
    return Objects.hash(left, right, leftToRightMapping, preserveKeys);
  }

  private static <T> int hashCodeNullable(JsonNullable<T> a) {
    if (a == null) {
      return 1;
    }
    return a.isPresent() ? Arrays.deepHashCode(new Object[]{a.get()}) : 31;
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class ValuationsReconciliationRequest {\n");
    sb.append("    left: ").append(toIndentedString(left)).append("\n");
    sb.append("    right: ").append(toIndentedString(right)).append("\n");
    sb.append("    leftToRightMapping: ").append(toIndentedString(leftToRightMapping)).append("\n");
    sb.append("    preserveKeys: ").append(toIndentedString(preserveKeys)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }


  public static HashSet<String> openapiFields;
  public static HashSet<String> openapiRequiredFields;

  static {
    // a set of all properties/fields (JSON key names)
    openapiFields = new HashSet<String>();
    openapiFields.add("left");
    openapiFields.add("right");
    openapiFields.add("leftToRightMapping");
    openapiFields.add("preserveKeys");

    // a set of required properties/fields (JSON key names)
    openapiRequiredFields = new HashSet<String>();
    openapiRequiredFields.add("left");
    openapiRequiredFields.add("right");
  }

 /**
  * Validates the JSON Element and throws an exception if issues found
  *
  * @param jsonElement JSON Element
  * @throws IOException if the JSON Element is invalid with respect to ValuationsReconciliationRequest
  */
  public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      if (jsonElement == null) {
        if (!ValuationsReconciliationRequest.openapiRequiredFields.isEmpty()) { // has required fields but JSON element is null
          throw new IllegalArgumentException(String.format("The required field(s) %s in ValuationsReconciliationRequest is not found in the empty JSON string", ValuationsReconciliationRequest.openapiRequiredFields.toString()));
        }
      }

      // check to make sure all required properties/fields are present in the JSON string
      for (String requiredField : ValuationsReconciliationRequest.openapiRequiredFields) {
        if (jsonElement.getAsJsonObject().get(requiredField) == null) {
          throw new IllegalArgumentException(String.format("The required field `%s` is not found in the JSON string: %s", requiredField, jsonElement.toString()));
        }
      }
        JsonObject jsonObj = jsonElement.getAsJsonObject();
      // validate the required field `left`
      ValuationRequest.validateJsonElement(jsonObj.get("left"));
      // validate the required field `right`
      ValuationRequest.validateJsonElement(jsonObj.get("right"));
      if (jsonObj.get("leftToRightMapping") != null && !jsonObj.get("leftToRightMapping").isJsonNull()) {
        JsonArray jsonArrayleftToRightMapping = jsonObj.getAsJsonArray("leftToRightMapping");
        if (jsonArrayleftToRightMapping != null) {
          // ensure the json data is an array
          if (!jsonObj.get("leftToRightMapping").isJsonArray()) {
            throw new IllegalArgumentException(String.format("Expected the field `leftToRightMapping` to be an array in the JSON string but got `%s`", jsonObj.get("leftToRightMapping").toString()));
          }

          // validate the optional field `leftToRightMapping` (array)
          for (int i = 0; i < jsonArrayleftToRightMapping.size(); i++) {
            ReconciliationLeftRightAddressKeyPair.validateJsonElement(jsonArrayleftToRightMapping.get(i));
          };
        }
      }
      // ensure the optional json data is an array if present
      if (jsonObj.get("preserveKeys") != null && !jsonObj.get("preserveKeys").isJsonNull() && !jsonObj.get("preserveKeys").isJsonArray()) {
        throw new IllegalArgumentException(String.format("Expected the field `preserveKeys` to be an array in the JSON string but got `%s`", jsonObj.get("preserveKeys").toString()));
      }
  }

  public static class CustomTypeAdapterFactory implements TypeAdapterFactory {
    @SuppressWarnings("unchecked")
    @Override
    public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {
       if (!ValuationsReconciliationRequest.class.isAssignableFrom(type.getRawType())) {
         return null; // this class only serializes 'ValuationsReconciliationRequest' and its subtypes
       }
       final TypeAdapter<JsonElement> elementAdapter = gson.getAdapter(JsonElement.class);
       final TypeAdapter<ValuationsReconciliationRequest> thisAdapter
                        = gson.getDelegateAdapter(this, TypeToken.get(ValuationsReconciliationRequest.class));

       return (TypeAdapter<T>) new TypeAdapter<ValuationsReconciliationRequest>() {
           @Override
           public void write(JsonWriter out, ValuationsReconciliationRequest value) throws IOException {
             JsonObject obj = thisAdapter.toJsonTree(value).getAsJsonObject();
             elementAdapter.write(out, obj);
           }

           @Override
           public ValuationsReconciliationRequest read(JsonReader in) throws IOException {
             JsonElement jsonElement = elementAdapter.read(in);
             validateJsonElement(jsonElement);
             return thisAdapter.fromJsonTree(jsonElement);
           }

       }.nullSafe();
    }
  }

 /**
  * Create an instance of ValuationsReconciliationRequest given an JSON string
  *
  * @param jsonString JSON string
  * @return An instance of ValuationsReconciliationRequest
  * @throws IOException if the JSON string is invalid with respect to ValuationsReconciliationRequest
  */
  public static ValuationsReconciliationRequest fromJson(String jsonString) throws IOException {
    return JSON.getGson().fromJson(jsonString, ValuationsReconciliationRequest.class);
  }

 /**
  * Convert an instance of ValuationsReconciliationRequest to an JSON string
  *
  * @return JSON string
  */
  public String toJson() {
    return JSON.getGson().toJson(this);
  }
}
