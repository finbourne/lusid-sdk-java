/*
 * LUSID API
 *
 * Contact: info@finbourne.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

package com.finbourne.lusid.model;

import java.util.Objects;
import com.finbourne.lusid.model.CurrencyAndAmount;
import com.finbourne.lusid.model.JournalEntryLineShareClassBreakdown;
import com.finbourne.lusid.model.Link;
import com.finbourne.lusid.model.PerpetualProperty;
import com.finbourne.lusid.model.Property;
import com.finbourne.lusid.model.ResourceId;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;
import java.time.OffsetDateTime;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import org.openapitools.jackson.nullable.JsonNullable;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonArray;
import com.google.gson.JsonDeserializationContext;
import com.google.gson.JsonDeserializer;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParseException;
import com.google.gson.TypeAdapterFactory;
import com.google.gson.reflect.TypeToken;
import com.google.gson.TypeAdapter;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;

import java.lang.reflect.Type;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Map.Entry;
import java.util.Set;

import com.finbourne.lusid.JSON;

/**
 * A Journal Entry line entity specifically for fund valuation point lines.
 */
@jakarta.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen")
public class FundJournalEntryLine {
  public static final String SERIALIZED_NAME_ACCOUNTING_DATE = "accountingDate";
  @SerializedName(SERIALIZED_NAME_ACCOUNTING_DATE)
  private OffsetDateTime accountingDate;

  public static final String SERIALIZED_NAME_ACTIVITY_DATE = "activityDate";
  @SerializedName(SERIALIZED_NAME_ACTIVITY_DATE)
  private OffsetDateTime activityDate;

  public static final String SERIALIZED_NAME_PORTFOLIO_ID = "portfolioId";
  @SerializedName(SERIALIZED_NAME_PORTFOLIO_ID)
  private ResourceId portfolioId;

  public static final String SERIALIZED_NAME_INSTRUMENT_ID = "instrumentId";
  @SerializedName(SERIALIZED_NAME_INSTRUMENT_ID)
  private String instrumentId;

  public static final String SERIALIZED_NAME_INSTRUMENT_SCOPE = "instrumentScope";
  @SerializedName(SERIALIZED_NAME_INSTRUMENT_SCOPE)
  private String instrumentScope;

  public static final String SERIALIZED_NAME_SUB_HOLDING_KEYS = "subHoldingKeys";
  @SerializedName(SERIALIZED_NAME_SUB_HOLDING_KEYS)
  private Map<String, PerpetualProperty> subHoldingKeys;

  public static final String SERIALIZED_NAME_TAX_LOT_ID = "taxLotId";
  @SerializedName(SERIALIZED_NAME_TAX_LOT_ID)
  private String taxLotId;

  public static final String SERIALIZED_NAME_GENERAL_LEDGER_ACCOUNT_CODE = "generalLedgerAccountCode";
  @SerializedName(SERIALIZED_NAME_GENERAL_LEDGER_ACCOUNT_CODE)
  private String generalLedgerAccountCode;

  public static final String SERIALIZED_NAME_LOCAL = "local";
  @SerializedName(SERIALIZED_NAME_LOCAL)
  private CurrencyAndAmount local;

  public static final String SERIALIZED_NAME_BASE = "base";
  @SerializedName(SERIALIZED_NAME_BASE)
  private CurrencyAndAmount base;

  public static final String SERIALIZED_NAME_UNITS = "units";
  @SerializedName(SERIALIZED_NAME_UNITS)
  private java.math.BigDecimal units;

  public static final String SERIALIZED_NAME_POSTING_MODULE_CODE = "postingModuleCode";
  @SerializedName(SERIALIZED_NAME_POSTING_MODULE_CODE)
  private String postingModuleCode;

  public static final String SERIALIZED_NAME_POSTING_RULE = "postingRule";
  @SerializedName(SERIALIZED_NAME_POSTING_RULE)
  private String postingRule;

  public static final String SERIALIZED_NAME_AS_AT_DATE = "asAtDate";
  @SerializedName(SERIALIZED_NAME_AS_AT_DATE)
  private OffsetDateTime asAtDate;

  public static final String SERIALIZED_NAME_ACTIVITIES_DESCRIPTION = "activitiesDescription";
  @SerializedName(SERIALIZED_NAME_ACTIVITIES_DESCRIPTION)
  private String activitiesDescription;

  public static final String SERIALIZED_NAME_SOURCE_TYPE = "sourceType";
  @SerializedName(SERIALIZED_NAME_SOURCE_TYPE)
  private String sourceType;

  public static final String SERIALIZED_NAME_SOURCE_ID = "sourceId";
  @SerializedName(SERIALIZED_NAME_SOURCE_ID)
  private String sourceId;

  public static final String SERIALIZED_NAME_PROPERTIES = "properties";
  @SerializedName(SERIALIZED_NAME_PROPERTIES)
  private Map<String, Property> properties;

  public static final String SERIALIZED_NAME_MOVEMENT_NAME = "movementName";
  @SerializedName(SERIALIZED_NAME_MOVEMENT_NAME)
  private String movementName;

  public static final String SERIALIZED_NAME_HOLDING_TYPE = "holdingType";
  @SerializedName(SERIALIZED_NAME_HOLDING_TYPE)
  private String holdingType;

  public static final String SERIALIZED_NAME_ECONOMIC_BUCKET = "economicBucket";
  @SerializedName(SERIALIZED_NAME_ECONOMIC_BUCKET)
  private String economicBucket;

  public static final String SERIALIZED_NAME_ECONOMIC_BUCKET_COMPONENT = "economicBucketComponent";
  @SerializedName(SERIALIZED_NAME_ECONOMIC_BUCKET_COMPONENT)
  private String economicBucketComponent;

  public static final String SERIALIZED_NAME_ECONOMIC_BUCKET_VARIANT = "economicBucketVariant";
  @SerializedName(SERIALIZED_NAME_ECONOMIC_BUCKET_VARIANT)
  private String economicBucketVariant;

  public static final String SERIALIZED_NAME_LEVELS = "levels";
  @SerializedName(SERIALIZED_NAME_LEVELS)
  private List<String> levels;

  public static final String SERIALIZED_NAME_SOURCE_LEVELS = "sourceLevels";
  @SerializedName(SERIALIZED_NAME_SOURCE_LEVELS)
  private List<String> sourceLevels;

  public static final String SERIALIZED_NAME_MOVEMENT_SIGN = "movementSign";
  @SerializedName(SERIALIZED_NAME_MOVEMENT_SIGN)
  private String movementSign;

  public static final String SERIALIZED_NAME_HOLDING_SIGN = "holdingSign";
  @SerializedName(SERIALIZED_NAME_HOLDING_SIGN)
  private String holdingSign;

  public static final String SERIALIZED_NAME_LEDGER_COLUMN = "ledgerColumn";
  @SerializedName(SERIALIZED_NAME_LEDGER_COLUMN)
  private String ledgerColumn;

  public static final String SERIALIZED_NAME_JOURNAL_ENTRY_LINE_TYPE = "journalEntryLineType";
  @SerializedName(SERIALIZED_NAME_JOURNAL_ENTRY_LINE_TYPE)
  private String journalEntryLineType;

  public static final String SERIALIZED_NAME_SHARE_CLASS_BREAKDOWNS = "shareClassBreakdowns";
  @SerializedName(SERIALIZED_NAME_SHARE_CLASS_BREAKDOWNS)
  private List<JournalEntryLineShareClassBreakdown> shareClassBreakdowns;

  public static final String SERIALIZED_NAME_LINKS = "links";
  @SerializedName(SERIALIZED_NAME_LINKS)
  private List<Link> links;

  public FundJournalEntryLine() {
  }

  public FundJournalEntryLine accountingDate(OffsetDateTime accountingDate) {
    
    this.accountingDate = accountingDate;
    return this;
  }

   /**
   * The Journal Entry Line accounting date.
   * @return accountingDate
  **/
  @jakarta.annotation.Nonnull
  public OffsetDateTime getAccountingDate() {
    return accountingDate;
  }


  public void setAccountingDate(OffsetDateTime accountingDate) {
    this.accountingDate = accountingDate;
  }


  public FundJournalEntryLine activityDate(OffsetDateTime activityDate) {
    
    this.activityDate = activityDate;
    return this;
  }

   /**
   * The actual date of the activity. Differs from the accounting date when creating journals that would occur in a closed period.
   * @return activityDate
  **/
  @jakarta.annotation.Nonnull
  public OffsetDateTime getActivityDate() {
    return activityDate;
  }


  public void setActivityDate(OffsetDateTime activityDate) {
    this.activityDate = activityDate;
  }


  public FundJournalEntryLine portfolioId(ResourceId portfolioId) {
    
    this.portfolioId = portfolioId;
    return this;
  }

   /**
   * Get portfolioId
   * @return portfolioId
  **/
  @jakarta.annotation.Nonnull
  public ResourceId getPortfolioId() {
    return portfolioId;
  }


  public void setPortfolioId(ResourceId portfolioId) {
    this.portfolioId = portfolioId;
  }


  public FundJournalEntryLine instrumentId(String instrumentId) {
    
    this.instrumentId = instrumentId;
    return this;
  }

   /**
   * To indicate the instrument of the transaction that the Journal Entry Line posted for, if applicable.
   * @return instrumentId
  **/
  @jakarta.annotation.Nonnull
  public String getInstrumentId() {
    return instrumentId;
  }


  public void setInstrumentId(String instrumentId) {
    this.instrumentId = instrumentId;
  }


  public FundJournalEntryLine instrumentScope(String instrumentScope) {
    
    this.instrumentScope = instrumentScope;
    return this;
  }

   /**
   * The scope in which the Journal Entry Line instrument is in.
   * @return instrumentScope
  **/
  @jakarta.annotation.Nonnull
  public String getInstrumentScope() {
    return instrumentScope;
  }


  public void setInstrumentScope(String instrumentScope) {
    this.instrumentScope = instrumentScope;
  }


  public FundJournalEntryLine subHoldingKeys(Map<String, PerpetualProperty> subHoldingKeys) {
    
    this.subHoldingKeys = subHoldingKeys;
    return this;
  }

  public FundJournalEntryLine putSubHoldingKeysItem(String key, PerpetualProperty subHoldingKeysItem) {
    if (this.subHoldingKeys == null) {
      this.subHoldingKeys = new HashMap<>();
    }
    this.subHoldingKeys.put(key, subHoldingKeysItem);
    return this;
  }

   /**
   * The sub-holding properties which are part of the AccountingKey.
   * @return subHoldingKeys
  **/
  @jakarta.annotation.Nullable
  public Map<String, PerpetualProperty> getSubHoldingKeys() {
    return subHoldingKeys;
  }


  public void setSubHoldingKeys(Map<String, PerpetualProperty> subHoldingKeys) {
    this.subHoldingKeys = subHoldingKeys;
  }


  public FundJournalEntryLine taxLotId(String taxLotId) {
    
    this.taxLotId = taxLotId;
    return this;
  }

   /**
   * If the holding type is &#39;B&#39; (settled cash balance), this is 1. Otherwise, this is the ID of a tax lot if applicable, or the source ID of the original transaction if not.
   * @return taxLotId
  **/
  @jakarta.annotation.Nullable
  public String getTaxLotId() {
    return taxLotId;
  }


  public void setTaxLotId(String taxLotId) {
    this.taxLotId = taxLotId;
  }


  public FundJournalEntryLine generalLedgerAccountCode(String generalLedgerAccountCode) {
    
    this.generalLedgerAccountCode = generalLedgerAccountCode;
    return this;
  }

   /**
   * The code of the account in the general ledger the Journal Entry was posted to.
   * @return generalLedgerAccountCode
  **/
  @jakarta.annotation.Nonnull
  public String getGeneralLedgerAccountCode() {
    return generalLedgerAccountCode;
  }


  public void setGeneralLedgerAccountCode(String generalLedgerAccountCode) {
    this.generalLedgerAccountCode = generalLedgerAccountCode;
  }


  public FundJournalEntryLine local(CurrencyAndAmount local) {
    
    this.local = local;
    return this;
  }

   /**
   * Get local
   * @return local
  **/
  @jakarta.annotation.Nonnull
  public CurrencyAndAmount getLocal() {
    return local;
  }


  public void setLocal(CurrencyAndAmount local) {
    this.local = local;
  }


  public FundJournalEntryLine base(CurrencyAndAmount base) {
    
    this.base = base;
    return this;
  }

   /**
   * Get base
   * @return base
  **/
  @jakarta.annotation.Nonnull
  public CurrencyAndAmount getBase() {
    return base;
  }


  public void setBase(CurrencyAndAmount base) {
    this.base = base;
  }


  public FundJournalEntryLine units(java.math.BigDecimal units) {
    
    this.units = units;
    return this;
  }

   /**
   * Units held for the Journal Entry Line.
   * @return units
  **/
  @jakarta.annotation.Nonnull
  public java.math.BigDecimal getUnits() {
    return units;
  }


  public void setUnits(java.math.BigDecimal units) {
    this.units = units;
  }


  public FundJournalEntryLine postingModuleCode(String postingModuleCode) {
    
    this.postingModuleCode = postingModuleCode;
    return this;
  }

   /**
   * The code of the posting module where the posting rules derived the Journal Entry lines.
   * @return postingModuleCode
  **/
  @jakarta.annotation.Nullable
  public String getPostingModuleCode() {
    return postingModuleCode;
  }


  public void setPostingModuleCode(String postingModuleCode) {
    this.postingModuleCode = postingModuleCode;
  }


  public FundJournalEntryLine postingRule(String postingRule) {
    
    this.postingRule = postingRule;
    return this;
  }

   /**
   * The rule generating the Journal Entry Line.
   * @return postingRule
  **/
  @jakarta.annotation.Nonnull
  public String getPostingRule() {
    return postingRule;
  }


  public void setPostingRule(String postingRule) {
    this.postingRule = postingRule;
  }


  public FundJournalEntryLine asAtDate(OffsetDateTime asAtDate) {
    
    this.asAtDate = asAtDate;
    return this;
  }

   /**
   * The corresponding input date and time of the Transaction generating the Journal Entry Line.
   * @return asAtDate
  **/
  @jakarta.annotation.Nonnull
  public OffsetDateTime getAsAtDate() {
    return asAtDate;
  }


  public void setAsAtDate(OffsetDateTime asAtDate) {
    this.asAtDate = asAtDate;
  }


  public FundJournalEntryLine activitiesDescription(String activitiesDescription) {
    
    this.activitiesDescription = activitiesDescription;
    return this;
  }

   /**
   * This would be the description of the business activities this Journal Entry Line is for.
   * @return activitiesDescription
  **/
  @jakarta.annotation.Nullable
  public String getActivitiesDescription() {
    return activitiesDescription;
  }


  public void setActivitiesDescription(String activitiesDescription) {
    this.activitiesDescription = activitiesDescription;
  }


  public FundJournalEntryLine sourceType(String sourceType) {
    
    this.sourceType = sourceType;
    return this;
  }

   /**
   * So far are 4 types: LusidTxn, LusidValuation, Manual and External.
   * @return sourceType
  **/
  @jakarta.annotation.Nonnull
  public String getSourceType() {
    return sourceType;
  }


  public void setSourceType(String sourceType) {
    this.sourceType = sourceType;
  }


  public FundJournalEntryLine sourceId(String sourceId) {
    
    this.sourceId = sourceId;
    return this;
  }

   /**
   * For the Lusid Source Type this will be the txn Id. For the rest will be what the user populates.
   * @return sourceId
  **/
  @jakarta.annotation.Nonnull
  public String getSourceId() {
    return sourceId;
  }


  public void setSourceId(String sourceId) {
    this.sourceId = sourceId;
  }


  public FundJournalEntryLine properties(Map<String, Property> properties) {
    
    this.properties = properties;
    return this;
  }

  public FundJournalEntryLine putPropertiesItem(String key, Property propertiesItem) {
    if (this.properties == null) {
      this.properties = new HashMap<>();
    }
    this.properties.put(key, propertiesItem);
    return this;
  }

   /**
   * A set of properties for the Abor.
   * @return properties
  **/
  @jakarta.annotation.Nullable
  public Map<String, Property> getProperties() {
    return properties;
  }


  public void setProperties(Map<String, Property> properties) {
    this.properties = properties;
  }


  public FundJournalEntryLine movementName(String movementName) {
    
    this.movementName = movementName;
    return this;
  }

   /**
   * If the JE Line is generated from a transaction, the name of the side in the transaction type&#39;s movement. If from a valuation, this is &#39;MarkToMarket&#39;.
   * @return movementName
  **/
  @jakarta.annotation.Nullable
  public String getMovementName() {
    return movementName;
  }


  public void setMovementName(String movementName) {
    this.movementName = movementName;
  }


  public FundJournalEntryLine holdingType(String holdingType) {
    
    this.holdingType = holdingType;
    return this;
  }

   /**
   * One of the LUSID holding types such as &#39;P&#39; for position or &#39;B&#39; for settled cash balance.
   * @return holdingType
  **/
  @jakarta.annotation.Nonnull
  public String getHoldingType() {
    return holdingType;
  }


  public void setHoldingType(String holdingType) {
    this.holdingType = holdingType;
  }


  public FundJournalEntryLine economicBucket(String economicBucket) {
    
    this.economicBucket = economicBucket;
    return this;
  }

   /**
   * LUSID automatically categorises a JE Line into a broad economic bucket such as &#39;NA_Cost&#39; or &#39;PL_RealPriceGL&#39;.
   * @return economicBucket
  **/
  @jakarta.annotation.Nonnull
  public String getEconomicBucket() {
    return economicBucket;
  }


  public void setEconomicBucket(String economicBucket) {
    this.economicBucket = economicBucket;
  }


  public FundJournalEntryLine economicBucketComponent(String economicBucketComponent) {
    
    this.economicBucketComponent = economicBucketComponent;
    return this;
  }

   /**
   * Sub bucket of the economic bucket.
   * @return economicBucketComponent
  **/
  @jakarta.annotation.Nullable
  public String getEconomicBucketComponent() {
    return economicBucketComponent;
  }


  public void setEconomicBucketComponent(String economicBucketComponent) {
    this.economicBucketComponent = economicBucketComponent;
  }


  public FundJournalEntryLine economicBucketVariant(String economicBucketVariant) {
    
    this.economicBucketVariant = economicBucketVariant;
    return this;
  }

   /**
   * Categorisation of a Mark-to-market journal entry line into LongTerm or ShortTerm based on whether the ActivityDate is more than a year after the purchase trade date or not.
   * @return economicBucketVariant
  **/
  @jakarta.annotation.Nullable
  public String getEconomicBucketVariant() {
    return economicBucketVariant;
  }


  public void setEconomicBucketVariant(String economicBucketVariant) {
    this.economicBucketVariant = economicBucketVariant;
  }


  public FundJournalEntryLine levels(List<String> levels) {
    
    this.levels = levels;
    return this;
  }

  public FundJournalEntryLine addLevelsItem(String levelsItem) {
    if (this.levels == null) {
      this.levels = new ArrayList<>();
    }
    this.levels.add(levelsItem);
    return this;
  }

   /**
   * Resolved data from the general ledger profile where the GeneralLedgerProfileCode is specified in the GetJournalEntryLines request body.
   * @return levels
  **/
  @jakarta.annotation.Nullable
  public List<String> getLevels() {
    return levels;
  }


  public void setLevels(List<String> levels) {
    this.levels = levels;
  }


  public FundJournalEntryLine sourceLevels(List<String> sourceLevels) {
    
    this.sourceLevels = sourceLevels;
    return this;
  }

  public FundJournalEntryLine addSourceLevelsItem(String sourceLevelsItem) {
    if (this.sourceLevels == null) {
      this.sourceLevels = new ArrayList<>();
    }
    this.sourceLevels.add(sourceLevelsItem);
    return this;
  }

   /**
   * Source data from the general ledger profile where the GeneralLedgerProfileCode is specified in the GetJournalEntryLines request body.
   * @return sourceLevels
  **/
  @jakarta.annotation.Nullable
  public List<String> getSourceLevels() {
    return sourceLevels;
  }


  public void setSourceLevels(List<String> sourceLevels) {
    this.sourceLevels = sourceLevels;
  }


  public FundJournalEntryLine movementSign(String movementSign) {
    
    this.movementSign = movementSign;
    return this;
  }

   /**
   * Indicates if the Journal Entry Line corresponds to a Long or Short movement.
   * @return movementSign
  **/
  @jakarta.annotation.Nullable
  public String getMovementSign() {
    return movementSign;
  }


  public void setMovementSign(String movementSign) {
    this.movementSign = movementSign;
  }


  public FundJournalEntryLine holdingSign(String holdingSign) {
    
    this.holdingSign = holdingSign;
    return this;
  }

   /**
   * Indicates if the Journal Entry Line is operating against a Long or Short holding.
   * @return holdingSign
  **/
  @jakarta.annotation.Nullable
  public String getHoldingSign() {
    return holdingSign;
  }


  public void setHoldingSign(String holdingSign) {
    this.holdingSign = holdingSign;
  }


  public FundJournalEntryLine ledgerColumn(String ledgerColumn) {
    
    this.ledgerColumn = ledgerColumn;
    return this;
  }

   /**
   * Indicates if the Journal Entry Line is credit or debit.
   * @return ledgerColumn
  **/
  @jakarta.annotation.Nullable
  public String getLedgerColumn() {
    return ledgerColumn;
  }


  public void setLedgerColumn(String ledgerColumn) {
    this.ledgerColumn = ledgerColumn;
  }


  public FundJournalEntryLine journalEntryLineType(String journalEntryLineType) {
    
    this.journalEntryLineType = journalEntryLineType;
    return this;
  }

   /**
   * Indicates the Journal Entry Line type
   * @return journalEntryLineType
  **/
  @jakarta.annotation.Nullable
  public String getJournalEntryLineType() {
    return journalEntryLineType;
  }


  public void setJournalEntryLineType(String journalEntryLineType) {
    this.journalEntryLineType = journalEntryLineType;
  }


  public FundJournalEntryLine shareClassBreakdowns(List<JournalEntryLineShareClassBreakdown> shareClassBreakdowns) {
    
    this.shareClassBreakdowns = shareClassBreakdowns;
    return this;
  }

  public FundJournalEntryLine addShareClassBreakdownsItem(JournalEntryLineShareClassBreakdown shareClassBreakdownsItem) {
    if (this.shareClassBreakdowns == null) {
      this.shareClassBreakdowns = new ArrayList<>();
    }
    this.shareClassBreakdowns.add(shareClassBreakdownsItem);
    return this;
  }

   /**
   * Share Class breakdown data for this Journal Entry Line.
   * @return shareClassBreakdowns
  **/
  @jakarta.annotation.Nullable
  public List<JournalEntryLineShareClassBreakdown> getShareClassBreakdowns() {
    return shareClassBreakdowns;
  }


  public void setShareClassBreakdowns(List<JournalEntryLineShareClassBreakdown> shareClassBreakdowns) {
    this.shareClassBreakdowns = shareClassBreakdowns;
  }


  public FundJournalEntryLine links(List<Link> links) {
    
    this.links = links;
    return this;
  }

  public FundJournalEntryLine addLinksItem(Link linksItem) {
    if (this.links == null) {
      this.links = new ArrayList<>();
    }
    this.links.add(linksItem);
    return this;
  }

   /**
   * Get links
   * @return links
  **/
  @jakarta.annotation.Nullable
  public List<Link> getLinks() {
    return links;
  }


  public void setLinks(List<Link> links) {
    this.links = links;
  }



  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    FundJournalEntryLine fundJournalEntryLine = (FundJournalEntryLine) o;
    return Objects.equals(this.accountingDate, fundJournalEntryLine.accountingDate) &&
        Objects.equals(this.activityDate, fundJournalEntryLine.activityDate) &&
        Objects.equals(this.portfolioId, fundJournalEntryLine.portfolioId) &&
        Objects.equals(this.instrumentId, fundJournalEntryLine.instrumentId) &&
        Objects.equals(this.instrumentScope, fundJournalEntryLine.instrumentScope) &&
        Objects.equals(this.subHoldingKeys, fundJournalEntryLine.subHoldingKeys) &&
        Objects.equals(this.taxLotId, fundJournalEntryLine.taxLotId) &&
        Objects.equals(this.generalLedgerAccountCode, fundJournalEntryLine.generalLedgerAccountCode) &&
        Objects.equals(this.local, fundJournalEntryLine.local) &&
        Objects.equals(this.base, fundJournalEntryLine.base) &&
        (this.units.compareTo(fundJournalEntryLine.getUnits()) == 0) &&
        Objects.equals(this.postingModuleCode, fundJournalEntryLine.postingModuleCode) &&
        Objects.equals(this.postingRule, fundJournalEntryLine.postingRule) &&
        Objects.equals(this.asAtDate, fundJournalEntryLine.asAtDate) &&
        Objects.equals(this.activitiesDescription, fundJournalEntryLine.activitiesDescription) &&
        Objects.equals(this.sourceType, fundJournalEntryLine.sourceType) &&
        Objects.equals(this.sourceId, fundJournalEntryLine.sourceId) &&
        Objects.equals(this.properties, fundJournalEntryLine.properties) &&
        Objects.equals(this.movementName, fundJournalEntryLine.movementName) &&
        Objects.equals(this.holdingType, fundJournalEntryLine.holdingType) &&
        Objects.equals(this.economicBucket, fundJournalEntryLine.economicBucket) &&
        Objects.equals(this.economicBucketComponent, fundJournalEntryLine.economicBucketComponent) &&
        Objects.equals(this.economicBucketVariant, fundJournalEntryLine.economicBucketVariant) &&
        Objects.equals(this.levels, fundJournalEntryLine.levels) &&
        Objects.equals(this.sourceLevels, fundJournalEntryLine.sourceLevels) &&
        Objects.equals(this.movementSign, fundJournalEntryLine.movementSign) &&
        Objects.equals(this.holdingSign, fundJournalEntryLine.holdingSign) &&
        Objects.equals(this.ledgerColumn, fundJournalEntryLine.ledgerColumn) &&
        Objects.equals(this.journalEntryLineType, fundJournalEntryLine.journalEntryLineType) &&
        Objects.equals(this.shareClassBreakdowns, fundJournalEntryLine.shareClassBreakdowns) &&
        Objects.equals(this.links, fundJournalEntryLine.links);
  }

  private static <T> boolean equalsNullable(JsonNullable<T> a, JsonNullable<T> b) {
    return a == b || (a != null && b != null && a.isPresent() && b.isPresent() && Objects.deepEquals(a.get(), b.get()));
  }

  @Override
  public int hashCode() {
    return Objects.hash(accountingDate, activityDate, portfolioId, instrumentId, instrumentScope, subHoldingKeys, taxLotId, generalLedgerAccountCode, local, base, units, postingModuleCode, postingRule, asAtDate, activitiesDescription, sourceType, sourceId, properties, movementName, holdingType, economicBucket, economicBucketComponent, economicBucketVariant, levels, sourceLevels, movementSign, holdingSign, ledgerColumn, journalEntryLineType, shareClassBreakdowns, links);
  }

  private static <T> int hashCodeNullable(JsonNullable<T> a) {
    if (a == null) {
      return 1;
    }
    return a.isPresent() ? Arrays.deepHashCode(new Object[]{a.get()}) : 31;
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class FundJournalEntryLine {\n");
    sb.append("    accountingDate: ").append(toIndentedString(accountingDate)).append("\n");
    sb.append("    activityDate: ").append(toIndentedString(activityDate)).append("\n");
    sb.append("    portfolioId: ").append(toIndentedString(portfolioId)).append("\n");
    sb.append("    instrumentId: ").append(toIndentedString(instrumentId)).append("\n");
    sb.append("    instrumentScope: ").append(toIndentedString(instrumentScope)).append("\n");
    sb.append("    subHoldingKeys: ").append(toIndentedString(subHoldingKeys)).append("\n");
    sb.append("    taxLotId: ").append(toIndentedString(taxLotId)).append("\n");
    sb.append("    generalLedgerAccountCode: ").append(toIndentedString(generalLedgerAccountCode)).append("\n");
    sb.append("    local: ").append(toIndentedString(local)).append("\n");
    sb.append("    base: ").append(toIndentedString(base)).append("\n");
    sb.append("    units: ").append(toIndentedString(units)).append("\n");
    sb.append("    postingModuleCode: ").append(toIndentedString(postingModuleCode)).append("\n");
    sb.append("    postingRule: ").append(toIndentedString(postingRule)).append("\n");
    sb.append("    asAtDate: ").append(toIndentedString(asAtDate)).append("\n");
    sb.append("    activitiesDescription: ").append(toIndentedString(activitiesDescription)).append("\n");
    sb.append("    sourceType: ").append(toIndentedString(sourceType)).append("\n");
    sb.append("    sourceId: ").append(toIndentedString(sourceId)).append("\n");
    sb.append("    properties: ").append(toIndentedString(properties)).append("\n");
    sb.append("    movementName: ").append(toIndentedString(movementName)).append("\n");
    sb.append("    holdingType: ").append(toIndentedString(holdingType)).append("\n");
    sb.append("    economicBucket: ").append(toIndentedString(economicBucket)).append("\n");
    sb.append("    economicBucketComponent: ").append(toIndentedString(economicBucketComponent)).append("\n");
    sb.append("    economicBucketVariant: ").append(toIndentedString(economicBucketVariant)).append("\n");
    sb.append("    levels: ").append(toIndentedString(levels)).append("\n");
    sb.append("    sourceLevels: ").append(toIndentedString(sourceLevels)).append("\n");
    sb.append("    movementSign: ").append(toIndentedString(movementSign)).append("\n");
    sb.append("    holdingSign: ").append(toIndentedString(holdingSign)).append("\n");
    sb.append("    ledgerColumn: ").append(toIndentedString(ledgerColumn)).append("\n");
    sb.append("    journalEntryLineType: ").append(toIndentedString(journalEntryLineType)).append("\n");
    sb.append("    shareClassBreakdowns: ").append(toIndentedString(shareClassBreakdowns)).append("\n");
    sb.append("    links: ").append(toIndentedString(links)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }


  public static HashSet<String> openapiFields;
  public static HashSet<String> openapiRequiredFields;

  static {
    // a set of all properties/fields (JSON key names)
    openapiFields = new HashSet<String>();
    openapiFields.add("accountingDate");
    openapiFields.add("activityDate");
    openapiFields.add("portfolioId");
    openapiFields.add("instrumentId");
    openapiFields.add("instrumentScope");
    openapiFields.add("subHoldingKeys");
    openapiFields.add("taxLotId");
    openapiFields.add("generalLedgerAccountCode");
    openapiFields.add("local");
    openapiFields.add("base");
    openapiFields.add("units");
    openapiFields.add("postingModuleCode");
    openapiFields.add("postingRule");
    openapiFields.add("asAtDate");
    openapiFields.add("activitiesDescription");
    openapiFields.add("sourceType");
    openapiFields.add("sourceId");
    openapiFields.add("properties");
    openapiFields.add("movementName");
    openapiFields.add("holdingType");
    openapiFields.add("economicBucket");
    openapiFields.add("economicBucketComponent");
    openapiFields.add("economicBucketVariant");
    openapiFields.add("levels");
    openapiFields.add("sourceLevels");
    openapiFields.add("movementSign");
    openapiFields.add("holdingSign");
    openapiFields.add("ledgerColumn");
    openapiFields.add("journalEntryLineType");
    openapiFields.add("shareClassBreakdowns");
    openapiFields.add("links");

    // a set of required properties/fields (JSON key names)
    openapiRequiredFields = new HashSet<String>();
    openapiRequiredFields.add("accountingDate");
    openapiRequiredFields.add("activityDate");
    openapiRequiredFields.add("portfolioId");
    openapiRequiredFields.add("instrumentId");
    openapiRequiredFields.add("instrumentScope");
    openapiRequiredFields.add("generalLedgerAccountCode");
    openapiRequiredFields.add("local");
    openapiRequiredFields.add("base");
    openapiRequiredFields.add("units");
    openapiRequiredFields.add("postingRule");
    openapiRequiredFields.add("asAtDate");
    openapiRequiredFields.add("sourceType");
    openapiRequiredFields.add("sourceId");
    openapiRequiredFields.add("holdingType");
    openapiRequiredFields.add("economicBucket");
  }

 /**
  * Validates the JSON Element and throws an exception if issues found
  *
  * @param jsonElement JSON Element
  * @throws IOException if the JSON Element is invalid with respect to FundJournalEntryLine
  */
  public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      if (jsonElement == null) {
        if (!FundJournalEntryLine.openapiRequiredFields.isEmpty()) { // has required fields but JSON element is null
          throw new IllegalArgumentException(String.format("The required field(s) %s in FundJournalEntryLine is not found in the empty JSON string", FundJournalEntryLine.openapiRequiredFields.toString()));
        }
      }

      // check to make sure all required properties/fields are present in the JSON string
      for (String requiredField : FundJournalEntryLine.openapiRequiredFields) {
        if (jsonElement.getAsJsonObject().get(requiredField) == null) {
          throw new IllegalArgumentException(String.format("The required field `%s` is not found in the JSON string: %s", requiredField, jsonElement.toString()));
        }
      }
        JsonObject jsonObj = jsonElement.getAsJsonObject();
      // validate the required field `portfolioId`
      ResourceId.validateJsonElement(jsonObj.get("portfolioId"));
      if (!jsonObj.get("instrumentId").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `instrumentId` to be a primitive type in the JSON string but got `%s`", jsonObj.get("instrumentId").toString()));
      }
      if (!jsonObj.get("instrumentScope").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `instrumentScope` to be a primitive type in the JSON string but got `%s`", jsonObj.get("instrumentScope").toString()));
      }
      if ((jsonObj.get("taxLotId") != null && !jsonObj.get("taxLotId").isJsonNull()) && !jsonObj.get("taxLotId").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `taxLotId` to be a primitive type in the JSON string but got `%s`", jsonObj.get("taxLotId").toString()));
      }
      if (!jsonObj.get("generalLedgerAccountCode").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `generalLedgerAccountCode` to be a primitive type in the JSON string but got `%s`", jsonObj.get("generalLedgerAccountCode").toString()));
      }
      // validate the required field `local`
      CurrencyAndAmount.validateJsonElement(jsonObj.get("local"));
      // validate the required field `base`
      CurrencyAndAmount.validateJsonElement(jsonObj.get("base"));
      if ((jsonObj.get("postingModuleCode") != null && !jsonObj.get("postingModuleCode").isJsonNull()) && !jsonObj.get("postingModuleCode").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `postingModuleCode` to be a primitive type in the JSON string but got `%s`", jsonObj.get("postingModuleCode").toString()));
      }
      if (!jsonObj.get("postingRule").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `postingRule` to be a primitive type in the JSON string but got `%s`", jsonObj.get("postingRule").toString()));
      }
      if ((jsonObj.get("activitiesDescription") != null && !jsonObj.get("activitiesDescription").isJsonNull()) && !jsonObj.get("activitiesDescription").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `activitiesDescription` to be a primitive type in the JSON string but got `%s`", jsonObj.get("activitiesDescription").toString()));
      }
      if (!jsonObj.get("sourceType").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `sourceType` to be a primitive type in the JSON string but got `%s`", jsonObj.get("sourceType").toString()));
      }
      if (!jsonObj.get("sourceId").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `sourceId` to be a primitive type in the JSON string but got `%s`", jsonObj.get("sourceId").toString()));
      }
      if ((jsonObj.get("movementName") != null && !jsonObj.get("movementName").isJsonNull()) && !jsonObj.get("movementName").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `movementName` to be a primitive type in the JSON string but got `%s`", jsonObj.get("movementName").toString()));
      }
      if (!jsonObj.get("holdingType").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `holdingType` to be a primitive type in the JSON string but got `%s`", jsonObj.get("holdingType").toString()));
      }
      if (!jsonObj.get("economicBucket").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `economicBucket` to be a primitive type in the JSON string but got `%s`", jsonObj.get("economicBucket").toString()));
      }
      if ((jsonObj.get("economicBucketComponent") != null && !jsonObj.get("economicBucketComponent").isJsonNull()) && !jsonObj.get("economicBucketComponent").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `economicBucketComponent` to be a primitive type in the JSON string but got `%s`", jsonObj.get("economicBucketComponent").toString()));
      }
      if ((jsonObj.get("economicBucketVariant") != null && !jsonObj.get("economicBucketVariant").isJsonNull()) && !jsonObj.get("economicBucketVariant").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `economicBucketVariant` to be a primitive type in the JSON string but got `%s`", jsonObj.get("economicBucketVariant").toString()));
      }
      // ensure the optional json data is an array if present
      if (jsonObj.get("levels") != null && !jsonObj.get("levels").isJsonNull() && !jsonObj.get("levels").isJsonArray()) {
        throw new IllegalArgumentException(String.format("Expected the field `levels` to be an array in the JSON string but got `%s`", jsonObj.get("levels").toString()));
      }
      // ensure the optional json data is an array if present
      if (jsonObj.get("sourceLevels") != null && !jsonObj.get("sourceLevels").isJsonNull() && !jsonObj.get("sourceLevels").isJsonArray()) {
        throw new IllegalArgumentException(String.format("Expected the field `sourceLevels` to be an array in the JSON string but got `%s`", jsonObj.get("sourceLevels").toString()));
      }
      if ((jsonObj.get("movementSign") != null && !jsonObj.get("movementSign").isJsonNull()) && !jsonObj.get("movementSign").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `movementSign` to be a primitive type in the JSON string but got `%s`", jsonObj.get("movementSign").toString()));
      }
      if ((jsonObj.get("holdingSign") != null && !jsonObj.get("holdingSign").isJsonNull()) && !jsonObj.get("holdingSign").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `holdingSign` to be a primitive type in the JSON string but got `%s`", jsonObj.get("holdingSign").toString()));
      }
      if ((jsonObj.get("ledgerColumn") != null && !jsonObj.get("ledgerColumn").isJsonNull()) && !jsonObj.get("ledgerColumn").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `ledgerColumn` to be a primitive type in the JSON string but got `%s`", jsonObj.get("ledgerColumn").toString()));
      }
      if ((jsonObj.get("journalEntryLineType") != null && !jsonObj.get("journalEntryLineType").isJsonNull()) && !jsonObj.get("journalEntryLineType").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `journalEntryLineType` to be a primitive type in the JSON string but got `%s`", jsonObj.get("journalEntryLineType").toString()));
      }
      if (jsonObj.get("shareClassBreakdowns") != null && !jsonObj.get("shareClassBreakdowns").isJsonNull()) {
        JsonArray jsonArrayshareClassBreakdowns = jsonObj.getAsJsonArray("shareClassBreakdowns");
        if (jsonArrayshareClassBreakdowns != null) {
          // ensure the json data is an array
          if (!jsonObj.get("shareClassBreakdowns").isJsonArray()) {
            throw new IllegalArgumentException(String.format("Expected the field `shareClassBreakdowns` to be an array in the JSON string but got `%s`", jsonObj.get("shareClassBreakdowns").toString()));
          }

          // validate the optional field `shareClassBreakdowns` (array)
          for (int i = 0; i < jsonArrayshareClassBreakdowns.size(); i++) {
            JournalEntryLineShareClassBreakdown.validateJsonElement(jsonArrayshareClassBreakdowns.get(i));
          };
        }
      }
      if (jsonObj.get("links") != null && !jsonObj.get("links").isJsonNull()) {
        JsonArray jsonArraylinks = jsonObj.getAsJsonArray("links");
        if (jsonArraylinks != null) {
          // ensure the json data is an array
          if (!jsonObj.get("links").isJsonArray()) {
            throw new IllegalArgumentException(String.format("Expected the field `links` to be an array in the JSON string but got `%s`", jsonObj.get("links").toString()));
          }

          // validate the optional field `links` (array)
          for (int i = 0; i < jsonArraylinks.size(); i++) {
            Link.validateJsonElement(jsonArraylinks.get(i));
          };
        }
      }
  }

  public static class CustomTypeAdapterFactory implements TypeAdapterFactory {
    @SuppressWarnings("unchecked")
    @Override
    public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {
       if (!FundJournalEntryLine.class.isAssignableFrom(type.getRawType())) {
         return null; // this class only serializes 'FundJournalEntryLine' and its subtypes
       }
       final TypeAdapter<JsonElement> elementAdapter = gson.getAdapter(JsonElement.class);
       final TypeAdapter<FundJournalEntryLine> thisAdapter
                        = gson.getDelegateAdapter(this, TypeToken.get(FundJournalEntryLine.class));

       return (TypeAdapter<T>) new TypeAdapter<FundJournalEntryLine>() {
           @Override
           public void write(JsonWriter out, FundJournalEntryLine value) throws IOException {
             JsonObject obj = thisAdapter.toJsonTree(value).getAsJsonObject();
             elementAdapter.write(out, obj);
           }

           @Override
           public FundJournalEntryLine read(JsonReader in) throws IOException {
             JsonElement jsonElement = elementAdapter.read(in);
             validateJsonElement(jsonElement);
             return thisAdapter.fromJsonTree(jsonElement);
           }

       }.nullSafe();
    }
  }

 /**
  * Create an instance of FundJournalEntryLine given an JSON string
  *
  * @param jsonString JSON string
  * @return An instance of FundJournalEntryLine
  * @throws IOException if the JSON string is invalid with respect to FundJournalEntryLine
  */
  public static FundJournalEntryLine fromJson(String jsonString) throws IOException {
    return JSON.getGson().fromJson(jsonString, FundJournalEntryLine.class);
  }

 /**
  * Convert an instance of FundJournalEntryLine to an JSON string
  *
  * @return JSON string
  */
  public String toJson() {
    return JSON.getGson().toJson(this);
  }
}
