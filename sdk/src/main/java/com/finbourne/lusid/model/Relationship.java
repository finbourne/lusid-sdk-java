/*
 * LUSID API
 *
 * Contact: info@finbourne.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

package com.finbourne.lusid.model;

import java.util.Objects;
import com.finbourne.lusid.model.RelatedEntity;
import com.finbourne.lusid.model.ResourceId;
import com.finbourne.lusid.model.Version;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;
import java.time.OffsetDateTime;
import java.util.Arrays;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonArray;
import com.google.gson.JsonDeserializationContext;
import com.google.gson.JsonDeserializer;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParseException;
import com.google.gson.TypeAdapterFactory;
import com.google.gson.reflect.TypeToken;
import com.google.gson.TypeAdapter;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;

import java.lang.reflect.Type;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Map.Entry;
import java.util.Set;

import com.finbourne.lusid.JSON;

/**
 * Representation of a Relationship between a requested entity with the stated entity as RelatedEntityId
 */
@jakarta.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen")
public class Relationship {
  public static final String SERIALIZED_NAME_VERSION = "version";
  @SerializedName(SERIALIZED_NAME_VERSION)
  private Version version;

  public static final String SERIALIZED_NAME_RELATIONSHIP_DEFINITION_ID = "relationshipDefinitionId";
  @SerializedName(SERIALIZED_NAME_RELATIONSHIP_DEFINITION_ID)
  private ResourceId relationshipDefinitionId;

  public static final String SERIALIZED_NAME_RELATED_ENTITY = "relatedEntity";
  @SerializedName(SERIALIZED_NAME_RELATED_ENTITY)
  private RelatedEntity relatedEntity;

  public static final String SERIALIZED_NAME_TRAVERSAL_DIRECTION = "traversalDirection";
  @SerializedName(SERIALIZED_NAME_TRAVERSAL_DIRECTION)
  private String traversalDirection;

  public static final String SERIALIZED_NAME_TRAVERSAL_DESCRIPTION = "traversalDescription";
  @SerializedName(SERIALIZED_NAME_TRAVERSAL_DESCRIPTION)
  private String traversalDescription;

  public static final String SERIALIZED_NAME_EFFECTIVE_FROM = "effectiveFrom";
  @SerializedName(SERIALIZED_NAME_EFFECTIVE_FROM)
  private OffsetDateTime effectiveFrom;

  public static final String SERIALIZED_NAME_EFFECTIVE_UNTIL = "effectiveUntil";
  @SerializedName(SERIALIZED_NAME_EFFECTIVE_UNTIL)
  private OffsetDateTime effectiveUntil;

  public Relationship() {
  }

  public Relationship version(Version version) {
    
    this.version = version;
    return this;
  }

   /**
   * Get version
   * @return version
  **/
  @jakarta.annotation.Nullable
  public Version getVersion() {
    return version;
  }


  public void setVersion(Version version) {
    this.version = version;
  }


  public Relationship relationshipDefinitionId(ResourceId relationshipDefinitionId) {
    
    this.relationshipDefinitionId = relationshipDefinitionId;
    return this;
  }

   /**
   * Get relationshipDefinitionId
   * @return relationshipDefinitionId
  **/
  @jakarta.annotation.Nonnull
  public ResourceId getRelationshipDefinitionId() {
    return relationshipDefinitionId;
  }


  public void setRelationshipDefinitionId(ResourceId relationshipDefinitionId) {
    this.relationshipDefinitionId = relationshipDefinitionId;
  }


  public Relationship relatedEntity(RelatedEntity relatedEntity) {
    
    this.relatedEntity = relatedEntity;
    return this;
  }

   /**
   * Get relatedEntity
   * @return relatedEntity
  **/
  @jakarta.annotation.Nonnull
  public RelatedEntity getRelatedEntity() {
    return relatedEntity;
  }


  public void setRelatedEntity(RelatedEntity relatedEntity) {
    this.relatedEntity = relatedEntity;
  }


  public Relationship traversalDirection(String traversalDirection) {
    
    this.traversalDirection = traversalDirection;
    return this;
  }

   /**
   * Direction of relationship between the requested entity and related entity. This can be &#39;In&#39; or &#39;Out&#39;. Read more about relationships traversal direction in LUSID Knowledge Base here https://support.lusid.com/knowledgebase/article/KA-01679.
   * @return traversalDirection
  **/
  @jakarta.annotation.Nonnull
  public String getTraversalDirection() {
    return traversalDirection;
  }


  public void setTraversalDirection(String traversalDirection) {
    this.traversalDirection = traversalDirection;
  }


  public Relationship traversalDescription(String traversalDescription) {
    
    this.traversalDescription = traversalDescription;
    return this;
  }

   /**
   * Description of the relationship based on relationship&#39;s traversal direction. If &#39;TraversalDirection&#39; is &#39;Out&#39;, this description would be &#39;OutwardDescription&#39; from the associated relationship definition. If &#39;TraversalDirection&#39; is &#39;In&#39;, this description would be &#39;InwardDescription&#39; from the associated relationship definition.
   * @return traversalDescription
  **/
  @jakarta.annotation.Nonnull
  public String getTraversalDescription() {
    return traversalDescription;
  }


  public void setTraversalDescription(String traversalDescription) {
    this.traversalDescription = traversalDescription;
  }


  public Relationship effectiveFrom(OffsetDateTime effectiveFrom) {
    
    this.effectiveFrom = effectiveFrom;
    return this;
  }

   /**
   * The effective datetime from which the relationship is valid.
   * @return effectiveFrom
  **/
  @jakarta.annotation.Nullable
  public OffsetDateTime getEffectiveFrom() {
    return effectiveFrom;
  }


  public void setEffectiveFrom(OffsetDateTime effectiveFrom) {
    this.effectiveFrom = effectiveFrom;
  }


  public Relationship effectiveUntil(OffsetDateTime effectiveUntil) {
    
    this.effectiveUntil = effectiveUntil;
    return this;
  }

   /**
   * The effective datetime until which the relationship is valid. If no future deletions are present or an effective until has not been set for the relationship, this will be indefinite and represented by the maximum date.
   * @return effectiveUntil
  **/
  @jakarta.annotation.Nullable
  public OffsetDateTime getEffectiveUntil() {
    return effectiveUntil;
  }


  public void setEffectiveUntil(OffsetDateTime effectiveUntil) {
    this.effectiveUntil = effectiveUntil;
  }



  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    Relationship relationship = (Relationship) o;
    return Objects.equals(this.version, relationship.version) &&
        Objects.equals(this.relationshipDefinitionId, relationship.relationshipDefinitionId) &&
        Objects.equals(this.relatedEntity, relationship.relatedEntity) &&
        Objects.equals(this.traversalDirection, relationship.traversalDirection) &&
        Objects.equals(this.traversalDescription, relationship.traversalDescription) &&
        Objects.equals(this.effectiveFrom, relationship.effectiveFrom) &&
        Objects.equals(this.effectiveUntil, relationship.effectiveUntil);
  }

  @Override
  public int hashCode() {
    return Objects.hash(version, relationshipDefinitionId, relatedEntity, traversalDirection, traversalDescription, effectiveFrom, effectiveUntil);
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class Relationship {\n");
    sb.append("    version: ").append(toIndentedString(version)).append("\n");
    sb.append("    relationshipDefinitionId: ").append(toIndentedString(relationshipDefinitionId)).append("\n");
    sb.append("    relatedEntity: ").append(toIndentedString(relatedEntity)).append("\n");
    sb.append("    traversalDirection: ").append(toIndentedString(traversalDirection)).append("\n");
    sb.append("    traversalDescription: ").append(toIndentedString(traversalDescription)).append("\n");
    sb.append("    effectiveFrom: ").append(toIndentedString(effectiveFrom)).append("\n");
    sb.append("    effectiveUntil: ").append(toIndentedString(effectiveUntil)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }


  public static HashSet<String> openapiFields;
  public static HashSet<String> openapiRequiredFields;

  static {
    // a set of all properties/fields (JSON key names)
    openapiFields = new HashSet<String>();
    openapiFields.add("version");
    openapiFields.add("relationshipDefinitionId");
    openapiFields.add("relatedEntity");
    openapiFields.add("traversalDirection");
    openapiFields.add("traversalDescription");
    openapiFields.add("effectiveFrom");
    openapiFields.add("effectiveUntil");

    // a set of required properties/fields (JSON key names)
    openapiRequiredFields = new HashSet<String>();
    openapiRequiredFields.add("relationshipDefinitionId");
    openapiRequiredFields.add("relatedEntity");
    openapiRequiredFields.add("traversalDirection");
    openapiRequiredFields.add("traversalDescription");
  }

 /**
  * Validates the JSON Element and throws an exception if issues found
  *
  * @param jsonElement JSON Element
  * @throws IOException if the JSON Element is invalid with respect to Relationship
  */
  public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      if (jsonElement == null) {
        if (!Relationship.openapiRequiredFields.isEmpty()) { // has required fields but JSON element is null
          throw new IllegalArgumentException(String.format("The required field(s) %s in Relationship is not found in the empty JSON string", Relationship.openapiRequiredFields.toString()));
        }
      }

      // check to make sure all required properties/fields are present in the JSON string
      for (String requiredField : Relationship.openapiRequiredFields) {
        if (jsonElement.getAsJsonObject().get(requiredField) == null) {
          throw new IllegalArgumentException(String.format("The required field `%s` is not found in the JSON string: %s", requiredField, jsonElement.toString()));
        }
      }
        JsonObject jsonObj = jsonElement.getAsJsonObject();
      // validate the optional field `version`
      if (jsonObj.get("version") != null && !jsonObj.get("version").isJsonNull()) {
        Version.validateJsonElement(jsonObj.get("version"));
      }
      // validate the required field `relationshipDefinitionId`
      ResourceId.validateJsonElement(jsonObj.get("relationshipDefinitionId"));
      // validate the required field `relatedEntity`
      RelatedEntity.validateJsonElement(jsonObj.get("relatedEntity"));
      if (!jsonObj.get("traversalDirection").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `traversalDirection` to be a primitive type in the JSON string but got `%s`", jsonObj.get("traversalDirection").toString()));
      }
      if (!jsonObj.get("traversalDescription").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `traversalDescription` to be a primitive type in the JSON string but got `%s`", jsonObj.get("traversalDescription").toString()));
      }
  }

  public static class CustomTypeAdapterFactory implements TypeAdapterFactory {
    @SuppressWarnings("unchecked")
    @Override
    public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {
       if (!Relationship.class.isAssignableFrom(type.getRawType())) {
         return null; // this class only serializes 'Relationship' and its subtypes
       }
       final TypeAdapter<JsonElement> elementAdapter = gson.getAdapter(JsonElement.class);
       final TypeAdapter<Relationship> thisAdapter
                        = gson.getDelegateAdapter(this, TypeToken.get(Relationship.class));

       return (TypeAdapter<T>) new TypeAdapter<Relationship>() {
           @Override
           public void write(JsonWriter out, Relationship value) throws IOException {
             JsonObject obj = thisAdapter.toJsonTree(value).getAsJsonObject();
             elementAdapter.write(out, obj);
           }

           @Override
           public Relationship read(JsonReader in) throws IOException {
             JsonElement jsonElement = elementAdapter.read(in);
             validateJsonElement(jsonElement);
             return thisAdapter.fromJsonTree(jsonElement);
           }

       }.nullSafe();
    }
  }

 /**
  * Create an instance of Relationship given an JSON string
  *
  * @param jsonString JSON string
  * @return An instance of Relationship
  * @throws IOException if the JSON string is invalid with respect to Relationship
  */
  public static Relationship fromJson(String jsonString) throws IOException {
    return JSON.getGson().fromJson(jsonString, Relationship.class);
  }

 /**
  * Convert an instance of Relationship to an JSON string
  *
  * @return JSON string
  */
  public String toJson() {
    return JSON.getGson().toJson(this);
  }
}
