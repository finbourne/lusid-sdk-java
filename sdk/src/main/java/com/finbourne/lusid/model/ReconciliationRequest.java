/*
 * LUSID API
 *
 * Contact: info@finbourne.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

package com.finbourne.lusid.model;

import java.util.Objects;
import com.finbourne.lusid.model.ReconciliationLeftRightAddressKeyPair;
import com.finbourne.lusid.model.ReconciliationRule;
import com.finbourne.lusid.model.ValuationRequest;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import org.openapitools.jackson.nullable.JsonNullable;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonArray;
import com.google.gson.JsonDeserializationContext;
import com.google.gson.JsonDeserializer;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParseException;
import com.google.gson.TypeAdapterFactory;
import com.google.gson.reflect.TypeToken;
import com.google.gson.TypeAdapter;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;

import java.lang.reflect.Type;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Map.Entry;
import java.util.Set;

import com.finbourne.lusid.JSON;

/**
 * Specification for the reconciliation request. Left and Right hand sides are constructed. Each consists of a valuation of a portfolio  using an aggregation request. The results of this can then be compared to each other. The difference, which is effectively a risk based  difference allows comparison of the effects of changing a recipe, valuation date, or (though it may or may not make logical sense) a portfolio.  For instance, one might look at the difference in risk caused by the addition of transaction to a portfolio, or through changing the valuation  methodology or system.
 */
@jakarta.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen")
public class ReconciliationRequest {
  public static final String SERIALIZED_NAME_LEFT = "left";
  @SerializedName(SERIALIZED_NAME_LEFT)
  private ValuationRequest left;

  public static final String SERIALIZED_NAME_RIGHT = "right";
  @SerializedName(SERIALIZED_NAME_RIGHT)
  private ValuationRequest right;

  public static final String SERIALIZED_NAME_LEFT_TO_RIGHT_MAPPING = "leftToRightMapping";
  @SerializedName(SERIALIZED_NAME_LEFT_TO_RIGHT_MAPPING)
  private List<ReconciliationLeftRightAddressKeyPair> leftToRightMapping;

  public static final String SERIALIZED_NAME_COMPARISON_RULES = "comparisonRules";
  @SerializedName(SERIALIZED_NAME_COMPARISON_RULES)
  private List<ReconciliationRule> comparisonRules;

  public static final String SERIALIZED_NAME_PRESERVE_KEYS = "preserveKeys";
  @SerializedName(SERIALIZED_NAME_PRESERVE_KEYS)
  private List<String> preserveKeys;

  public ReconciliationRequest() {
  }

  public ReconciliationRequest left(ValuationRequest left) {
    
    this.left = left;
    return this;
  }

   /**
   * Get left
   * @return left
  **/
  @jakarta.annotation.Nonnull
  public ValuationRequest getLeft() {
    return left;
  }


  public void setLeft(ValuationRequest left) {
    this.left = left;
  }


  public ReconciliationRequest right(ValuationRequest right) {
    
    this.right = right;
    return this;
  }

   /**
   * Get right
   * @return right
  **/
  @jakarta.annotation.Nonnull
  public ValuationRequest getRight() {
    return right;
  }


  public void setRight(ValuationRequest right) {
    this.right = right;
  }


  public ReconciliationRequest leftToRightMapping(List<ReconciliationLeftRightAddressKeyPair> leftToRightMapping) {
    
    this.leftToRightMapping = leftToRightMapping;
    return this;
  }

  public ReconciliationRequest addLeftToRightMappingItem(ReconciliationLeftRightAddressKeyPair leftToRightMappingItem) {
    if (this.leftToRightMapping == null) {
      this.leftToRightMapping = new ArrayList<>();
    }
    this.leftToRightMapping.add(leftToRightMappingItem);
    return this;
  }

   /**
   * The mapping from property keys requested by left aggregation to property keys on right hand side
   * @return leftToRightMapping
  **/
  @jakarta.annotation.Nullable
  public List<ReconciliationLeftRightAddressKeyPair> getLeftToRightMapping() {
    return leftToRightMapping;
  }


  public void setLeftToRightMapping(List<ReconciliationLeftRightAddressKeyPair> leftToRightMapping) {
    this.leftToRightMapping = leftToRightMapping;
  }


  public ReconciliationRequest comparisonRules(List<ReconciliationRule> comparisonRules) {
    
    this.comparisonRules = comparisonRules;
    return this;
  }

  public ReconciliationRequest addComparisonRulesItem(ReconciliationRule comparisonRulesItem) {
    if (this.comparisonRules == null) {
      this.comparisonRules = new ArrayList<>();
    }
    this.comparisonRules.add(comparisonRulesItem);
    return this;
  }

   /**
   * The set of rules to be used in comparing values. These are the rules that determine what constitutes a match.  The simplest is obviously an exact one-for-one comparison, but tolerances on numerical or date time values and  case-insensitive string comparison are supported amongst other types.
   * @return comparisonRules
  **/
  @jakarta.annotation.Nullable
  public List<ReconciliationRule> getComparisonRules() {
    return comparisonRules;
  }


  public void setComparisonRules(List<ReconciliationRule> comparisonRules) {
    this.comparisonRules = comparisonRules;
  }


  public ReconciliationRequest preserveKeys(List<String> preserveKeys) {
    
    this.preserveKeys = preserveKeys;
    return this;
  }

  public ReconciliationRequest addPreserveKeysItem(String preserveKeysItem) {
    if (this.preserveKeys == null) {
      this.preserveKeys = new ArrayList<>();
    }
    this.preserveKeys.add(preserveKeysItem);
    return this;
  }

   /**
   * List of keys to preserve (from rhs) in the diff. Used in conjunction with filtering/grouping.  If two values are equal, for a given key then the value is elided from the results. Setting it here  will preserve it (takes the values from the RHS and puts it into the line by line results).
   * @return preserveKeys
  **/
  @jakarta.annotation.Nullable
  public List<String> getPreserveKeys() {
    return preserveKeys;
  }


  public void setPreserveKeys(List<String> preserveKeys) {
    this.preserveKeys = preserveKeys;
  }



  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    ReconciliationRequest reconciliationRequest = (ReconciliationRequest) o;
    return Objects.equals(this.left, reconciliationRequest.left) &&
        Objects.equals(this.right, reconciliationRequest.right) &&
        Objects.equals(this.leftToRightMapping, reconciliationRequest.leftToRightMapping) &&
        Objects.equals(this.comparisonRules, reconciliationRequest.comparisonRules) &&
        Objects.equals(this.preserveKeys, reconciliationRequest.preserveKeys);
  }

  private static <T> boolean equalsNullable(JsonNullable<T> a, JsonNullable<T> b) {
    return a == b || (a != null && b != null && a.isPresent() && b.isPresent() && Objects.deepEquals(a.get(), b.get()));
  }

  @Override
  public int hashCode() {
    return Objects.hash(left, right, leftToRightMapping, comparisonRules, preserveKeys);
  }

  private static <T> int hashCodeNullable(JsonNullable<T> a) {
    if (a == null) {
      return 1;
    }
    return a.isPresent() ? Arrays.deepHashCode(new Object[]{a.get()}) : 31;
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class ReconciliationRequest {\n");
    sb.append("    left: ").append(toIndentedString(left)).append("\n");
    sb.append("    right: ").append(toIndentedString(right)).append("\n");
    sb.append("    leftToRightMapping: ").append(toIndentedString(leftToRightMapping)).append("\n");
    sb.append("    comparisonRules: ").append(toIndentedString(comparisonRules)).append("\n");
    sb.append("    preserveKeys: ").append(toIndentedString(preserveKeys)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }


  public static HashSet<String> openapiFields;
  public static HashSet<String> openapiRequiredFields;

  static {
    // a set of all properties/fields (JSON key names)
    openapiFields = new HashSet<String>();
    openapiFields.add("left");
    openapiFields.add("right");
    openapiFields.add("leftToRightMapping");
    openapiFields.add("comparisonRules");
    openapiFields.add("preserveKeys");

    // a set of required properties/fields (JSON key names)
    openapiRequiredFields = new HashSet<String>();
    openapiRequiredFields.add("left");
    openapiRequiredFields.add("right");
  }

 /**
  * Validates the JSON Element and throws an exception if issues found
  *
  * @param jsonElement JSON Element
  * @throws IOException if the JSON Element is invalid with respect to ReconciliationRequest
  */
  public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      if (jsonElement == null) {
        if (!ReconciliationRequest.openapiRequiredFields.isEmpty()) { // has required fields but JSON element is null
          throw new IllegalArgumentException(String.format("The required field(s) %s in ReconciliationRequest is not found in the empty JSON string", ReconciliationRequest.openapiRequiredFields.toString()));
        }
      }

      // check to make sure all required properties/fields are present in the JSON string
      for (String requiredField : ReconciliationRequest.openapiRequiredFields) {
        if (jsonElement.getAsJsonObject().get(requiredField) == null) {
          throw new IllegalArgumentException(String.format("The required field `%s` is not found in the JSON string: %s", requiredField, jsonElement.toString()));
        }
      }
        JsonObject jsonObj = jsonElement.getAsJsonObject();
      // validate the required field `left`
      ValuationRequest.validateJsonElement(jsonObj.get("left"));
      // validate the required field `right`
      ValuationRequest.validateJsonElement(jsonObj.get("right"));
      if (jsonObj.get("leftToRightMapping") != null && !jsonObj.get("leftToRightMapping").isJsonNull()) {
        JsonArray jsonArrayleftToRightMapping = jsonObj.getAsJsonArray("leftToRightMapping");
        if (jsonArrayleftToRightMapping != null) {
          // ensure the json data is an array
          if (!jsonObj.get("leftToRightMapping").isJsonArray()) {
            throw new IllegalArgumentException(String.format("Expected the field `leftToRightMapping` to be an array in the JSON string but got `%s`", jsonObj.get("leftToRightMapping").toString()));
          }

          // validate the optional field `leftToRightMapping` (array)
          for (int i = 0; i < jsonArrayleftToRightMapping.size(); i++) {
            ReconciliationLeftRightAddressKeyPair.validateJsonElement(jsonArrayleftToRightMapping.get(i));
          };
        }
      }
      if (jsonObj.get("comparisonRules") != null && !jsonObj.get("comparisonRules").isJsonNull()) {
        JsonArray jsonArraycomparisonRules = jsonObj.getAsJsonArray("comparisonRules");
        if (jsonArraycomparisonRules != null) {
          // ensure the json data is an array
          if (!jsonObj.get("comparisonRules").isJsonArray()) {
            throw new IllegalArgumentException(String.format("Expected the field `comparisonRules` to be an array in the JSON string but got `%s`", jsonObj.get("comparisonRules").toString()));
          }

          // validate the optional field `comparisonRules` (array)
          for (int i = 0; i < jsonArraycomparisonRules.size(); i++) {
            ReconciliationRule.validateJsonElement(jsonArraycomparisonRules.get(i));
          };
        }
      }
      // ensure the optional json data is an array if present
      if (jsonObj.get("preserveKeys") != null && !jsonObj.get("preserveKeys").isJsonNull() && !jsonObj.get("preserveKeys").isJsonArray()) {
        throw new IllegalArgumentException(String.format("Expected the field `preserveKeys` to be an array in the JSON string but got `%s`", jsonObj.get("preserveKeys").toString()));
      }
  }

  public static class CustomTypeAdapterFactory implements TypeAdapterFactory {
    @SuppressWarnings("unchecked")
    @Override
    public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {
       if (!ReconciliationRequest.class.isAssignableFrom(type.getRawType())) {
         return null; // this class only serializes 'ReconciliationRequest' and its subtypes
       }
       final TypeAdapter<JsonElement> elementAdapter = gson.getAdapter(JsonElement.class);
       final TypeAdapter<ReconciliationRequest> thisAdapter
                        = gson.getDelegateAdapter(this, TypeToken.get(ReconciliationRequest.class));

       return (TypeAdapter<T>) new TypeAdapter<ReconciliationRequest>() {
           @Override
           public void write(JsonWriter out, ReconciliationRequest value) throws IOException {
             JsonObject obj = thisAdapter.toJsonTree(value).getAsJsonObject();
             elementAdapter.write(out, obj);
           }

           @Override
           public ReconciliationRequest read(JsonReader in) throws IOException {
             JsonElement jsonElement = elementAdapter.read(in);
             validateJsonElement(jsonElement);
             return thisAdapter.fromJsonTree(jsonElement);
           }

       }.nullSafe();
    }
  }

 /**
  * Create an instance of ReconciliationRequest given an JSON string
  *
  * @param jsonString JSON string
  * @return An instance of ReconciliationRequest
  * @throws IOException if the JSON string is invalid with respect to ReconciliationRequest
  */
  public static ReconciliationRequest fromJson(String jsonString) throws IOException {
    return JSON.getGson().fromJson(jsonString, ReconciliationRequest.class);
  }

 /**
  * Convert an instance of ReconciliationRequest to an JSON string
  *
  * @return JSON string
  */
  public String toJson() {
    return JSON.getGson().toJson(this);
  }
}
