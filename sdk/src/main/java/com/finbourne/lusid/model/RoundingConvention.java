/*
 * LUSID API
 *
 * Contact: info@finbourne.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

package com.finbourne.lusid.model;

import java.util.Objects;
import java.util.Arrays;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;
import org.openapitools.jackson.nullable.JsonNullable;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonArray;
import com.google.gson.JsonDeserializationContext;
import com.google.gson.JsonDeserializer;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParseException;
import com.google.gson.TypeAdapterFactory;
import com.google.gson.reflect.TypeToken;
import com.google.gson.TypeAdapter;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;

import java.lang.reflect.Type;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Map.Entry;
import java.util.Set;

import com.finbourne.lusid.JSON;

/**
 * Certain bonds will follow certain rounding conventions.  For example, Thai government bonds will round accrued interest and cashflow values 2dp, whereas for  French government bonds, the rounding is to 7dp.
 */
@javax.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen")
public class RoundingConvention {
  public static final String SERIALIZED_NAME_FACE_VALUE = "faceValue";
  @SerializedName(SERIALIZED_NAME_FACE_VALUE)
  private java.math.BigDecimal faceValue;

  public static final String SERIALIZED_NAME_PRECISION = "precision";
  @SerializedName(SERIALIZED_NAME_PRECISION)
  private Integer precision;

  public static final String SERIALIZED_NAME_ROUNDING_TARGET = "roundingTarget";
  @SerializedName(SERIALIZED_NAME_ROUNDING_TARGET)
  private String roundingTarget;

  public static final String SERIALIZED_NAME_ROUNDING_TYPE = "roundingType";
  @SerializedName(SERIALIZED_NAME_ROUNDING_TYPE)
  private String roundingType;

  public RoundingConvention() {
  }

  public RoundingConvention faceValue(java.math.BigDecimal faceValue) {
    
    this.faceValue = faceValue;
    return this;
  }

   /**
   * The face value to round against.  The number to be rounded is scaled to this face value before being rounded, and then re-scaled to the holding amount.  For example if rounding an accrued interest value using a FaceValue of 1,000, but 10,000 units are held,  then the initial calculated value would be divided by 10,000, then multiplied by 1,000 and rounded per the convention.  The result of this would then be divided by 1,000 and multiplied by 10,000 to get the final value.
   * @return faceValue
  **/
  @javax.annotation.Nullable
  public java.math.BigDecimal getFaceValue() {
    return faceValue;
  }


  public void setFaceValue(java.math.BigDecimal faceValue) {
    this.faceValue = faceValue;
  }


  public RoundingConvention precision(Integer precision) {
    
    this.precision = precision;
    return this;
  }

   /**
   * The precision of the rounding.  The decimal places to which the rounding takes place.
   * @return precision
  **/
  @javax.annotation.Nullable
  public Integer getPrecision() {
    return precision;
  }


  public void setPrecision(Integer precision) {
    this.precision = precision;
  }


  public RoundingConvention roundingTarget(String roundingTarget) {
    
    this.roundingTarget = roundingTarget;
    return this;
  }

   /**
   * The target of the rounding convention.  Accepted values are &#39;AccruedInterest&#39;, &#39;Cashflows&#39;, or &#39;All&#39;    Supported string (enumeration) values are: [All, AccruedInterest, Cashflows].
   * @return roundingTarget
  **/
  @javax.annotation.Nullable
  public String getRoundingTarget() {
    return roundingTarget;
  }


  public void setRoundingTarget(String roundingTarget) {
    this.roundingTarget = roundingTarget;
  }


  public RoundingConvention roundingType(String roundingType) {
    
    this.roundingType = roundingType;
    return this;
  }

   /**
   * The type of rounding.  e.g. Round Up, Round Down    Supported string (enumeration) values are: [Down, Up, Floor, Ceiling, Nearest].
   * @return roundingType
  **/
  @javax.annotation.Nullable
  public String getRoundingType() {
    return roundingType;
  }


  public void setRoundingType(String roundingType) {
    this.roundingType = roundingType;
  }



  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    RoundingConvention roundingConvention = (RoundingConvention) o;
    return (this.faceValue.compareTo(roundingConvention.getFaceValue()) == 0) &&
        Objects.equals(this.precision, roundingConvention.precision) &&
        Objects.equals(this.roundingTarget, roundingConvention.roundingTarget) &&
        Objects.equals(this.roundingType, roundingConvention.roundingType);
  }

  private static <T> boolean equalsNullable(JsonNullable<T> a, JsonNullable<T> b) {
    return a == b || (a != null && b != null && a.isPresent() && b.isPresent() && Objects.deepEquals(a.get(), b.get()));
  }

  @Override
  public int hashCode() {
    return Objects.hash(faceValue, precision, roundingTarget, roundingType);
  }

  private static <T> int hashCodeNullable(JsonNullable<T> a) {
    if (a == null) {
      return 1;
    }
    return a.isPresent() ? Arrays.deepHashCode(new Object[]{a.get()}) : 31;
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class RoundingConvention {\n");
    sb.append("    faceValue: ").append(toIndentedString(faceValue)).append("\n");
    sb.append("    precision: ").append(toIndentedString(precision)).append("\n");
    sb.append("    roundingTarget: ").append(toIndentedString(roundingTarget)).append("\n");
    sb.append("    roundingType: ").append(toIndentedString(roundingType)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }


  public static HashSet<String> openapiFields;
  public static HashSet<String> openapiRequiredFields;

  static {
    // a set of all properties/fields (JSON key names)
    openapiFields = new HashSet<String>();
    openapiFields.add("faceValue");
    openapiFields.add("precision");
    openapiFields.add("roundingTarget");
    openapiFields.add("roundingType");

    // a set of required properties/fields (JSON key names)
    openapiRequiredFields = new HashSet<String>();
  }

 /**
  * Validates the JSON Object and throws an exception if issues found
  *
  * @param jsonObj JSON Object
  * @throws IOException if the JSON Object is invalid with respect to RoundingConvention
  */
  public static void validateJsonObject(JsonObject jsonObj) throws IOException {
      if (jsonObj == null) {
        if (!RoundingConvention.openapiRequiredFields.isEmpty()) { // has required fields but JSON object is null
          throw new IllegalArgumentException(String.format("The required field(s) %s in RoundingConvention is not found in the empty JSON string", RoundingConvention.openapiRequiredFields.toString()));
        }
      }

      Set<Entry<String, JsonElement>> entries = jsonObj.entrySet();
      // check to see if the JSON string contains additional fields
      for (Entry<String, JsonElement> entry : entries) {
        if (!RoundingConvention.openapiFields.contains(entry.getKey())) {
          throw new IllegalArgumentException(String.format("The field `%s` in the JSON string is not defined in the `RoundingConvention` properties. JSON: %s", entry.getKey(), jsonObj.toString()));
        }
      }
      if ((jsonObj.get("roundingTarget") != null && !jsonObj.get("roundingTarget").isJsonNull()) && !jsonObj.get("roundingTarget").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `roundingTarget` to be a primitive type in the JSON string but got `%s`", jsonObj.get("roundingTarget").toString()));
      }
      if ((jsonObj.get("roundingType") != null && !jsonObj.get("roundingType").isJsonNull()) && !jsonObj.get("roundingType").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `roundingType` to be a primitive type in the JSON string but got `%s`", jsonObj.get("roundingType").toString()));
      }
  }

  public static class CustomTypeAdapterFactory implements TypeAdapterFactory {
    @SuppressWarnings("unchecked")
    @Override
    public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {
       if (!RoundingConvention.class.isAssignableFrom(type.getRawType())) {
         return null; // this class only serializes 'RoundingConvention' and its subtypes
       }
       final TypeAdapter<JsonElement> elementAdapter = gson.getAdapter(JsonElement.class);
       final TypeAdapter<RoundingConvention> thisAdapter
                        = gson.getDelegateAdapter(this, TypeToken.get(RoundingConvention.class));

       return (TypeAdapter<T>) new TypeAdapter<RoundingConvention>() {
           @Override
           public void write(JsonWriter out, RoundingConvention value) throws IOException {
             JsonObject obj = thisAdapter.toJsonTree(value).getAsJsonObject();
             elementAdapter.write(out, obj);
           }

           @Override
           public RoundingConvention read(JsonReader in) throws IOException {
             JsonObject jsonObj = elementAdapter.read(in).getAsJsonObject();
             validateJsonObject(jsonObj);
             return thisAdapter.fromJsonTree(jsonObj);
           }

       }.nullSafe();
    }
  }

 /**
  * Create an instance of RoundingConvention given an JSON string
  *
  * @param jsonString JSON string
  * @return An instance of RoundingConvention
  * @throws IOException if the JSON string is invalid with respect to RoundingConvention
  */
  public static RoundingConvention fromJson(String jsonString) throws IOException {
    return JSON.getGson().fromJson(jsonString, RoundingConvention.class);
  }

 /**
  * Convert an instance of RoundingConvention to an JSON string
  *
  * @return JSON string
  */
  public String toJson() {
    return JSON.getGson().toJson(this);
  }
}
