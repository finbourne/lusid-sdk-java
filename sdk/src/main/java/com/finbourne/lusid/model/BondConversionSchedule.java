/*
 * LUSID API
 *
 * Contact: info@finbourne.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

package com.finbourne.lusid.model;

import java.util.Objects;
import com.finbourne.lusid.model.BondConversionEntry;
import com.finbourne.lusid.model.Schedule;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;
import java.time.OffsetDateTime;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import org.openapitools.jackson.nullable.JsonNullable;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonArray;
import com.google.gson.JsonDeserializationContext;
import com.google.gson.JsonDeserializer;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParseException;
import com.google.gson.TypeAdapterFactory;
import com.google.gson.reflect.TypeToken;
import com.google.gson.TypeAdapter;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;

import java.lang.reflect.Type;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Map.Entry;
import java.util.Set;

import com.finbourne.lusid.JSON;

/**
 * A BondConversionSchedule object represents a class containing the  information required for the creation of convertible features in a ComplexBond
 */
@jakarta.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen")
public class BondConversionSchedule extends Schedule {
  public static final String SERIALIZED_NAME_IDENTIFIERS = "identifiers";
  @SerializedName(SERIALIZED_NAME_IDENTIFIERS)
  private Map<String, String> identifiers;

  public static final String SERIALIZED_NAME_BOND_CONVERSION_ENTRIES = "bondConversionEntries";
  @SerializedName(SERIALIZED_NAME_BOND_CONVERSION_ENTRIES)
  private List<BondConversionEntry> bondConversionEntries;

  public static final String SERIALIZED_NAME_CONVERSION_TRIGGER = "conversionTrigger";
  @SerializedName(SERIALIZED_NAME_CONVERSION_TRIGGER)
  private String conversionTrigger;

  public static final String SERIALIZED_NAME_DELIVERY_TYPE = "deliveryType";
  @SerializedName(SERIALIZED_NAME_DELIVERY_TYPE)
  private String deliveryType;

  public static final String SERIALIZED_NAME_EXERCISE_TYPE = "exerciseType";
  @SerializedName(SERIALIZED_NAME_EXERCISE_TYPE)
  private String exerciseType;

  public static final String SERIALIZED_NAME_INCLUDES_ACCRUED = "includesAccrued";
  @SerializedName(SERIALIZED_NAME_INCLUDES_ACCRUED)
  private Boolean includesAccrued;

  public static final String SERIALIZED_NAME_MANDATORY_CONVERSION = "mandatoryConversion";
  @SerializedName(SERIALIZED_NAME_MANDATORY_CONVERSION)
  private Boolean mandatoryConversion;

  public static final String SERIALIZED_NAME_NOTIFICATION_PERIOD_END = "notificationPeriodEnd";
  @SerializedName(SERIALIZED_NAME_NOTIFICATION_PERIOD_END)
  private OffsetDateTime notificationPeriodEnd;

  public static final String SERIALIZED_NAME_NOTIFICATION_PERIOD_START = "notificationPeriodStart";
  @SerializedName(SERIALIZED_NAME_NOTIFICATION_PERIOD_START)
  private OffsetDateTime notificationPeriodStart;

  public BondConversionSchedule() {
    // this.scheduleType = this.getClass().getSimpleName();
  }

  public BondConversionSchedule identifiers(Map<String, String> identifiers) {
    
    this.identifiers = identifiers;
    return this;
  }

  public BondConversionSchedule putIdentifiersItem(String key, String identifiersItem) {
    if (this.identifiers == null) {
      this.identifiers = new HashMap<>();
    }
    this.identifiers.put(key, identifiersItem);
    return this;
  }

   /**
   * The market identifier(s) of the share that the bond converts to. The instrument  will not fail validation if no identifier is supplied.
   * @return identifiers
  **/
  @jakarta.annotation.Nullable
  public Map<String, String> getIdentifiers() {
    return identifiers;
  }


  public void setIdentifiers(Map<String, String> identifiers) {
    this.identifiers = identifiers;
  }


  public BondConversionSchedule bondConversionEntries(List<BondConversionEntry> bondConversionEntries) {
    
    this.bondConversionEntries = bondConversionEntries;
    return this;
  }

  public BondConversionSchedule addBondConversionEntriesItem(BondConversionEntry bondConversionEntriesItem) {
    if (this.bondConversionEntries == null) {
      this.bondConversionEntries = new ArrayList<>();
    }
    this.bondConversionEntries.add(bondConversionEntriesItem);
    return this;
  }

   /**
   * The dates at which the bond may be converted and associated information required about the conversion.
   * @return bondConversionEntries
  **/
  @jakarta.annotation.Nullable
  public List<BondConversionEntry> getBondConversionEntries() {
    return bondConversionEntries;
  }


  public void setBondConversionEntries(List<BondConversionEntry> bondConversionEntries) {
    this.bondConversionEntries = bondConversionEntries;
  }


  public BondConversionSchedule conversionTrigger(String conversionTrigger) {
    
    this.conversionTrigger = conversionTrigger;
    return this;
  }

   /**
   * Corporate event that triggers a conversion    Supported string (enumeration) values are: [NextEquityFinancing, IpoConversion, KnownDates, SoftCall].
   * @return conversionTrigger
  **/
  @jakarta.annotation.Nonnull
  public String getConversionTrigger() {
    return conversionTrigger;
  }


  public void setConversionTrigger(String conversionTrigger) {
    this.conversionTrigger = conversionTrigger;
  }


  public BondConversionSchedule deliveryType(String deliveryType) {
    
    this.deliveryType = deliveryType;
    return this;
  }

   /**
   * Is a conversion made into cash or into shares?    Supported string (enumeration) values are: [Cash, Physical].
   * @return deliveryType
  **/
  @jakarta.annotation.Nullable
  public String getDeliveryType() {
    return deliveryType;
  }


  public void setDeliveryType(String deliveryType) {
    this.deliveryType = deliveryType;
  }


  public BondConversionSchedule exerciseType(String exerciseType) {
    
    this.exerciseType = exerciseType;
    return this;
  }

   /**
   * The exercise type of the conversion schedule (American or European).  For American type, the bond is convertible from a given exercise date until the next date in the schedule, or until it matures.  For European type, the bond is only convertible on the given exercise date.    Supported string (enumeration) values are: [European, Bermudan, American].
   * @return exerciseType
  **/
  @jakarta.annotation.Nonnull
  public String getExerciseType() {
    return exerciseType;
  }


  public void setExerciseType(String exerciseType) {
    this.exerciseType = exerciseType;
  }


  public BondConversionSchedule includesAccrued(Boolean includesAccrued) {
    
    this.includesAccrued = includesAccrued;
    return this;
  }

   /**
   * Set this to true if a accrued interest is included in the conversion. Defaults to true.
   * @return includesAccrued
  **/
  @jakarta.annotation.Nullable
  public Boolean getIncludesAccrued() {
    return includesAccrued;
  }


  public void setIncludesAccrued(Boolean includesAccrued) {
    this.includesAccrued = includesAccrued;
  }


  public BondConversionSchedule mandatoryConversion(Boolean mandatoryConversion) {
    
    this.mandatoryConversion = mandatoryConversion;
    return this;
  }

   /**
   * Set this to true if a conversion is mandatory if the trigger occurs. Defaults to false.
   * @return mandatoryConversion
  **/
  @jakarta.annotation.Nullable
  public Boolean getMandatoryConversion() {
    return mandatoryConversion;
  }


  public void setMandatoryConversion(Boolean mandatoryConversion) {
    this.mandatoryConversion = mandatoryConversion;
  }


  public BondConversionSchedule notificationPeriodEnd(OffsetDateTime notificationPeriodEnd) {
    
    this.notificationPeriodEnd = notificationPeriodEnd;
    return this;
  }

   /**
   * The last day in the notification period for the conversion of the bond
   * @return notificationPeriodEnd
  **/
  @jakarta.annotation.Nullable
  public OffsetDateTime getNotificationPeriodEnd() {
    return notificationPeriodEnd;
  }


  public void setNotificationPeriodEnd(OffsetDateTime notificationPeriodEnd) {
    this.notificationPeriodEnd = notificationPeriodEnd;
  }


  public BondConversionSchedule notificationPeriodStart(OffsetDateTime notificationPeriodStart) {
    
    this.notificationPeriodStart = notificationPeriodStart;
    return this;
  }

   /**
   * The first day in the notification period for the conversion of the bond
   * @return notificationPeriodStart
  **/
  @jakarta.annotation.Nullable
  public OffsetDateTime getNotificationPeriodStart() {
    return notificationPeriodStart;
  }


  public void setNotificationPeriodStart(OffsetDateTime notificationPeriodStart) {
    this.notificationPeriodStart = notificationPeriodStart;
  }



  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    BondConversionSchedule bondConversionSchedule = (BondConversionSchedule) o;
    return Objects.equals(this.identifiers, bondConversionSchedule.identifiers) &&
        Objects.equals(this.bondConversionEntries, bondConversionSchedule.bondConversionEntries) &&
        Objects.equals(this.conversionTrigger, bondConversionSchedule.conversionTrigger) &&
        Objects.equals(this.deliveryType, bondConversionSchedule.deliveryType) &&
        Objects.equals(this.exerciseType, bondConversionSchedule.exerciseType) &&
        Objects.equals(this.includesAccrued, bondConversionSchedule.includesAccrued) &&
        Objects.equals(this.mandatoryConversion, bondConversionSchedule.mandatoryConversion) &&
        Objects.equals(this.notificationPeriodEnd, bondConversionSchedule.notificationPeriodEnd) &&
        Objects.equals(this.notificationPeriodStart, bondConversionSchedule.notificationPeriodStart) &&
        super.equals(o);
  }

  private static <T> boolean equalsNullable(JsonNullable<T> a, JsonNullable<T> b) {
    return a == b || (a != null && b != null && a.isPresent() && b.isPresent() && Objects.deepEquals(a.get(), b.get()));
  }

  @Override
  public int hashCode() {
    return Objects.hash(identifiers, bondConversionEntries, conversionTrigger, deliveryType, exerciseType, includesAccrued, mandatoryConversion, notificationPeriodEnd, notificationPeriodStart, super.hashCode());
  }

  private static <T> int hashCodeNullable(JsonNullable<T> a) {
    if (a == null) {
      return 1;
    }
    return a.isPresent() ? Arrays.deepHashCode(new Object[]{a.get()}) : 31;
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class BondConversionSchedule {\n");
    sb.append("    ").append(toIndentedString(super.toString())).append("\n");
    sb.append("    identifiers: ").append(toIndentedString(identifiers)).append("\n");
    sb.append("    bondConversionEntries: ").append(toIndentedString(bondConversionEntries)).append("\n");
    sb.append("    conversionTrigger: ").append(toIndentedString(conversionTrigger)).append("\n");
    sb.append("    deliveryType: ").append(toIndentedString(deliveryType)).append("\n");
    sb.append("    exerciseType: ").append(toIndentedString(exerciseType)).append("\n");
    sb.append("    includesAccrued: ").append(toIndentedString(includesAccrued)).append("\n");
    sb.append("    mandatoryConversion: ").append(toIndentedString(mandatoryConversion)).append("\n");
    sb.append("    notificationPeriodEnd: ").append(toIndentedString(notificationPeriodEnd)).append("\n");
    sb.append("    notificationPeriodStart: ").append(toIndentedString(notificationPeriodStart)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }


  public static HashSet<String> openapiFields;
  public static HashSet<String> openapiRequiredFields;

  static {
    // a set of all properties/fields (JSON key names)
    openapiFields = new HashSet<String>();
    openapiFields.add("scheduleType");
    openapiFields.add("identifiers");
    openapiFields.add("bondConversionEntries");
    openapiFields.add("conversionTrigger");
    openapiFields.add("deliveryType");
    openapiFields.add("exerciseType");
    openapiFields.add("includesAccrued");
    openapiFields.add("mandatoryConversion");
    openapiFields.add("notificationPeriodEnd");
    openapiFields.add("notificationPeriodStart");

    // a set of required properties/fields (JSON key names)
    openapiRequiredFields = new HashSet<String>();
    openapiRequiredFields.add("conversionTrigger");
    openapiRequiredFields.add("exerciseType");
    openapiRequiredFields.add("scheduleType");
  }

 /**
  * Validates the JSON Element and throws an exception if issues found
  *
  * @param jsonElement JSON Element
  * @throws IOException if the JSON Element is invalid with respect to BondConversionSchedule
  */
  public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      if (jsonElement == null) {
        if (!BondConversionSchedule.openapiRequiredFields.isEmpty()) { // has required fields but JSON element is null
          throw new IllegalArgumentException(String.format("The required field(s) %s in BondConversionSchedule is not found in the empty JSON string", BondConversionSchedule.openapiRequiredFields.toString()));
        }
      }

      // check to make sure all required properties/fields are present in the JSON string
      for (String requiredField : BondConversionSchedule.openapiRequiredFields) {
        if (jsonElement.getAsJsonObject().get(requiredField) == null) {
          throw new IllegalArgumentException(String.format("The required field `%s` is not found in the JSON string: %s", requiredField, jsonElement.toString()));
        }
      }
  }

  public static class CustomTypeAdapterFactory implements TypeAdapterFactory {
    @SuppressWarnings("unchecked")
    @Override
    public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {
       if (!BondConversionSchedule.class.isAssignableFrom(type.getRawType())) {
         return null; // this class only serializes 'BondConversionSchedule' and its subtypes
       }
       final TypeAdapter<JsonElement> elementAdapter = gson.getAdapter(JsonElement.class);
       final TypeAdapter<BondConversionSchedule> thisAdapter
                        = gson.getDelegateAdapter(this, TypeToken.get(BondConversionSchedule.class));

       return (TypeAdapter<T>) new TypeAdapter<BondConversionSchedule>() {
           @Override
           public void write(JsonWriter out, BondConversionSchedule value) throws IOException {
             JsonObject obj = thisAdapter.toJsonTree(value).getAsJsonObject();
             elementAdapter.write(out, obj);
           }

           @Override
           public BondConversionSchedule read(JsonReader in) throws IOException {
             JsonElement jsonElement = elementAdapter.read(in);
             validateJsonElement(jsonElement);
             return thisAdapter.fromJsonTree(jsonElement);
           }

       }.nullSafe();
    }
  }

 /**
  * Create an instance of BondConversionSchedule given an JSON string
  *
  * @param jsonString JSON string
  * @return An instance of BondConversionSchedule
  * @throws IOException if the JSON string is invalid with respect to BondConversionSchedule
  */
  public static BondConversionSchedule fromJson(String jsonString) throws IOException {
    return JSON.getGson().fromJson(jsonString, BondConversionSchedule.class);
  }

 /**
  * Convert an instance of BondConversionSchedule to an JSON string
  *
  * @return JSON string
  */
  public String toJson() {
    return JSON.getGson().toJson(this);
  }
}
