/*
 * LUSID API
 *
 * Contact: info@finbourne.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

package com.finbourne.lusid.model;

import java.util.Objects;
import com.finbourne.lusid.model.FlowConventions;
import com.finbourne.lusid.model.LusidInstrument;
import com.finbourne.lusid.model.TimeZoneConventions;
import com.finbourne.lusid.model.TradingConventions;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;
import java.time.OffsetDateTime;
import java.util.Arrays;
import org.openapitools.jackson.nullable.JsonNullable;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonArray;
import com.google.gson.JsonDeserializationContext;
import com.google.gson.JsonDeserializer;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParseException;
import com.google.gson.TypeAdapterFactory;
import com.google.gson.reflect.TypeToken;
import com.google.gson.TypeAdapter;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;

import java.lang.reflect.Type;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Map.Entry;
import java.util.Set;

import com.finbourne.lusid.JSON;

/**
 * LUSID representation of a Term Deposit.
 */
@jakarta.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen")
public class TermDeposit extends LusidInstrument {
  public static final String SERIALIZED_NAME_START_DATE = "startDate";
  @SerializedName(SERIALIZED_NAME_START_DATE)
  private OffsetDateTime startDate;

  public static final String SERIALIZED_NAME_MATURITY_DATE = "maturityDate";
  @SerializedName(SERIALIZED_NAME_MATURITY_DATE)
  private OffsetDateTime maturityDate;

  public static final String SERIALIZED_NAME_CONTRACT_SIZE = "contractSize";
  @SerializedName(SERIALIZED_NAME_CONTRACT_SIZE)
  private java.math.BigDecimal contractSize;

  public static final String SERIALIZED_NAME_FLOW_CONVENTION = "flowConvention";
  @SerializedName(SERIALIZED_NAME_FLOW_CONVENTION)
  private FlowConventions flowConvention;

  public static final String SERIALIZED_NAME_RATE = "rate";
  @SerializedName(SERIALIZED_NAME_RATE)
  private java.math.BigDecimal rate;

  public static final String SERIALIZED_NAME_DOM_CCY = "domCcy";
  @SerializedName(SERIALIZED_NAME_DOM_CCY)
  private String domCcy;

  public static final String SERIALIZED_NAME_TRADING_CONVENTIONS = "tradingConventions";
  @SerializedName(SERIALIZED_NAME_TRADING_CONVENTIONS)
  private TradingConventions tradingConventions;

  public static final String SERIALIZED_NAME_TIME_ZONE_CONVENTIONS = "timeZoneConventions";
  @SerializedName(SERIALIZED_NAME_TIME_ZONE_CONVENTIONS)
  private TimeZoneConventions timeZoneConventions;

  public TermDeposit() {
    // this.instrumentType = this.getClass().getSimpleName();
  }

  public TermDeposit startDate(OffsetDateTime startDate) {
    
    this.startDate = startDate;
    return this;
  }

   /**
   * The start date of the instrument. For term deposits this is the start date of the interest calculation period.
   * @return startDate
  **/
  @jakarta.annotation.Nonnull
  public OffsetDateTime getStartDate() {
    return startDate;
  }


  public void setStartDate(OffsetDateTime startDate) {
    this.startDate = startDate;
  }


  public TermDeposit maturityDate(OffsetDateTime maturityDate) {
    
    this.maturityDate = maturityDate;
    return this;
  }

   /**
   * The maturity date of the instrument. For term deposits this is the last date of the interest calculation period.
   * @return maturityDate
  **/
  @jakarta.annotation.Nonnull
  public OffsetDateTime getMaturityDate() {
    return maturityDate;
  }


  public void setMaturityDate(OffsetDateTime maturityDate) {
    this.maturityDate = maturityDate;
  }


  public TermDeposit contractSize(java.math.BigDecimal contractSize) {
    
    this.contractSize = contractSize;
    return this;
  }

   /**
   * The principal amount of the term deposit.
   * @return contractSize
  **/
  @jakarta.annotation.Nonnull
  public java.math.BigDecimal getContractSize() {
    return contractSize;
  }


  public void setContractSize(java.math.BigDecimal contractSize) {
    this.contractSize = contractSize;
  }


  public TermDeposit flowConvention(FlowConventions flowConvention) {
    
    this.flowConvention = flowConvention;
    return this;
  }

   /**
   * Get flowConvention
   * @return flowConvention
  **/
  @jakarta.annotation.Nonnull
  public FlowConventions getFlowConvention() {
    return flowConvention;
  }


  public void setFlowConvention(FlowConventions flowConvention) {
    this.flowConvention = flowConvention;
  }


  public TermDeposit rate(java.math.BigDecimal rate) {
    
    this.rate = rate;
    return this;
  }

   /**
   * The fixed rate for the term deposit. Specified as a decimal, e.g 0.03 is meant to be 3% interest
   * @return rate
  **/
  @jakarta.annotation.Nonnull
  public java.math.BigDecimal getRate() {
    return rate;
  }


  public void setRate(java.math.BigDecimal rate) {
    this.rate = rate;
  }


  public TermDeposit domCcy(String domCcy) {
    
    this.domCcy = domCcy;
    return this;
  }

   /**
   * The domestic currency of the instrument. This should be the same as the Currency set on the FlowConventions.  You do not need to populate this field for Term Deposits in LUSID as all functionality is driven by the Currency set on the FlowConventions.  LUSID will not store values saved on this field.
   * @return domCcy
  **/
  @jakarta.annotation.Nullable
  public String getDomCcy() {
    return domCcy;
  }


  public void setDomCcy(String domCcy) {
    this.domCcy = domCcy;
  }


  public TermDeposit tradingConventions(TradingConventions tradingConventions) {
    
    this.tradingConventions = tradingConventions;
    return this;
  }

   /**
   * Get tradingConventions
   * @return tradingConventions
  **/
  @jakarta.annotation.Nullable
  public TradingConventions getTradingConventions() {
    return tradingConventions;
  }


  public void setTradingConventions(TradingConventions tradingConventions) {
    this.tradingConventions = tradingConventions;
  }


  public TermDeposit timeZoneConventions(TimeZoneConventions timeZoneConventions) {
    
    this.timeZoneConventions = timeZoneConventions;
    return this;
  }

   /**
   * Get timeZoneConventions
   * @return timeZoneConventions
  **/
  @jakarta.annotation.Nullable
  public TimeZoneConventions getTimeZoneConventions() {
    return timeZoneConventions;
  }


  public void setTimeZoneConventions(TimeZoneConventions timeZoneConventions) {
    this.timeZoneConventions = timeZoneConventions;
  }



  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    TermDeposit termDeposit = (TermDeposit) o;
    return Objects.equals(this.startDate, termDeposit.startDate) &&
        Objects.equals(this.maturityDate, termDeposit.maturityDate) &&
        (this.contractSize.compareTo(termDeposit.getContractSize()) == 0) &&
        Objects.equals(this.flowConvention, termDeposit.flowConvention) &&
        (this.rate.compareTo(termDeposit.getRate()) == 0) &&
        Objects.equals(this.domCcy, termDeposit.domCcy) &&
        Objects.equals(this.tradingConventions, termDeposit.tradingConventions) &&
        Objects.equals(this.timeZoneConventions, termDeposit.timeZoneConventions) &&
        super.equals(o);
  }

  private static <T> boolean equalsNullable(JsonNullable<T> a, JsonNullable<T> b) {
    return a == b || (a != null && b != null && a.isPresent() && b.isPresent() && Objects.deepEquals(a.get(), b.get()));
  }

  @Override
  public int hashCode() {
    return Objects.hash(startDate, maturityDate, contractSize, flowConvention, rate, domCcy, tradingConventions, timeZoneConventions, super.hashCode());
  }

  private static <T> int hashCodeNullable(JsonNullable<T> a) {
    if (a == null) {
      return 1;
    }
    return a.isPresent() ? Arrays.deepHashCode(new Object[]{a.get()}) : 31;
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class TermDeposit {\n");
    sb.append("    ").append(toIndentedString(super.toString())).append("\n");
    sb.append("    startDate: ").append(toIndentedString(startDate)).append("\n");
    sb.append("    maturityDate: ").append(toIndentedString(maturityDate)).append("\n");
    sb.append("    contractSize: ").append(toIndentedString(contractSize)).append("\n");
    sb.append("    flowConvention: ").append(toIndentedString(flowConvention)).append("\n");
    sb.append("    rate: ").append(toIndentedString(rate)).append("\n");
    sb.append("    domCcy: ").append(toIndentedString(domCcy)).append("\n");
    sb.append("    tradingConventions: ").append(toIndentedString(tradingConventions)).append("\n");
    sb.append("    timeZoneConventions: ").append(toIndentedString(timeZoneConventions)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }


  public static HashSet<String> openapiFields;
  public static HashSet<String> openapiRequiredFields;

  static {
    // a set of all properties/fields (JSON key names)
    openapiFields = new HashSet<String>();
    openapiFields.add("instrumentType");
    openapiFields.add("startDate");
    openapiFields.add("maturityDate");
    openapiFields.add("contractSize");
    openapiFields.add("flowConvention");
    openapiFields.add("rate");
    openapiFields.add("domCcy");
    openapiFields.add("tradingConventions");
    openapiFields.add("timeZoneConventions");

    // a set of required properties/fields (JSON key names)
    openapiRequiredFields = new HashSet<String>();
    openapiRequiredFields.add("startDate");
    openapiRequiredFields.add("maturityDate");
    openapiRequiredFields.add("contractSize");
    openapiRequiredFields.add("flowConvention");
    openapiRequiredFields.add("rate");
    openapiRequiredFields.add("instrumentType");
  }

 /**
  * Validates the JSON Element and throws an exception if issues found
  *
  * @param jsonElement JSON Element
  * @throws IOException if the JSON Element is invalid with respect to TermDeposit
  */
  public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      if (jsonElement == null) {
        if (!TermDeposit.openapiRequiredFields.isEmpty()) { // has required fields but JSON element is null
          throw new IllegalArgumentException(String.format("The required field(s) %s in TermDeposit is not found in the empty JSON string", TermDeposit.openapiRequiredFields.toString()));
        }
      }

      // check to make sure all required properties/fields are present in the JSON string
      for (String requiredField : TermDeposit.openapiRequiredFields) {
        if (jsonElement.getAsJsonObject().get(requiredField) == null) {
          throw new IllegalArgumentException(String.format("The required field `%s` is not found in the JSON string: %s", requiredField, jsonElement.toString()));
        }
      }
  }

  public static class CustomTypeAdapterFactory implements TypeAdapterFactory {
    @SuppressWarnings("unchecked")
    @Override
    public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {
       if (!TermDeposit.class.isAssignableFrom(type.getRawType())) {
         return null; // this class only serializes 'TermDeposit' and its subtypes
       }
       final TypeAdapter<JsonElement> elementAdapter = gson.getAdapter(JsonElement.class);
       final TypeAdapter<TermDeposit> thisAdapter
                        = gson.getDelegateAdapter(this, TypeToken.get(TermDeposit.class));

       return (TypeAdapter<T>) new TypeAdapter<TermDeposit>() {
           @Override
           public void write(JsonWriter out, TermDeposit value) throws IOException {
             JsonObject obj = thisAdapter.toJsonTree(value).getAsJsonObject();
             elementAdapter.write(out, obj);
           }

           @Override
           public TermDeposit read(JsonReader in) throws IOException {
             JsonElement jsonElement = elementAdapter.read(in);
             validateJsonElement(jsonElement);
             return thisAdapter.fromJsonTree(jsonElement);
           }

       }.nullSafe();
    }
  }

 /**
  * Create an instance of TermDeposit given an JSON string
  *
  * @param jsonString JSON string
  * @return An instance of TermDeposit
  * @throws IOException if the JSON string is invalid with respect to TermDeposit
  */
  public static TermDeposit fromJson(String jsonString) throws IOException {
    return JSON.getGson().fromJson(jsonString, TermDeposit.class);
  }

 /**
  * Convert an instance of TermDeposit to an JSON string
  *
  * @return JSON string
  */
  public String toJson() {
    return JSON.getGson().toJson(this);
  }
}
