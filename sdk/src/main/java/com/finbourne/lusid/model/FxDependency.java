/*
 * LUSID API
 *
 * Contact: info@finbourne.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

package com.finbourne.lusid.model;

import java.util.Objects;
import java.util.Arrays;
import com.finbourne.lusid.model.EconomicDependency;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;
import java.time.OffsetDateTime;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonArray;
import com.google.gson.JsonDeserializationContext;
import com.google.gson.JsonDeserializer;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParseException;
import com.google.gson.TypeAdapterFactory;
import com.google.gson.reflect.TypeToken;
import com.google.gson.TypeAdapter;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;

import java.lang.reflect.Type;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Map.Entry;
import java.util.Set;

import com.finbourne.lusid.JSON;

/**
 * For indicating a dependency on an fx rate.  For example domestic-foreign for USD-JPY  means that 1 unit (dollar) of domestic currency will buy you \&quot;X\&quot; units of foreign (Yen) currency; currently somewhere around 100.  This is equivalently denoted as USDJPY and USD/JPY                On the assumption that you wish to convert an amount in the domestic currency to the foreign, you would want the (dom,fgn) dependency; domfgn currency pair.  On the assumption that you wish to convert an amount in the foreign currency to the domestic, you would want the (fgn,dom) dependency; fgndom currency pair.                NB: There alternate descriptions for currency pairs that seem to vary between different banks and sectors of the industry, e.g. base and contract                In pricing we are taking the convention that we will convert from FGN to DOM by DIVIDING through by the DOMFGN spot rate.
 */
@javax.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen")
public class FxDependency extends EconomicDependency {
  public static final String SERIALIZED_NAME_DOMESTIC_CURRENCY = "domesticCurrency";
  @SerializedName(SERIALIZED_NAME_DOMESTIC_CURRENCY)
  private String domesticCurrency;

  public static final String SERIALIZED_NAME_FOREIGN_CURRENCY = "foreignCurrency";
  @SerializedName(SERIALIZED_NAME_FOREIGN_CURRENCY)
  private String foreignCurrency;

  public static final String SERIALIZED_NAME_DATE = "date";
  @SerializedName(SERIALIZED_NAME_DATE)
  private OffsetDateTime date;

  public FxDependency() {
    // this.dependencyType = this.getClass().getSimpleName();
  }

  public FxDependency domesticCurrency(String domesticCurrency) {
    
    this.domesticCurrency = domesticCurrency;
    return this;
  }

   /**
   * DomesticCurrency is the first currency in a currency pair quote e.g. eur-gbp, eur is the domestic currency.
   * @return domesticCurrency
  **/
  @javax.annotation.Nonnull
  public String getDomesticCurrency() {
    return domesticCurrency;
  }


  public void setDomesticCurrency(String domesticCurrency) {
    this.domesticCurrency = domesticCurrency;
  }


  public FxDependency foreignCurrency(String foreignCurrency) {
    
    this.foreignCurrency = foreignCurrency;
    return this;
  }

   /**
   * ForeignCurrency is the second currency in a currency pair quote e.g. eur-gbp, gbp is the foreign currency.
   * @return foreignCurrency
  **/
  @javax.annotation.Nonnull
  public String getForeignCurrency() {
    return foreignCurrency;
  }


  public void setForeignCurrency(String foreignCurrency) {
    this.foreignCurrency = foreignCurrency;
  }


  public FxDependency date(OffsetDateTime date) {
    
    this.date = date;
    return this;
  }

   /**
   * The effectiveAt of the fx rate.
   * @return date
  **/
  @javax.annotation.Nonnull
  public OffsetDateTime getDate() {
    return date;
  }


  public void setDate(OffsetDateTime date) {
    this.date = date;
  }



  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    FxDependency fxDependency = (FxDependency) o;
    return Objects.equals(this.domesticCurrency, fxDependency.domesticCurrency) &&
        Objects.equals(this.foreignCurrency, fxDependency.foreignCurrency) &&
        Objects.equals(this.date, fxDependency.date) &&
        super.equals(o);
  }

  @Override
  public int hashCode() {
    return Objects.hash(domesticCurrency, foreignCurrency, date, super.hashCode());
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class FxDependency {\n");
    sb.append("    ").append(toIndentedString(super.toString())).append("\n");
    sb.append("    domesticCurrency: ").append(toIndentedString(domesticCurrency)).append("\n");
    sb.append("    foreignCurrency: ").append(toIndentedString(foreignCurrency)).append("\n");
    sb.append("    date: ").append(toIndentedString(date)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }


  public static HashSet<String> openapiFields;
  public static HashSet<String> openapiRequiredFields;

  static {
    // a set of all properties/fields (JSON key names)
    openapiFields = new HashSet<String>();
    openapiFields.add("dependencyType");
    openapiFields.add("domesticCurrency");
    openapiFields.add("foreignCurrency");
    openapiFields.add("date");

    // a set of required properties/fields (JSON key names)
    openapiRequiredFields = new HashSet<String>();
    openapiRequiredFields.add("domesticCurrency");
    openapiRequiredFields.add("foreignCurrency");
    openapiRequiredFields.add("date");
    openapiRequiredFields.add("dependencyType");
  }

 /**
  * Validates the JSON Object and throws an exception if issues found
  *
  * @param jsonObj JSON Object
  * @throws IOException if the JSON Object is invalid with respect to FxDependency
  */
  public static void validateJsonObject(JsonObject jsonObj) throws IOException {
      if (jsonObj == null) {
        if (!FxDependency.openapiRequiredFields.isEmpty()) { // has required fields but JSON object is null
          throw new IllegalArgumentException(String.format("The required field(s) %s in FxDependency is not found in the empty JSON string", FxDependency.openapiRequiredFields.toString()));
        }
      }

      Set<Entry<String, JsonElement>> entries = jsonObj.entrySet();
      // check to see if the JSON string contains additional fields
      for (Entry<String, JsonElement> entry : entries) {
        if (!FxDependency.openapiFields.contains(entry.getKey())) {
          throw new IllegalArgumentException(String.format("The field `%s` in the JSON string is not defined in the `FxDependency` properties. JSON: %s", entry.getKey(), jsonObj.toString()));
        }
      }

      // check to make sure all required properties/fields are present in the JSON string
      for (String requiredField : FxDependency.openapiRequiredFields) {
        if (jsonObj.get(requiredField) == null) {
          throw new IllegalArgumentException(String.format("The required field `%s` is not found in the JSON string: %s", requiredField, jsonObj.toString()));
        }
      }
  }

  public static class CustomTypeAdapterFactory implements TypeAdapterFactory {
    @SuppressWarnings("unchecked")
    @Override
    public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {
       if (!FxDependency.class.isAssignableFrom(type.getRawType())) {
         return null; // this class only serializes 'FxDependency' and its subtypes
       }
       final TypeAdapter<JsonElement> elementAdapter = gson.getAdapter(JsonElement.class);
       final TypeAdapter<FxDependency> thisAdapter
                        = gson.getDelegateAdapter(this, TypeToken.get(FxDependency.class));

       return (TypeAdapter<T>) new TypeAdapter<FxDependency>() {
           @Override
           public void write(JsonWriter out, FxDependency value) throws IOException {
             JsonObject obj = thisAdapter.toJsonTree(value).getAsJsonObject();
             elementAdapter.write(out, obj);
           }

           @Override
           public FxDependency read(JsonReader in) throws IOException {
             JsonObject jsonObj = elementAdapter.read(in).getAsJsonObject();
             validateJsonObject(jsonObj);
             return thisAdapter.fromJsonTree(jsonObj);
           }

       }.nullSafe();
    }
  }

 /**
  * Create an instance of FxDependency given an JSON string
  *
  * @param jsonString JSON string
  * @return An instance of FxDependency
  * @throws IOException if the JSON string is invalid with respect to FxDependency
  */
  public static FxDependency fromJson(String jsonString) throws IOException {
    return JSON.getGson().fromJson(jsonString, FxDependency.class);
  }

 /**
  * Convert an instance of FxDependency to an JSON string
  *
  * @return JSON string
  */
  public String toJson() {
    return JSON.getGson().toJson(this);
  }
}
