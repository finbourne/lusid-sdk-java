/*
 * LUSID API
 *
 * Contact: info@finbourne.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

package com.finbourne.lusid.model;

import java.util.Objects;
import com.finbourne.lusid.model.ModelSelection;
import com.finbourne.lusid.model.ReturnZeroPvOptions;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;
import java.util.Arrays;
import org.openapitools.jackson.nullable.JsonNullable;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonArray;
import com.google.gson.JsonDeserializationContext;
import com.google.gson.JsonDeserializer;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParseException;
import com.google.gson.TypeAdapterFactory;
import com.google.gson.reflect.TypeToken;
import com.google.gson.TypeAdapter;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;

import java.lang.reflect.Type;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Map.Entry;
import java.util.Set;

import com.finbourne.lusid.JSON;

/**
 * Options for controlling the default aspects and behaviour of the pricing engine.
 */
@jakarta.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen")
public class PricingOptions {
  public static final String SERIALIZED_NAME_MODEL_SELECTION = "modelSelection";
  @SerializedName(SERIALIZED_NAME_MODEL_SELECTION)
  private ModelSelection modelSelection;

  public static final String SERIALIZED_NAME_USE_INSTRUMENT_TYPE_TO_DETERMINE_PRICER = "useInstrumentTypeToDeterminePricer";
  @SerializedName(SERIALIZED_NAME_USE_INSTRUMENT_TYPE_TO_DETERMINE_PRICER)
  private Boolean useInstrumentTypeToDeterminePricer;

  public static final String SERIALIZED_NAME_ALLOW_ANY_INSTRUMENTS_WITH_SEC_UID_TO_PRICE_OFF_LOOKUP = "allowAnyInstrumentsWithSecUidToPriceOffLookup";
  @SerializedName(SERIALIZED_NAME_ALLOW_ANY_INSTRUMENTS_WITH_SEC_UID_TO_PRICE_OFF_LOOKUP)
  private Boolean allowAnyInstrumentsWithSecUidToPriceOffLookup;

  public static final String SERIALIZED_NAME_ALLOW_PARTIALLY_SUCCESSFUL_EVALUATION = "allowPartiallySuccessfulEvaluation";
  @SerializedName(SERIALIZED_NAME_ALLOW_PARTIALLY_SUCCESSFUL_EVALUATION)
  private Boolean allowPartiallySuccessfulEvaluation;

  public static final String SERIALIZED_NAME_PRODUCE_SEPARATE_RESULT_FOR_LINEAR_OTC_LEGS = "produceSeparateResultForLinearOtcLegs";
  @SerializedName(SERIALIZED_NAME_PRODUCE_SEPARATE_RESULT_FOR_LINEAR_OTC_LEGS)
  private Boolean produceSeparateResultForLinearOtcLegs;

  public static final String SERIALIZED_NAME_ENABLE_USE_OF_CACHED_UNIT_RESULTS = "enableUseOfCachedUnitResults";
  @SerializedName(SERIALIZED_NAME_ENABLE_USE_OF_CACHED_UNIT_RESULTS)
  private Boolean enableUseOfCachedUnitResults;

  public static final String SERIALIZED_NAME_WINDOW_VALUATION_ON_INSTRUMENT_START_END = "windowValuationOnInstrumentStartEnd";
  @SerializedName(SERIALIZED_NAME_WINDOW_VALUATION_ON_INSTRUMENT_START_END)
  private Boolean windowValuationOnInstrumentStartEnd;

  public static final String SERIALIZED_NAME_REMOVE_CONTINGENT_CASHFLOWS_IN_PAYMENT_DIARY = "removeContingentCashflowsInPaymentDiary";
  @SerializedName(SERIALIZED_NAME_REMOVE_CONTINGENT_CASHFLOWS_IN_PAYMENT_DIARY)
  private Boolean removeContingentCashflowsInPaymentDiary;

  public static final String SERIALIZED_NAME_USE_CHILD_SUB_HOLDING_KEYS_FOR_PORTFOLIO_EXPANSION = "useChildSubHoldingKeysForPortfolioExpansion";
  @SerializedName(SERIALIZED_NAME_USE_CHILD_SUB_HOLDING_KEYS_FOR_PORTFOLIO_EXPANSION)
  private Boolean useChildSubHoldingKeysForPortfolioExpansion;

  public static final String SERIALIZED_NAME_VALIDATE_DOMESTIC_AND_QUOTE_CURRENCIES_ARE_CONSISTENT = "validateDomesticAndQuoteCurrenciesAreConsistent";
  @SerializedName(SERIALIZED_NAME_VALIDATE_DOMESTIC_AND_QUOTE_CURRENCIES_ARE_CONSISTENT)
  private Boolean validateDomesticAndQuoteCurrenciesAreConsistent;

  public static final String SERIALIZED_NAME_MBS_VALUATION_USING_HOLDING_CURRENT_FACE = "mbsValuationUsingHoldingCurrentFace";
  @SerializedName(SERIALIZED_NAME_MBS_VALUATION_USING_HOLDING_CURRENT_FACE)
  private Boolean mbsValuationUsingHoldingCurrentFace;

  public static final String SERIALIZED_NAME_CONVERT_SRS_CASH_FLOWS_TO_PORTFOLIO_CURRENCY = "convertSrsCashFlowsToPortfolioCurrency";
  @SerializedName(SERIALIZED_NAME_CONVERT_SRS_CASH_FLOWS_TO_PORTFOLIO_CURRENCY)
  private Boolean convertSrsCashFlowsToPortfolioCurrency;

  public static final String SERIALIZED_NAME_CONSERVED_QUANTITY_FOR_LOOKTHROUGH_EXPANSION = "conservedQuantityForLookthroughExpansion";
  @SerializedName(SERIALIZED_NAME_CONSERVED_QUANTITY_FOR_LOOKTHROUGH_EXPANSION)
  private String conservedQuantityForLookthroughExpansion;

  public static final String SERIALIZED_NAME_RETURN_ZERO_PV = "returnZeroPv";
  @SerializedName(SERIALIZED_NAME_RETURN_ZERO_PV)
  private ReturnZeroPvOptions returnZeroPv;

  public static final String SERIALIZED_NAME_ENABLE_LEG_LEVEL_INFERENCE_FOR_CUSTOM_SRS_COLUMNS = "enableLegLevelInferenceForCustomSrsColumns";
  @SerializedName(SERIALIZED_NAME_ENABLE_LEG_LEVEL_INFERENCE_FOR_CUSTOM_SRS_COLUMNS)
  private Boolean enableLegLevelInferenceForCustomSrsColumns;

  public PricingOptions() {
  }

  public PricingOptions modelSelection(ModelSelection modelSelection) {
    
    this.modelSelection = modelSelection;
    return this;
  }

   /**
   * Get modelSelection
   * @return modelSelection
  **/
  @jakarta.annotation.Nullable
  public ModelSelection getModelSelection() {
    return modelSelection;
  }


  public void setModelSelection(ModelSelection modelSelection) {
    this.modelSelection = modelSelection;
  }


  public PricingOptions useInstrumentTypeToDeterminePricer(Boolean useInstrumentTypeToDeterminePricer) {
    
    this.useInstrumentTypeToDeterminePricer = useInstrumentTypeToDeterminePricer;
    return this;
  }

   /**
   * If true then use the instrument type to set the default instrument pricer This applies where no more specific set of overrides are provided on a per-vendor and instrument basis.
   * @return useInstrumentTypeToDeterminePricer
  **/
  @jakarta.annotation.Nullable
  public Boolean getUseInstrumentTypeToDeterminePricer() {
    return useInstrumentTypeToDeterminePricer;
  }


  public void setUseInstrumentTypeToDeterminePricer(Boolean useInstrumentTypeToDeterminePricer) {
    this.useInstrumentTypeToDeterminePricer = useInstrumentTypeToDeterminePricer;
  }


  public PricingOptions allowAnyInstrumentsWithSecUidToPriceOffLookup(Boolean allowAnyInstrumentsWithSecUidToPriceOffLookup) {
    
    this.allowAnyInstrumentsWithSecUidToPriceOffLookup = allowAnyInstrumentsWithSecUidToPriceOffLookup;
    return this;
  }

   /**
   * By default, one would not expect to price and exotic instrument, i.e. an instrument with a complicated instrument definition simply through looking up a price as there should be a better way of evaluating it. To override that behaviour and allow lookup for a price from the instrument identifier(s), set this to true.
   * @return allowAnyInstrumentsWithSecUidToPriceOffLookup
  **/
  @jakarta.annotation.Nullable
  public Boolean getAllowAnyInstrumentsWithSecUidToPriceOffLookup() {
    return allowAnyInstrumentsWithSecUidToPriceOffLookup;
  }


  public void setAllowAnyInstrumentsWithSecUidToPriceOffLookup(Boolean allowAnyInstrumentsWithSecUidToPriceOffLookup) {
    this.allowAnyInstrumentsWithSecUidToPriceOffLookup = allowAnyInstrumentsWithSecUidToPriceOffLookup;
  }


  public PricingOptions allowPartiallySuccessfulEvaluation(Boolean allowPartiallySuccessfulEvaluation) {
    
    this.allowPartiallySuccessfulEvaluation = allowPartiallySuccessfulEvaluation;
    return this;
  }

   /**
   * If true then a failure in task evaluation doesn&#39;t cause overall failure. results will be returned where they succeeded and annotation elsewhere
   * @return allowPartiallySuccessfulEvaluation
  **/
  @jakarta.annotation.Nullable
  public Boolean getAllowPartiallySuccessfulEvaluation() {
    return allowPartiallySuccessfulEvaluation;
  }


  public void setAllowPartiallySuccessfulEvaluation(Boolean allowPartiallySuccessfulEvaluation) {
    this.allowPartiallySuccessfulEvaluation = allowPartiallySuccessfulEvaluation;
  }


  public PricingOptions produceSeparateResultForLinearOtcLegs(Boolean produceSeparateResultForLinearOtcLegs) {
    
    this.produceSeparateResultForLinearOtcLegs = produceSeparateResultForLinearOtcLegs;
    return this;
  }

   /**
   * If true (default), when pricing an Fx-Forward or Interest Rate Swap, Future and other linearly separable products, product two results, one for each leg rather than a single line result with the amalgamated/summed pv from both legs.
   * @return produceSeparateResultForLinearOtcLegs
  **/
  @jakarta.annotation.Nullable
  public Boolean getProduceSeparateResultForLinearOtcLegs() {
    return produceSeparateResultForLinearOtcLegs;
  }


  public void setProduceSeparateResultForLinearOtcLegs(Boolean produceSeparateResultForLinearOtcLegs) {
    this.produceSeparateResultForLinearOtcLegs = produceSeparateResultForLinearOtcLegs;
  }


  public PricingOptions enableUseOfCachedUnitResults(Boolean enableUseOfCachedUnitResults) {
    
    this.enableUseOfCachedUnitResults = enableUseOfCachedUnitResults;
    return this;
  }

   /**
   * If true, when pricing using a model or for an instrument that supports use of intermediate cached-results, use them. Default is that this caching is turned off.
   * @return enableUseOfCachedUnitResults
  **/
  @jakarta.annotation.Nullable
  public Boolean getEnableUseOfCachedUnitResults() {
    return enableUseOfCachedUnitResults;
  }


  public void setEnableUseOfCachedUnitResults(Boolean enableUseOfCachedUnitResults) {
    this.enableUseOfCachedUnitResults = enableUseOfCachedUnitResults;
  }


  public PricingOptions windowValuationOnInstrumentStartEnd(Boolean windowValuationOnInstrumentStartEnd) {
    
    this.windowValuationOnInstrumentStartEnd = windowValuationOnInstrumentStartEnd;
    return this;
  }

   /**
   * If true, when valuing an instrument outside the period where it is &#39;alive&#39; (the start-maturity window) it will return a valuation of zero
   * @return windowValuationOnInstrumentStartEnd
  **/
  @jakarta.annotation.Nullable
  public Boolean getWindowValuationOnInstrumentStartEnd() {
    return windowValuationOnInstrumentStartEnd;
  }


  public void setWindowValuationOnInstrumentStartEnd(Boolean windowValuationOnInstrumentStartEnd) {
    this.windowValuationOnInstrumentStartEnd = windowValuationOnInstrumentStartEnd;
  }


  public PricingOptions removeContingentCashflowsInPaymentDiary(Boolean removeContingentCashflowsInPaymentDiary) {
    
    this.removeContingentCashflowsInPaymentDiary = removeContingentCashflowsInPaymentDiary;
    return this;
  }

   /**
   * When creating a payment diary, should contingent cash payments (e.g. from exercise of a swaption into a swap) be included or not. i.e. Is exercise or default being assumed to happen or not.
   * @return removeContingentCashflowsInPaymentDiary
  **/
  @jakarta.annotation.Nullable
  public Boolean getRemoveContingentCashflowsInPaymentDiary() {
    return removeContingentCashflowsInPaymentDiary;
  }


  public void setRemoveContingentCashflowsInPaymentDiary(Boolean removeContingentCashflowsInPaymentDiary) {
    this.removeContingentCashflowsInPaymentDiary = removeContingentCashflowsInPaymentDiary;
  }


  public PricingOptions useChildSubHoldingKeysForPortfolioExpansion(Boolean useChildSubHoldingKeysForPortfolioExpansion) {
    
    this.useChildSubHoldingKeysForPortfolioExpansion = useChildSubHoldingKeysForPortfolioExpansion;
    return this;
  }

   /**
   * Should fund constituents inherit subholding keys from the parent subholding keyb
   * @return useChildSubHoldingKeysForPortfolioExpansion
  **/
  @jakarta.annotation.Nullable
  public Boolean getUseChildSubHoldingKeysForPortfolioExpansion() {
    return useChildSubHoldingKeysForPortfolioExpansion;
  }


  public void setUseChildSubHoldingKeysForPortfolioExpansion(Boolean useChildSubHoldingKeysForPortfolioExpansion) {
    this.useChildSubHoldingKeysForPortfolioExpansion = useChildSubHoldingKeysForPortfolioExpansion;
  }


  public PricingOptions validateDomesticAndQuoteCurrenciesAreConsistent(Boolean validateDomesticAndQuoteCurrenciesAreConsistent) {
    
    this.validateDomesticAndQuoteCurrenciesAreConsistent = validateDomesticAndQuoteCurrenciesAreConsistent;
    return this;
  }

   /**
   * Do we validate that the instrument domestic currency matches the quote currency (unless unknown/zzz) when using lookup pricing.
   * @return validateDomesticAndQuoteCurrenciesAreConsistent
  **/
  @jakarta.annotation.Nullable
  public Boolean getValidateDomesticAndQuoteCurrenciesAreConsistent() {
    return validateDomesticAndQuoteCurrenciesAreConsistent;
  }


  public void setValidateDomesticAndQuoteCurrenciesAreConsistent(Boolean validateDomesticAndQuoteCurrenciesAreConsistent) {
    this.validateDomesticAndQuoteCurrenciesAreConsistent = validateDomesticAndQuoteCurrenciesAreConsistent;
  }


  public PricingOptions mbsValuationUsingHoldingCurrentFace(Boolean mbsValuationUsingHoldingCurrentFace) {
    
    this.mbsValuationUsingHoldingCurrentFace = mbsValuationUsingHoldingCurrentFace;
    return this;
  }

   /**
   * Get mbsValuationUsingHoldingCurrentFace
   * @return mbsValuationUsingHoldingCurrentFace
  **/
  @jakarta.annotation.Nullable
  public Boolean getMbsValuationUsingHoldingCurrentFace() {
    return mbsValuationUsingHoldingCurrentFace;
  }


  public void setMbsValuationUsingHoldingCurrentFace(Boolean mbsValuationUsingHoldingCurrentFace) {
    this.mbsValuationUsingHoldingCurrentFace = mbsValuationUsingHoldingCurrentFace;
  }


  public PricingOptions convertSrsCashFlowsToPortfolioCurrency(Boolean convertSrsCashFlowsToPortfolioCurrency) {
    
    this.convertSrsCashFlowsToPortfolioCurrency = convertSrsCashFlowsToPortfolioCurrency;
    return this;
  }

   /**
   * In the case upserted structured result store (SRS) cashflows are not  in the portfolio currency, set this parameter to True to convert said cashflows into the portfolio currency. By default, this flag is set  to False and Lusid will not do any FX conversion.  Please note that FX conversion is dependent on the data available in the quote store - ensure that all relevant FX quotes have been loaded for cashflow currency conversion.
   * @return convertSrsCashFlowsToPortfolioCurrency
  **/
  @jakarta.annotation.Nullable
  public Boolean getConvertSrsCashFlowsToPortfolioCurrency() {
    return convertSrsCashFlowsToPortfolioCurrency;
  }


  public void setConvertSrsCashFlowsToPortfolioCurrency(Boolean convertSrsCashFlowsToPortfolioCurrency) {
    this.convertSrsCashFlowsToPortfolioCurrency = convertSrsCashFlowsToPortfolioCurrency;
  }


  public PricingOptions conservedQuantityForLookthroughExpansion(String conservedQuantityForLookthroughExpansion) {
    
    this.conservedQuantityForLookthroughExpansion = conservedQuantityForLookthroughExpansion;
    return this;
  }

   /**
   * When performing lookthrough portfolio expansion with ScalingMethodology set to \&quot;Sum\&quot; or \&quot;AbsoluteSum\&quot;, the quantity specified here will be conserved and apportioned to lookthrough constituents. For example, an equal-weighting index with 100 constituents can be modelled as a reference portfolio with 1% weights on each equity. When expanding a $9000 holding of that index into its constituents while conserving PV, we end up with $90 of each equity. The number of units of each equity held is then implied. Note that conservation of one quantity may imply non-conservation of others, especially when some constituents are OTCs.   Allowed values are: \&quot;PV\&quot; (default), \&quot;Exposure\&quot;.
   * @return conservedQuantityForLookthroughExpansion
  **/
  @jakarta.annotation.Nullable
  public String getConservedQuantityForLookthroughExpansion() {
    return conservedQuantityForLookthroughExpansion;
  }


  public void setConservedQuantityForLookthroughExpansion(String conservedQuantityForLookthroughExpansion) {
    this.conservedQuantityForLookthroughExpansion = conservedQuantityForLookthroughExpansion;
  }


  public PricingOptions returnZeroPv(ReturnZeroPvOptions returnZeroPv) {
    
    this.returnZeroPv = returnZeroPv;
    return this;
  }

   /**
   * Get returnZeroPv
   * @return returnZeroPv
  **/
  @jakarta.annotation.Nullable
  public ReturnZeroPvOptions getReturnZeroPv() {
    return returnZeroPv;
  }


  public void setReturnZeroPv(ReturnZeroPvOptions returnZeroPv) {
    this.returnZeroPv = returnZeroPv;
  }


  public PricingOptions enableLegLevelInferenceForCustomSrsColumns(Boolean enableLegLevelInferenceForCustomSrsColumns) {
    
    this.enableLegLevelInferenceForCustomSrsColumns = enableLegLevelInferenceForCustomSrsColumns;
    return this;
  }

   /**
   * When enabled, allows inference between leg-level and instrument-level data during portfolio valuation. If data is missing at one level, it may be inferred from the other level. For example, missing leg-level data  may be inferred from existing leg-level and instrument- level data when ProduceSeparateResultForLinearOtcLegs is enabled, and vice versa. Explicitly provided data always takes precedence.
   * @return enableLegLevelInferenceForCustomSrsColumns
  **/
  @jakarta.annotation.Nullable
  public Boolean getEnableLegLevelInferenceForCustomSrsColumns() {
    return enableLegLevelInferenceForCustomSrsColumns;
  }


  public void setEnableLegLevelInferenceForCustomSrsColumns(Boolean enableLegLevelInferenceForCustomSrsColumns) {
    this.enableLegLevelInferenceForCustomSrsColumns = enableLegLevelInferenceForCustomSrsColumns;
  }



  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    PricingOptions pricingOptions = (PricingOptions) o;
    return Objects.equals(this.modelSelection, pricingOptions.modelSelection) &&
        Objects.equals(this.useInstrumentTypeToDeterminePricer, pricingOptions.useInstrumentTypeToDeterminePricer) &&
        Objects.equals(this.allowAnyInstrumentsWithSecUidToPriceOffLookup, pricingOptions.allowAnyInstrumentsWithSecUidToPriceOffLookup) &&
        Objects.equals(this.allowPartiallySuccessfulEvaluation, pricingOptions.allowPartiallySuccessfulEvaluation) &&
        Objects.equals(this.produceSeparateResultForLinearOtcLegs, pricingOptions.produceSeparateResultForLinearOtcLegs) &&
        Objects.equals(this.enableUseOfCachedUnitResults, pricingOptions.enableUseOfCachedUnitResults) &&
        Objects.equals(this.windowValuationOnInstrumentStartEnd, pricingOptions.windowValuationOnInstrumentStartEnd) &&
        Objects.equals(this.removeContingentCashflowsInPaymentDiary, pricingOptions.removeContingentCashflowsInPaymentDiary) &&
        Objects.equals(this.useChildSubHoldingKeysForPortfolioExpansion, pricingOptions.useChildSubHoldingKeysForPortfolioExpansion) &&
        Objects.equals(this.validateDomesticAndQuoteCurrenciesAreConsistent, pricingOptions.validateDomesticAndQuoteCurrenciesAreConsistent) &&
        Objects.equals(this.mbsValuationUsingHoldingCurrentFace, pricingOptions.mbsValuationUsingHoldingCurrentFace) &&
        Objects.equals(this.convertSrsCashFlowsToPortfolioCurrency, pricingOptions.convertSrsCashFlowsToPortfolioCurrency) &&
        Objects.equals(this.conservedQuantityForLookthroughExpansion, pricingOptions.conservedQuantityForLookthroughExpansion) &&
        Objects.equals(this.returnZeroPv, pricingOptions.returnZeroPv) &&
        Objects.equals(this.enableLegLevelInferenceForCustomSrsColumns, pricingOptions.enableLegLevelInferenceForCustomSrsColumns);
  }

  private static <T> boolean equalsNullable(JsonNullable<T> a, JsonNullable<T> b) {
    return a == b || (a != null && b != null && a.isPresent() && b.isPresent() && Objects.deepEquals(a.get(), b.get()));
  }

  @Override
  public int hashCode() {
    return Objects.hash(modelSelection, useInstrumentTypeToDeterminePricer, allowAnyInstrumentsWithSecUidToPriceOffLookup, allowPartiallySuccessfulEvaluation, produceSeparateResultForLinearOtcLegs, enableUseOfCachedUnitResults, windowValuationOnInstrumentStartEnd, removeContingentCashflowsInPaymentDiary, useChildSubHoldingKeysForPortfolioExpansion, validateDomesticAndQuoteCurrenciesAreConsistent, mbsValuationUsingHoldingCurrentFace, convertSrsCashFlowsToPortfolioCurrency, conservedQuantityForLookthroughExpansion, returnZeroPv, enableLegLevelInferenceForCustomSrsColumns);
  }

  private static <T> int hashCodeNullable(JsonNullable<T> a) {
    if (a == null) {
      return 1;
    }
    return a.isPresent() ? Arrays.deepHashCode(new Object[]{a.get()}) : 31;
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class PricingOptions {\n");
    sb.append("    modelSelection: ").append(toIndentedString(modelSelection)).append("\n");
    sb.append("    useInstrumentTypeToDeterminePricer: ").append(toIndentedString(useInstrumentTypeToDeterminePricer)).append("\n");
    sb.append("    allowAnyInstrumentsWithSecUidToPriceOffLookup: ").append(toIndentedString(allowAnyInstrumentsWithSecUidToPriceOffLookup)).append("\n");
    sb.append("    allowPartiallySuccessfulEvaluation: ").append(toIndentedString(allowPartiallySuccessfulEvaluation)).append("\n");
    sb.append("    produceSeparateResultForLinearOtcLegs: ").append(toIndentedString(produceSeparateResultForLinearOtcLegs)).append("\n");
    sb.append("    enableUseOfCachedUnitResults: ").append(toIndentedString(enableUseOfCachedUnitResults)).append("\n");
    sb.append("    windowValuationOnInstrumentStartEnd: ").append(toIndentedString(windowValuationOnInstrumentStartEnd)).append("\n");
    sb.append("    removeContingentCashflowsInPaymentDiary: ").append(toIndentedString(removeContingentCashflowsInPaymentDiary)).append("\n");
    sb.append("    useChildSubHoldingKeysForPortfolioExpansion: ").append(toIndentedString(useChildSubHoldingKeysForPortfolioExpansion)).append("\n");
    sb.append("    validateDomesticAndQuoteCurrenciesAreConsistent: ").append(toIndentedString(validateDomesticAndQuoteCurrenciesAreConsistent)).append("\n");
    sb.append("    mbsValuationUsingHoldingCurrentFace: ").append(toIndentedString(mbsValuationUsingHoldingCurrentFace)).append("\n");
    sb.append("    convertSrsCashFlowsToPortfolioCurrency: ").append(toIndentedString(convertSrsCashFlowsToPortfolioCurrency)).append("\n");
    sb.append("    conservedQuantityForLookthroughExpansion: ").append(toIndentedString(conservedQuantityForLookthroughExpansion)).append("\n");
    sb.append("    returnZeroPv: ").append(toIndentedString(returnZeroPv)).append("\n");
    sb.append("    enableLegLevelInferenceForCustomSrsColumns: ").append(toIndentedString(enableLegLevelInferenceForCustomSrsColumns)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }


  public static HashSet<String> openapiFields;
  public static HashSet<String> openapiRequiredFields;

  static {
    // a set of all properties/fields (JSON key names)
    openapiFields = new HashSet<String>();
    openapiFields.add("modelSelection");
    openapiFields.add("useInstrumentTypeToDeterminePricer");
    openapiFields.add("allowAnyInstrumentsWithSecUidToPriceOffLookup");
    openapiFields.add("allowPartiallySuccessfulEvaluation");
    openapiFields.add("produceSeparateResultForLinearOtcLegs");
    openapiFields.add("enableUseOfCachedUnitResults");
    openapiFields.add("windowValuationOnInstrumentStartEnd");
    openapiFields.add("removeContingentCashflowsInPaymentDiary");
    openapiFields.add("useChildSubHoldingKeysForPortfolioExpansion");
    openapiFields.add("validateDomesticAndQuoteCurrenciesAreConsistent");
    openapiFields.add("mbsValuationUsingHoldingCurrentFace");
    openapiFields.add("convertSrsCashFlowsToPortfolioCurrency");
    openapiFields.add("conservedQuantityForLookthroughExpansion");
    openapiFields.add("returnZeroPv");
    openapiFields.add("enableLegLevelInferenceForCustomSrsColumns");

    // a set of required properties/fields (JSON key names)
    openapiRequiredFields = new HashSet<String>();
  }

 /**
  * Validates the JSON Element and throws an exception if issues found
  *
  * @param jsonElement JSON Element
  * @throws IOException if the JSON Element is invalid with respect to PricingOptions
  */
  public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      if (jsonElement == null) {
        if (!PricingOptions.openapiRequiredFields.isEmpty()) { // has required fields but JSON element is null
          throw new IllegalArgumentException(String.format("The required field(s) %s in PricingOptions is not found in the empty JSON string", PricingOptions.openapiRequiredFields.toString()));
        }
      }
        JsonObject jsonObj = jsonElement.getAsJsonObject();
      // validate the optional field `modelSelection`
      if (jsonObj.get("modelSelection") != null && !jsonObj.get("modelSelection").isJsonNull()) {
        ModelSelection.validateJsonElement(jsonObj.get("modelSelection"));
      }
      if ((jsonObj.get("conservedQuantityForLookthroughExpansion") != null && !jsonObj.get("conservedQuantityForLookthroughExpansion").isJsonNull()) && !jsonObj.get("conservedQuantityForLookthroughExpansion").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `conservedQuantityForLookthroughExpansion` to be a primitive type in the JSON string but got `%s`", jsonObj.get("conservedQuantityForLookthroughExpansion").toString()));
      }
      // validate the optional field `returnZeroPv`
      if (jsonObj.get("returnZeroPv") != null && !jsonObj.get("returnZeroPv").isJsonNull()) {
        ReturnZeroPvOptions.validateJsonElement(jsonObj.get("returnZeroPv"));
      }
  }

  public static class CustomTypeAdapterFactory implements TypeAdapterFactory {
    @SuppressWarnings("unchecked")
    @Override
    public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {
       if (!PricingOptions.class.isAssignableFrom(type.getRawType())) {
         return null; // this class only serializes 'PricingOptions' and its subtypes
       }
       final TypeAdapter<JsonElement> elementAdapter = gson.getAdapter(JsonElement.class);
       final TypeAdapter<PricingOptions> thisAdapter
                        = gson.getDelegateAdapter(this, TypeToken.get(PricingOptions.class));

       return (TypeAdapter<T>) new TypeAdapter<PricingOptions>() {
           @Override
           public void write(JsonWriter out, PricingOptions value) throws IOException {
             JsonObject obj = thisAdapter.toJsonTree(value).getAsJsonObject();
             elementAdapter.write(out, obj);
           }

           @Override
           public PricingOptions read(JsonReader in) throws IOException {
             JsonElement jsonElement = elementAdapter.read(in);
             validateJsonElement(jsonElement);
             return thisAdapter.fromJsonTree(jsonElement);
           }

       }.nullSafe();
    }
  }

 /**
  * Create an instance of PricingOptions given an JSON string
  *
  * @param jsonString JSON string
  * @return An instance of PricingOptions
  * @throws IOException if the JSON string is invalid with respect to PricingOptions
  */
  public static PricingOptions fromJson(String jsonString) throws IOException {
    return JSON.getGson().fromJson(jsonString, PricingOptions.class);
  }

 /**
  * Convert an instance of PricingOptions to an JSON string
  *
  * @return JSON string
  */
  public String toJson() {
    return JSON.getGson().toJson(this);
  }
}
