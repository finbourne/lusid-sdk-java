/*
 * LUSID API
 *
 * Contact: info@finbourne.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

package com.finbourne.lusid.model;

import java.util.Objects;
import com.finbourne.lusid.model.LusidInstrument;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;
import java.time.OffsetDateTime;
import java.util.Arrays;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonArray;
import com.google.gson.JsonDeserializationContext;
import com.google.gson.JsonDeserializer;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParseException;
import com.google.gson.TypeAdapterFactory;
import com.google.gson.reflect.TypeToken;
import com.google.gson.TypeAdapter;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;

import java.lang.reflect.Type;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Map.Entry;
import java.util.Set;

import com.finbourne.lusid.JSON;

/**
 * Loan Facility. This is a very lightweight instrument which acts as a placeholder for the events occurring within  the related facility Portfolio. This Portfolio is identified by its Scope and Code, which is recorded on the  instrument definition. The instrument acts as an agreement between a single borrower and many lenders (investors).  Several contracts may be drawn up to enable the lending of funds to the borrower. These contracts are modelled via  FlexibleLoan instruments in LUSID. The events occurring within the linked Portfolio may be related  to the facility as a whole (for example to define a global commitment amount), or they may relate to a single  contract (such as a paydown transaction on a particular contract).
 */
@jakarta.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen")
public class LoanFacility extends LusidInstrument {
  public static final String SERIALIZED_NAME_START_DATE = "startDate";
  @SerializedName(SERIALIZED_NAME_START_DATE)
  private OffsetDateTime startDate;

  public static final String SERIALIZED_NAME_DOM_CCY = "domCcy";
  @SerializedName(SERIALIZED_NAME_DOM_CCY)
  private String domCcy;

  public static final String SERIALIZED_NAME_FACILITY_PORTFOLIO_SCOPE = "facilityPortfolioScope";
  @SerializedName(SERIALIZED_NAME_FACILITY_PORTFOLIO_SCOPE)
  private String facilityPortfolioScope;

  public static final String SERIALIZED_NAME_FACILITY_PORTFOLIO_CODE = "facilityPortfolioCode";
  @SerializedName(SERIALIZED_NAME_FACILITY_PORTFOLIO_CODE)
  private String facilityPortfolioCode;

  public LoanFacility() {
    // this.instrumentType = this.getClass().getSimpleName();
  }

  public LoanFacility startDate(OffsetDateTime startDate) {
    
    this.startDate = startDate;
    return this;
  }

   /**
   * The start date of the instrument. This is normally synonymous with the trade-date.
   * @return startDate
  **/
  @jakarta.annotation.Nonnull
  public OffsetDateTime getStartDate() {
    return startDate;
  }


  public void setStartDate(OffsetDateTime startDate) {
    this.startDate = startDate;
  }


  public LoanFacility domCcy(String domCcy) {
    
    this.domCcy = domCcy;
    return this;
  }

   /**
   * The domestic currency of the instrument.
   * @return domCcy
  **/
  @jakarta.annotation.Nonnull
  public String getDomCcy() {
    return domCcy;
  }


  public void setDomCcy(String domCcy) {
    this.domCcy = domCcy;
  }


  public LoanFacility facilityPortfolioScope(String facilityPortfolioScope) {
    
    this.facilityPortfolioScope = facilityPortfolioScope;
    return this;
  }

   /**
   * The Scope of the Transaction Portfolio to which the Loan Facility instrument is linked.
   * @return facilityPortfolioScope
  **/
  @jakarta.annotation.Nonnull
  public String getFacilityPortfolioScope() {
    return facilityPortfolioScope;
  }


  public void setFacilityPortfolioScope(String facilityPortfolioScope) {
    this.facilityPortfolioScope = facilityPortfolioScope;
  }


  public LoanFacility facilityPortfolioCode(String facilityPortfolioCode) {
    
    this.facilityPortfolioCode = facilityPortfolioCode;
    return this;
  }

   /**
   * The Code of the Transaction Portfolio to which the Loan Facility instrument is linked.
   * @return facilityPortfolioCode
  **/
  @jakarta.annotation.Nonnull
  public String getFacilityPortfolioCode() {
    return facilityPortfolioCode;
  }


  public void setFacilityPortfolioCode(String facilityPortfolioCode) {
    this.facilityPortfolioCode = facilityPortfolioCode;
  }



  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    LoanFacility loanFacility = (LoanFacility) o;
    return Objects.equals(this.startDate, loanFacility.startDate) &&
        Objects.equals(this.domCcy, loanFacility.domCcy) &&
        Objects.equals(this.facilityPortfolioScope, loanFacility.facilityPortfolioScope) &&
        Objects.equals(this.facilityPortfolioCode, loanFacility.facilityPortfolioCode) &&
        super.equals(o);
  }

  @Override
  public int hashCode() {
    return Objects.hash(startDate, domCcy, facilityPortfolioScope, facilityPortfolioCode, super.hashCode());
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class LoanFacility {\n");
    sb.append("    ").append(toIndentedString(super.toString())).append("\n");
    sb.append("    startDate: ").append(toIndentedString(startDate)).append("\n");
    sb.append("    domCcy: ").append(toIndentedString(domCcy)).append("\n");
    sb.append("    facilityPortfolioScope: ").append(toIndentedString(facilityPortfolioScope)).append("\n");
    sb.append("    facilityPortfolioCode: ").append(toIndentedString(facilityPortfolioCode)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }


  public static HashSet<String> openapiFields;
  public static HashSet<String> openapiRequiredFields;

  static {
    // a set of all properties/fields (JSON key names)
    openapiFields = new HashSet<String>();
    openapiFields.add("instrumentType");
    openapiFields.add("startDate");
    openapiFields.add("domCcy");
    openapiFields.add("facilityPortfolioScope");
    openapiFields.add("facilityPortfolioCode");

    // a set of required properties/fields (JSON key names)
    openapiRequiredFields = new HashSet<String>();
    openapiRequiredFields.add("startDate");
    openapiRequiredFields.add("domCcy");
    openapiRequiredFields.add("facilityPortfolioScope");
    openapiRequiredFields.add("facilityPortfolioCode");
    openapiRequiredFields.add("instrumentType");
  }

 /**
  * Validates the JSON Element and throws an exception if issues found
  *
  * @param jsonElement JSON Element
  * @throws IOException if the JSON Element is invalid with respect to LoanFacility
  */
  public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      if (jsonElement == null) {
        if (!LoanFacility.openapiRequiredFields.isEmpty()) { // has required fields but JSON element is null
          throw new IllegalArgumentException(String.format("The required field(s) %s in LoanFacility is not found in the empty JSON string", LoanFacility.openapiRequiredFields.toString()));
        }
      }

      // check to make sure all required properties/fields are present in the JSON string
      for (String requiredField : LoanFacility.openapiRequiredFields) {
        if (jsonElement.getAsJsonObject().get(requiredField) == null) {
          throw new IllegalArgumentException(String.format("The required field `%s` is not found in the JSON string: %s", requiredField, jsonElement.toString()));
        }
      }
  }

  public static class CustomTypeAdapterFactory implements TypeAdapterFactory {
    @SuppressWarnings("unchecked")
    @Override
    public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {
       if (!LoanFacility.class.isAssignableFrom(type.getRawType())) {
         return null; // this class only serializes 'LoanFacility' and its subtypes
       }
       final TypeAdapter<JsonElement> elementAdapter = gson.getAdapter(JsonElement.class);
       final TypeAdapter<LoanFacility> thisAdapter
                        = gson.getDelegateAdapter(this, TypeToken.get(LoanFacility.class));

       return (TypeAdapter<T>) new TypeAdapter<LoanFacility>() {
           @Override
           public void write(JsonWriter out, LoanFacility value) throws IOException {
             JsonObject obj = thisAdapter.toJsonTree(value).getAsJsonObject();
             elementAdapter.write(out, obj);
           }

           @Override
           public LoanFacility read(JsonReader in) throws IOException {
             JsonElement jsonElement = elementAdapter.read(in);
             validateJsonElement(jsonElement);
             return thisAdapter.fromJsonTree(jsonElement);
           }

       }.nullSafe();
    }
  }

 /**
  * Create an instance of LoanFacility given an JSON string
  *
  * @param jsonString JSON string
  * @return An instance of LoanFacility
  * @throws IOException if the JSON string is invalid with respect to LoanFacility
  */
  public static LoanFacility fromJson(String jsonString) throws IOException {
    return JSON.getGson().fromJson(jsonString, LoanFacility.class);
  }

 /**
  * Convert an instance of LoanFacility to an JSON string
  *
  * @return JSON string
  */
  public String toJson() {
    return JSON.getGson().toJson(this);
  }
}
