/*
 * LUSID API
 *
 * Contact: info@finbourne.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

package com.finbourne.lusid.model;

import java.util.Objects;
import com.finbourne.lusid.model.AggregationOptions;
import com.finbourne.lusid.model.ConfigurationRecipe;
import com.finbourne.lusid.model.MarketDataKeyRule;
import com.finbourne.lusid.model.MarketOptions;
import com.finbourne.lusid.model.PricingOptions;
import com.finbourne.lusid.model.VendorModelRule;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import org.openapitools.jackson.nullable.JsonNullable;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonArray;
import com.google.gson.JsonDeserializationContext;
import com.google.gson.JsonDeserializer;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParseException;
import com.google.gson.TypeAdapterFactory;
import com.google.gson.reflect.TypeToken;
import com.google.gson.TypeAdapter;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;

import java.lang.reflect.Type;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Map.Entry;
import java.util.Set;

import com.finbourne.lusid.JSON;

/**
 * If it is desired to have multiple recipes, there is a strong likelihood that they will share various components.  A configuration recipe snippet allows a user to define a set of rules that can then be included into a parent recipe.  This allows sharing of common blocks of the recipe.                For example, a user might define a set of rules for resolving Fx and then include them into every recipe used firm-wide, thereby  enforcing consistency. As the rules can be permissioned differently using Shrine, it is possible to enable users to   read but not alter such a rule set.                The same applies to a set of pricing rules.                A configuration snippet must only contain one entry from the available set.                 Recipes are compiled from the set of snippets through a model that is analogous to inheritance.  A recipe can have a set of &#39;parent&#39; recipes from which it inherits. These are specified in the inheritance section of a recipe.  Upon loading, the recipe will fall back on these recipe components for any options or rules that are not explicitly specified in the  named recipe for the request.                This allows control of pricing to be harmonised across a set of desks within an institution. Suppose that, e.g.  there are four desks looking after products under the areas of Fx, Rates, Credit and Exotics.  The model and market data for pricing given asset types would potentially be controlled by the appropriate desk; e.g. rules for Fx market data resolution being  controlled by the Fx desk. The exotics desk would likely depend upon rules for all the other asset classes as well as, say, correlation rules of its own.  It could inherit the market data and model rules from the other desks for finding the appropriate institution-standard data and then overlay that with the correlation rules.                Note that permissioning of the store means that one could decide that only a particular desk or control function could update certain rules. That would assist the abilitiy  to ensure that pricing is performed consistently and provide an audit of changes made to it along with restricting changes to appropriate authorised functions.
 */
@jakarta.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen")
public class ConfigurationRecipeSnippet {
  public static final String SERIALIZED_NAME_SCOPE = "scope";
  @SerializedName(SERIALIZED_NAME_SCOPE)
  private String scope;

  public static final String SERIALIZED_NAME_CODE = "code";
  @SerializedName(SERIALIZED_NAME_CODE)
  private String code;

  public static final String SERIALIZED_NAME_AGGREGATION_OPTIONS = "aggregationOptions";
  @SerializedName(SERIALIZED_NAME_AGGREGATION_OPTIONS)
  private AggregationOptions aggregationOptions;

  public static final String SERIALIZED_NAME_MODEL_RULES = "modelRules";
  @SerializedName(SERIALIZED_NAME_MODEL_RULES)
  private List<VendorModelRule> modelRules;

  public static final String SERIALIZED_NAME_PRICING_OPTIONS = "pricingOptions";
  @SerializedName(SERIALIZED_NAME_PRICING_OPTIONS)
  private PricingOptions pricingOptions;

  public static final String SERIALIZED_NAME_MARKET_RULES = "marketRules";
  @SerializedName(SERIALIZED_NAME_MARKET_RULES)
  private List<MarketDataKeyRule> marketRules;

  public static final String SERIALIZED_NAME_MARKET_OPTIONS = "marketOptions";
  @SerializedName(SERIALIZED_NAME_MARKET_OPTIONS)
  private MarketOptions marketOptions;

  public static final String SERIALIZED_NAME_RECIPE = "recipe";
  @SerializedName(SERIALIZED_NAME_RECIPE)
  private ConfigurationRecipe recipe;

  public ConfigurationRecipeSnippet() {
  }

  public ConfigurationRecipeSnippet scope(String scope) {
    
    this.scope = scope;
    return this;
  }

   /**
   * The scope used when updating or inserting the Configuration Recipe snippet
   * @return scope
  **/
  @jakarta.annotation.Nonnull
  public String getScope() {
    return scope;
  }


  public void setScope(String scope) {
    this.scope = scope;
  }


  public ConfigurationRecipeSnippet code(String code) {
    
    this.code = code;
    return this;
  }

   /**
   * User given string name (code) to identify the recipe.
   * @return code
  **/
  @jakarta.annotation.Nonnull
  public String getCode() {
    return code;
  }


  public void setCode(String code) {
    this.code = code;
  }


  public ConfigurationRecipeSnippet aggregationOptions(AggregationOptions aggregationOptions) {
    
    this.aggregationOptions = aggregationOptions;
    return this;
  }

   /**
   * Get aggregationOptions
   * @return aggregationOptions
  **/
  @jakarta.annotation.Nullable
  public AggregationOptions getAggregationOptions() {
    return aggregationOptions;
  }


  public void setAggregationOptions(AggregationOptions aggregationOptions) {
    this.aggregationOptions = aggregationOptions;
  }


  public ConfigurationRecipeSnippet modelRules(List<VendorModelRule> modelRules) {
    
    this.modelRules = modelRules;
    return this;
  }

  public ConfigurationRecipeSnippet addModelRulesItem(VendorModelRule modelRulesItem) {
    if (this.modelRules == null) {
      this.modelRules = new ArrayList<>();
    }
    this.modelRules.add(modelRulesItem);
    return this;
  }

   /**
   * The set of model rules that are available. There may be multiple rules for Vendors, but only one per model-instrument pair.  Which of these preference sets is used depends upon the model choice selection if specified, or failing that the global default model specification  in the options.
   * @return modelRules
  **/
  @jakarta.annotation.Nullable
  public List<VendorModelRule> getModelRules() {
    return modelRules;
  }


  public void setModelRules(List<VendorModelRule> modelRules) {
    this.modelRules = modelRules;
  }


  public ConfigurationRecipeSnippet pricingOptions(PricingOptions pricingOptions) {
    
    this.pricingOptions = pricingOptions;
    return this;
  }

   /**
   * Get pricingOptions
   * @return pricingOptions
  **/
  @jakarta.annotation.Nullable
  public PricingOptions getPricingOptions() {
    return pricingOptions;
  }


  public void setPricingOptions(PricingOptions pricingOptions) {
    this.pricingOptions = pricingOptions;
  }


  public ConfigurationRecipeSnippet marketRules(List<MarketDataKeyRule> marketRules) {
    
    this.marketRules = marketRules;
    return this;
  }

  public ConfigurationRecipeSnippet addMarketRulesItem(MarketDataKeyRule marketRulesItem) {
    if (this.marketRules == null) {
      this.marketRules = new ArrayList<>();
    }
    this.marketRules.add(marketRulesItem);
    return this;
  }

   /**
   * The set of rules that define how to resolve particular use cases. These can be relatively general or specific in nature.  Nominally any number are possible and will be processed in order where applicable. However, there is evidently a potential  for increased computational cost where many rules must be applied to resolve data. Ensuring that portfolios are structured in  such a way as to reduce the number of rules required is therefore sensible.
   * @return marketRules
  **/
  @jakarta.annotation.Nullable
  public List<MarketDataKeyRule> getMarketRules() {
    return marketRules;
  }


  public void setMarketRules(List<MarketDataKeyRule> marketRules) {
    this.marketRules = marketRules;
  }


  public ConfigurationRecipeSnippet marketOptions(MarketOptions marketOptions) {
    
    this.marketOptions = marketOptions;
    return this;
  }

   /**
   * Get marketOptions
   * @return marketOptions
  **/
  @jakarta.annotation.Nullable
  public MarketOptions getMarketOptions() {
    return marketOptions;
  }


  public void setMarketOptions(MarketOptions marketOptions) {
    this.marketOptions = marketOptions;
  }


  public ConfigurationRecipeSnippet recipe(ConfigurationRecipe recipe) {
    
    this.recipe = recipe;
    return this;
  }

   /**
   * Get recipe
   * @return recipe
  **/
  @jakarta.annotation.Nullable
  public ConfigurationRecipe getRecipe() {
    return recipe;
  }


  public void setRecipe(ConfigurationRecipe recipe) {
    this.recipe = recipe;
  }



  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    ConfigurationRecipeSnippet configurationRecipeSnippet = (ConfigurationRecipeSnippet) o;
    return Objects.equals(this.scope, configurationRecipeSnippet.scope) &&
        Objects.equals(this.code, configurationRecipeSnippet.code) &&
        Objects.equals(this.aggregationOptions, configurationRecipeSnippet.aggregationOptions) &&
        Objects.equals(this.modelRules, configurationRecipeSnippet.modelRules) &&
        Objects.equals(this.pricingOptions, configurationRecipeSnippet.pricingOptions) &&
        Objects.equals(this.marketRules, configurationRecipeSnippet.marketRules) &&
        Objects.equals(this.marketOptions, configurationRecipeSnippet.marketOptions) &&
        Objects.equals(this.recipe, configurationRecipeSnippet.recipe);
  }

  private static <T> boolean equalsNullable(JsonNullable<T> a, JsonNullable<T> b) {
    return a == b || (a != null && b != null && a.isPresent() && b.isPresent() && Objects.deepEquals(a.get(), b.get()));
  }

  @Override
  public int hashCode() {
    return Objects.hash(scope, code, aggregationOptions, modelRules, pricingOptions, marketRules, marketOptions, recipe);
  }

  private static <T> int hashCodeNullable(JsonNullable<T> a) {
    if (a == null) {
      return 1;
    }
    return a.isPresent() ? Arrays.deepHashCode(new Object[]{a.get()}) : 31;
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class ConfigurationRecipeSnippet {\n");
    sb.append("    scope: ").append(toIndentedString(scope)).append("\n");
    sb.append("    code: ").append(toIndentedString(code)).append("\n");
    sb.append("    aggregationOptions: ").append(toIndentedString(aggregationOptions)).append("\n");
    sb.append("    modelRules: ").append(toIndentedString(modelRules)).append("\n");
    sb.append("    pricingOptions: ").append(toIndentedString(pricingOptions)).append("\n");
    sb.append("    marketRules: ").append(toIndentedString(marketRules)).append("\n");
    sb.append("    marketOptions: ").append(toIndentedString(marketOptions)).append("\n");
    sb.append("    recipe: ").append(toIndentedString(recipe)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }


  public static HashSet<String> openapiFields;
  public static HashSet<String> openapiRequiredFields;

  static {
    // a set of all properties/fields (JSON key names)
    openapiFields = new HashSet<String>();
    openapiFields.add("scope");
    openapiFields.add("code");
    openapiFields.add("aggregationOptions");
    openapiFields.add("modelRules");
    openapiFields.add("pricingOptions");
    openapiFields.add("marketRules");
    openapiFields.add("marketOptions");
    openapiFields.add("recipe");

    // a set of required properties/fields (JSON key names)
    openapiRequiredFields = new HashSet<String>();
    openapiRequiredFields.add("scope");
    openapiRequiredFields.add("code");
  }

 /**
  * Validates the JSON Object and throws an exception if issues found
  *
  * @param jsonObj JSON Object
  * @throws IOException if the JSON Object is invalid with respect to ConfigurationRecipeSnippet
  */
  public static void validateJsonObject(JsonObject jsonObj) throws IOException {
      if (jsonObj == null) {
        if (!ConfigurationRecipeSnippet.openapiRequiredFields.isEmpty()) { // has required fields but JSON object is null
          throw new IllegalArgumentException(String.format("The required field(s) %s in ConfigurationRecipeSnippet is not found in the empty JSON string", ConfigurationRecipeSnippet.openapiRequiredFields.toString()));
        }
      }

      Set<Entry<String, JsonElement>> entries = jsonObj.entrySet();
      // check to see if the JSON string contains additional fields
      for (Entry<String, JsonElement> entry : entries) {
        if (!ConfigurationRecipeSnippet.openapiFields.contains(entry.getKey())) {
          throw new IllegalArgumentException(String.format("The field `%s` in the JSON string is not defined in the `ConfigurationRecipeSnippet` properties. JSON: %s", entry.getKey(), jsonObj.toString()));
        }
      }

      // check to make sure all required properties/fields are present in the JSON string
      for (String requiredField : ConfigurationRecipeSnippet.openapiRequiredFields) {
        if (jsonObj.get(requiredField) == null) {
          throw new IllegalArgumentException(String.format("The required field `%s` is not found in the JSON string: %s", requiredField, jsonObj.toString()));
        }
      }
      if (!jsonObj.get("scope").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `scope` to be a primitive type in the JSON string but got `%s`", jsonObj.get("scope").toString()));
      }
      if (!jsonObj.get("code").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `code` to be a primitive type in the JSON string but got `%s`", jsonObj.get("code").toString()));
      }
      // validate the optional field `aggregationOptions`
      if (jsonObj.get("aggregationOptions") != null && !jsonObj.get("aggregationOptions").isJsonNull()) {
        AggregationOptions.validateJsonObject(jsonObj.getAsJsonObject("aggregationOptions"));
      }
      if (jsonObj.get("modelRules") != null && !jsonObj.get("modelRules").isJsonNull()) {
        JsonArray jsonArraymodelRules = jsonObj.getAsJsonArray("modelRules");
        if (jsonArraymodelRules != null) {
          // ensure the json data is an array
          if (!jsonObj.get("modelRules").isJsonArray()) {
            throw new IllegalArgumentException(String.format("Expected the field `modelRules` to be an array in the JSON string but got `%s`", jsonObj.get("modelRules").toString()));
          }

          // validate the optional field `modelRules` (array)
          for (int i = 0; i < jsonArraymodelRules.size(); i++) {
            VendorModelRule.validateJsonObject(jsonArraymodelRules.get(i).getAsJsonObject());
          };
        }
      }
      // validate the optional field `pricingOptions`
      if (jsonObj.get("pricingOptions") != null && !jsonObj.get("pricingOptions").isJsonNull()) {
        PricingOptions.validateJsonObject(jsonObj.getAsJsonObject("pricingOptions"));
      }
      if (jsonObj.get("marketRules") != null && !jsonObj.get("marketRules").isJsonNull()) {
        JsonArray jsonArraymarketRules = jsonObj.getAsJsonArray("marketRules");
        if (jsonArraymarketRules != null) {
          // ensure the json data is an array
          if (!jsonObj.get("marketRules").isJsonArray()) {
            throw new IllegalArgumentException(String.format("Expected the field `marketRules` to be an array in the JSON string but got `%s`", jsonObj.get("marketRules").toString()));
          }

          // validate the optional field `marketRules` (array)
          for (int i = 0; i < jsonArraymarketRules.size(); i++) {
            MarketDataKeyRule.validateJsonObject(jsonArraymarketRules.get(i).getAsJsonObject());
          };
        }
      }
      // validate the optional field `marketOptions`
      if (jsonObj.get("marketOptions") != null && !jsonObj.get("marketOptions").isJsonNull()) {
        MarketOptions.validateJsonObject(jsonObj.getAsJsonObject("marketOptions"));
      }
      // validate the optional field `recipe`
      if (jsonObj.get("recipe") != null && !jsonObj.get("recipe").isJsonNull()) {
        ConfigurationRecipe.validateJsonObject(jsonObj.getAsJsonObject("recipe"));
      }
  }

  public static class CustomTypeAdapterFactory implements TypeAdapterFactory {
    @SuppressWarnings("unchecked")
    @Override
    public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {
       if (!ConfigurationRecipeSnippet.class.isAssignableFrom(type.getRawType())) {
         return null; // this class only serializes 'ConfigurationRecipeSnippet' and its subtypes
       }
       final TypeAdapter<JsonElement> elementAdapter = gson.getAdapter(JsonElement.class);
       final TypeAdapter<ConfigurationRecipeSnippet> thisAdapter
                        = gson.getDelegateAdapter(this, TypeToken.get(ConfigurationRecipeSnippet.class));

       return (TypeAdapter<T>) new TypeAdapter<ConfigurationRecipeSnippet>() {
           @Override
           public void write(JsonWriter out, ConfigurationRecipeSnippet value) throws IOException {
             JsonObject obj = thisAdapter.toJsonTree(value).getAsJsonObject();
             elementAdapter.write(out, obj);
           }

           @Override
           public ConfigurationRecipeSnippet read(JsonReader in) throws IOException {
             JsonObject jsonObj = elementAdapter.read(in).getAsJsonObject();
             validateJsonObject(jsonObj);
             return thisAdapter.fromJsonTree(jsonObj);
           }

       }.nullSafe();
    }
  }

 /**
  * Create an instance of ConfigurationRecipeSnippet given an JSON string
  *
  * @param jsonString JSON string
  * @return An instance of ConfigurationRecipeSnippet
  * @throws IOException if the JSON string is invalid with respect to ConfigurationRecipeSnippet
  */
  public static ConfigurationRecipeSnippet fromJson(String jsonString) throws IOException {
    return JSON.getGson().fromJson(jsonString, ConfigurationRecipeSnippet.class);
  }

 /**
  * Convert an instance of ConfigurationRecipeSnippet to an JSON string
  *
  * @return JSON string
  */
  public String toJson() {
    return JSON.getGson().toJson(this);
  }
}
