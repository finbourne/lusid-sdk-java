/*
 * LUSID API
 *
 * Contact: info@finbourne.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

package com.finbourne.lusid.model;

import java.util.Objects;
import com.finbourne.lusid.model.LusidInstrument;
import com.finbourne.lusid.model.RoundingConvention;
import com.finbourne.lusid.model.Schedule;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import org.openapitools.jackson.nullable.JsonNullable;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonArray;
import com.google.gson.JsonDeserializationContext;
import com.google.gson.JsonDeserializer;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParseException;
import com.google.gson.TypeAdapterFactory;
import com.google.gson.reflect.TypeToken;
import com.google.gson.TypeAdapter;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;

import java.lang.reflect.Type;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Map.Entry;
import java.util.Set;

import com.finbourne.lusid.JSON;

/**
 * LUSID representation of a Complex Bond.  Including Floating, Fixed-to-float, Sinkable, Callable, Puttable, and Mortgage Backed Securities.
 */
@jakarta.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen")
public class ComplexBond extends LusidInstrument {
  public static final String SERIALIZED_NAME_IDENTIFIERS = "identifiers";
  @SerializedName(SERIALIZED_NAME_IDENTIFIERS)
  private Map<String, String> identifiers;

  public static final String SERIALIZED_NAME_CALCULATION_TYPE = "calculationType";
  @SerializedName(SERIALIZED_NAME_CALCULATION_TYPE)
  private String calculationType;

  public static final String SERIALIZED_NAME_SCHEDULES = "schedules";
  @SerializedName(SERIALIZED_NAME_SCHEDULES)
  private List<Schedule> schedules;

  public static final String SERIALIZED_NAME_ROUNDING_CONVENTIONS = "roundingConventions";
  @SerializedName(SERIALIZED_NAME_ROUNDING_CONVENTIONS)
  private List<RoundingConvention> roundingConventions;

  public static final String SERIALIZED_NAME_ASSET_BACKED = "assetBacked";
  @SerializedName(SERIALIZED_NAME_ASSET_BACKED)
  private Boolean assetBacked;

  public static final String SERIALIZED_NAME_ASSET_POOL_IDENTIFIER = "assetPoolIdentifier";
  @SerializedName(SERIALIZED_NAME_ASSET_POOL_IDENTIFIER)
  private String assetPoolIdentifier;

  public ComplexBond() {
    // this.instrumentType = this.getClass().getSimpleName();
  }

  public ComplexBond identifiers(Map<String, String> identifiers) {
    
    this.identifiers = identifiers;
    return this;
  }

  public ComplexBond putIdentifiersItem(String key, String identifiersItem) {
    if (this.identifiers == null) {
      this.identifiers = new HashMap<>();
    }
    this.identifiers.put(key, identifiersItem);
    return this;
  }

   /**
   * External market codes and identifiers for the bond, e.g. ISIN.
   * @return identifiers
  **/
  @jakarta.annotation.Nullable
  public Map<String, String> getIdentifiers() {
    return identifiers;
  }


  public void setIdentifiers(Map<String, String> identifiers) {
    this.identifiers = identifiers;
  }


  public ComplexBond calculationType(String calculationType) {
    
    this.calculationType = calculationType;
    return this;
  }

   /**
   * The calculation type applied to the bond coupon amount. This is required for bonds that have a particular type of computing the period coupon, such as simple compounding,  irregular coupons etc.  The default CalculationType is &#x60;Standard&#x60;, which returns a coupon amount equal to Principal generate justfile Coupon Rate / Coupon Frequency. Coupon Frequency is 12M / Payment Frequency.  Payment Frequency can be 1M, 3M, 6M, 12M etc. So Coupon Frequency can be 12, 4, 2, 1 respectively.    Supported string (enumeration) values are: [Standard, DayCountCoupon, NoCalculationFloater, BrazilFixedCoupon].
   * @return calculationType
  **/
  @jakarta.annotation.Nullable
  public String getCalculationType() {
    return calculationType;
  }


  public void setCalculationType(String calculationType) {
    this.calculationType = calculationType;
  }


  public ComplexBond schedules(List<Schedule> schedules) {
    
    this.schedules = schedules;
    return this;
  }

  public ComplexBond addSchedulesItem(Schedule schedulesItem) {
    if (this.schedules == null) {
      this.schedules = new ArrayList<>();
    }
    this.schedules.add(schedulesItem);
    return this;
  }

   /**
   * schedules.
   * @return schedules
  **/
  @jakarta.annotation.Nullable
  public List<Schedule> getSchedules() {
    return schedules;
  }


  public void setSchedules(List<Schedule> schedules) {
    this.schedules = schedules;
  }


  public ComplexBond roundingConventions(List<RoundingConvention> roundingConventions) {
    
    this.roundingConventions = roundingConventions;
    return this;
  }

  public ComplexBond addRoundingConventionsItem(RoundingConvention roundingConventionsItem) {
    if (this.roundingConventions == null) {
      this.roundingConventions = new ArrayList<>();
    }
    this.roundingConventions.add(roundingConventionsItem);
    return this;
  }

   /**
   * Rounding conventions for analytics, if any.
   * @return roundingConventions
  **/
  @jakarta.annotation.Nullable
  public List<RoundingConvention> getRoundingConventions() {
    return roundingConventions;
  }


  public void setRoundingConventions(List<RoundingConvention> roundingConventions) {
    this.roundingConventions = roundingConventions;
  }


  public ComplexBond assetBacked(Boolean assetBacked) {
    
    this.assetBacked = assetBacked;
    return this;
  }

   /**
   * If this flag is set to true, then the outstanding notional and principal repayments will be calculated based  on pool factors in the quote store. Usually AssetBacked bonds also require a RollConvention setting of   within the FlowConventions any given rates schedule (to ensure payment dates always happen on the same day  of the month) and US Agency MBSs with Pay Delay features also require their rates schedules to include an  ExDividendConfiguration to drive the lag between interest accrual and payment.
   * @return assetBacked
  **/
  @jakarta.annotation.Nullable
  public Boolean getAssetBacked() {
    return assetBacked;
  }


  public void setAssetBacked(Boolean assetBacked) {
    this.assetBacked = assetBacked;
  }


  public ComplexBond assetPoolIdentifier(String assetPoolIdentifier) {
    
    this.assetPoolIdentifier = assetPoolIdentifier;
    return this;
  }

   /**
   * Identifier used to retrieve pool factor information about this bond from the quote store. This is expected to  be the bond&#39;s ISIN as the pricer for asset backed securities will specifically look for an identifier of  ISIN identifier type when searching for pool factor reset values in the quote store.
   * @return assetPoolIdentifier
  **/
  @jakarta.annotation.Nullable
  public String getAssetPoolIdentifier() {
    return assetPoolIdentifier;
  }


  public void setAssetPoolIdentifier(String assetPoolIdentifier) {
    this.assetPoolIdentifier = assetPoolIdentifier;
  }



  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    ComplexBond complexBond = (ComplexBond) o;
    return Objects.equals(this.identifiers, complexBond.identifiers) &&
        Objects.equals(this.calculationType, complexBond.calculationType) &&
        Objects.equals(this.schedules, complexBond.schedules) &&
        Objects.equals(this.roundingConventions, complexBond.roundingConventions) &&
        Objects.equals(this.assetBacked, complexBond.assetBacked) &&
        Objects.equals(this.assetPoolIdentifier, complexBond.assetPoolIdentifier) &&
        super.equals(o);
  }

  private static <T> boolean equalsNullable(JsonNullable<T> a, JsonNullable<T> b) {
    return a == b || (a != null && b != null && a.isPresent() && b.isPresent() && Objects.deepEquals(a.get(), b.get()));
  }

  @Override
  public int hashCode() {
    return Objects.hash(identifiers, calculationType, schedules, roundingConventions, assetBacked, assetPoolIdentifier, super.hashCode());
  }

  private static <T> int hashCodeNullable(JsonNullable<T> a) {
    if (a == null) {
      return 1;
    }
    return a.isPresent() ? Arrays.deepHashCode(new Object[]{a.get()}) : 31;
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class ComplexBond {\n");
    sb.append("    ").append(toIndentedString(super.toString())).append("\n");
    sb.append("    identifiers: ").append(toIndentedString(identifiers)).append("\n");
    sb.append("    calculationType: ").append(toIndentedString(calculationType)).append("\n");
    sb.append("    schedules: ").append(toIndentedString(schedules)).append("\n");
    sb.append("    roundingConventions: ").append(toIndentedString(roundingConventions)).append("\n");
    sb.append("    assetBacked: ").append(toIndentedString(assetBacked)).append("\n");
    sb.append("    assetPoolIdentifier: ").append(toIndentedString(assetPoolIdentifier)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }


  public static HashSet<String> openapiFields;
  public static HashSet<String> openapiRequiredFields;

  static {
    // a set of all properties/fields (JSON key names)
    openapiFields = new HashSet<String>();
    openapiFields.add("instrumentType");
    openapiFields.add("identifiers");
    openapiFields.add("calculationType");
    openapiFields.add("schedules");
    openapiFields.add("roundingConventions");
    openapiFields.add("assetBacked");
    openapiFields.add("assetPoolIdentifier");

    // a set of required properties/fields (JSON key names)
    openapiRequiredFields = new HashSet<String>();
    openapiRequiredFields.add("instrumentType");
  }

 /**
  * Validates the JSON Element and throws an exception if issues found
  *
  * @param jsonElement JSON Element
  * @throws IOException if the JSON Element is invalid with respect to ComplexBond
  */
  public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      if (jsonElement == null) {
        if (!ComplexBond.openapiRequiredFields.isEmpty()) { // has required fields but JSON element is null
          throw new IllegalArgumentException(String.format("The required field(s) %s in ComplexBond is not found in the empty JSON string", ComplexBond.openapiRequiredFields.toString()));
        }
      }

      // check to make sure all required properties/fields are present in the JSON string
      for (String requiredField : ComplexBond.openapiRequiredFields) {
        if (jsonElement.getAsJsonObject().get(requiredField) == null) {
          throw new IllegalArgumentException(String.format("The required field `%s` is not found in the JSON string: %s", requiredField, jsonElement.toString()));
        }
      }
  }

  public static class CustomTypeAdapterFactory implements TypeAdapterFactory {
    @SuppressWarnings("unchecked")
    @Override
    public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {
       if (!ComplexBond.class.isAssignableFrom(type.getRawType())) {
         return null; // this class only serializes 'ComplexBond' and its subtypes
       }
       final TypeAdapter<JsonElement> elementAdapter = gson.getAdapter(JsonElement.class);
       final TypeAdapter<ComplexBond> thisAdapter
                        = gson.getDelegateAdapter(this, TypeToken.get(ComplexBond.class));

       return (TypeAdapter<T>) new TypeAdapter<ComplexBond>() {
           @Override
           public void write(JsonWriter out, ComplexBond value) throws IOException {
             JsonObject obj = thisAdapter.toJsonTree(value).getAsJsonObject();
             elementAdapter.write(out, obj);
           }

           @Override
           public ComplexBond read(JsonReader in) throws IOException {
             JsonElement jsonElement = elementAdapter.read(in);
             validateJsonElement(jsonElement);
             return thisAdapter.fromJsonTree(jsonElement);
           }

       }.nullSafe();
    }
  }

 /**
  * Create an instance of ComplexBond given an JSON string
  *
  * @param jsonString JSON string
  * @return An instance of ComplexBond
  * @throws IOException if the JSON string is invalid with respect to ComplexBond
  */
  public static ComplexBond fromJson(String jsonString) throws IOException {
    return JSON.getGson().fromJson(jsonString, ComplexBond.class);
  }

 /**
  * Convert an instance of ComplexBond to an JSON string
  *
  * @return JSON string
  */
  public String toJson() {
    return JSON.getGson().toJson(this);
  }
}
