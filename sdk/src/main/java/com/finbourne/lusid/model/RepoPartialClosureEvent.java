/*
 * LUSID API
 *
 * Contact: info@finbourne.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

package com.finbourne.lusid.model;

import java.util.Objects;
import com.finbourne.lusid.model.InstrumentEvent;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;
import java.time.OffsetDateTime;
import java.util.Arrays;
import org.openapitools.jackson.nullable.JsonNullable;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonArray;
import com.google.gson.JsonDeserializationContext;
import com.google.gson.JsonDeserializer;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParseException;
import com.google.gson.TypeAdapterFactory;
import com.google.gson.reflect.TypeToken;
import com.google.gson.TypeAdapter;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;

import java.lang.reflect.Type;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Map.Entry;
import java.util.Set;

import com.finbourne.lusid.JSON;

/**
 * Event representing the partial closure of a repurchase   agreement. Each event reduces the outstanding notional   and generates a corresponding receive-leg cashflow. The   final maturity cashflow is adjusted accordingly.    If multiple events are created, their effects compound.   Once the total repaid amount reaches the original purchase   price, no further receive-leg cashflows are generated. Any   event exceeding the remaining notional is marked with a   diagnostic to indicate it is invalid due to excessive repayment.    For example, for a repo with a 5% rate, 1% haircut and   collateral value of 100 (purchase price &#x3D; 99), a partial   closure of cash amount 10 followed by one of 100 results in   only the first event producing a cashflow. The second,   exceeding the remaining balance, is ignored and flagged   with a diagnostic. The remaining balance is settled at   maturity of the repurchase agreement.
 */
@jakarta.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen")
public class RepoPartialClosureEvent extends InstrumentEvent {
  public static final String SERIALIZED_NAME_ENTITLEMENT_DATE = "entitlementDate";
  @SerializedName(SERIALIZED_NAME_ENTITLEMENT_DATE)
  private OffsetDateTime entitlementDate;

  public static final String SERIALIZED_NAME_SETTLEMENT_DATE = "settlementDate";
  @SerializedName(SERIALIZED_NAME_SETTLEMENT_DATE)
  private OffsetDateTime settlementDate;

  public static final String SERIALIZED_NAME_CASH_AMOUNT = "cashAmount";
  @SerializedName(SERIALIZED_NAME_CASH_AMOUNT)
  private java.math.BigDecimal cashAmount;

  public static final String SERIALIZED_NAME_CASH_PERCENTAGE = "cashPercentage";
  @SerializedName(SERIALIZED_NAME_CASH_PERCENTAGE)
  private java.math.BigDecimal cashPercentage;

  public RepoPartialClosureEvent() {
    // this.instrumentEventType = this.getClass().getSimpleName();
  }

  public RepoPartialClosureEvent entitlementDate(OffsetDateTime entitlementDate) {
    
    this.entitlementDate = entitlementDate;
    return this;
  }

   /**
   * The date on which the counterparties become entitled   to exchange cash as part of a partial closure of the   repurchase agreement. The date must be before or on   the settlement date, and on or before the maturity   date of the repo. This is a required field.
   * @return entitlementDate
  **/
  @jakarta.annotation.Nullable
  public OffsetDateTime getEntitlementDate() {
    return entitlementDate;
  }


  public void setEntitlementDate(OffsetDateTime entitlementDate) {
    this.entitlementDate = entitlementDate;
  }


  public RepoPartialClosureEvent settlementDate(OffsetDateTime settlementDate) {
    
    this.settlementDate = settlementDate;
    return this;
  }

   /**
   * The date on which the exchange of cash is settled.   The date must be on or after the entitlement date,  and on or before the maturity date of the repo.   This is a required field.
   * @return settlementDate
  **/
  @jakarta.annotation.Nullable
  public OffsetDateTime getSettlementDate() {
    return settlementDate;
  }


  public void setSettlementDate(OffsetDateTime settlementDate) {
    this.settlementDate = settlementDate;
  }


  public RepoPartialClosureEvent cashAmount(java.math.BigDecimal cashAmount) {
    
    this.cashAmount = cashAmount;
    return this;
  }

   /**
   * The amount of cash to be exchanged as part of   a partial closure of the repurchase agreement.  It cannot be more than the initial amount of   cash at the start of the repo.
   * @return cashAmount
  **/
  @jakarta.annotation.Nullable
  public java.math.BigDecimal getCashAmount() {
    return cashAmount;
  }


  public void setCashAmount(java.math.BigDecimal cashAmount) {
    this.cashAmount = cashAmount;
  }


  public RepoPartialClosureEvent cashPercentage(java.math.BigDecimal cashPercentage) {
    
    this.cashPercentage = cashPercentage;
    return this;
  }

   /**
   * Represents the proportion of cash exchanged, as   a value between 0 and 1, relative to the total   cash involved in the repurchase agreement.  This value adjusts with each partial closure,   because the total cash amount is reduced.
   * @return cashPercentage
  **/
  @jakarta.annotation.Nullable
  public java.math.BigDecimal getCashPercentage() {
    return cashPercentage;
  }


  public void setCashPercentage(java.math.BigDecimal cashPercentage) {
    this.cashPercentage = cashPercentage;
  }



  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    RepoPartialClosureEvent repoPartialClosureEvent = (RepoPartialClosureEvent) o;
    return Objects.equals(this.entitlementDate, repoPartialClosureEvent.entitlementDate) &&
        Objects.equals(this.settlementDate, repoPartialClosureEvent.settlementDate) &&
        (this.cashAmount.compareTo(repoPartialClosureEvent.getCashAmount()) == 0) &&
        (this.cashPercentage.compareTo(repoPartialClosureEvent.getCashPercentage()) == 0) &&
        super.equals(o);
  }

  private static <T> boolean equalsNullable(JsonNullable<T> a, JsonNullable<T> b) {
    return a == b || (a != null && b != null && a.isPresent() && b.isPresent() && Objects.deepEquals(a.get(), b.get()));
  }

  @Override
  public int hashCode() {
    return Objects.hash(entitlementDate, settlementDate, cashAmount, cashPercentage, super.hashCode());
  }

  private static <T> int hashCodeNullable(JsonNullable<T> a) {
    if (a == null) {
      return 1;
    }
    return a.isPresent() ? Arrays.deepHashCode(new Object[]{a.get()}) : 31;
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class RepoPartialClosureEvent {\n");
    sb.append("    ").append(toIndentedString(super.toString())).append("\n");
    sb.append("    entitlementDate: ").append(toIndentedString(entitlementDate)).append("\n");
    sb.append("    settlementDate: ").append(toIndentedString(settlementDate)).append("\n");
    sb.append("    cashAmount: ").append(toIndentedString(cashAmount)).append("\n");
    sb.append("    cashPercentage: ").append(toIndentedString(cashPercentage)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }


  public static HashSet<String> openapiFields;
  public static HashSet<String> openapiRequiredFields;

  static {
    // a set of all properties/fields (JSON key names)
    openapiFields = new HashSet<String>();
    openapiFields.add("instrumentEventType");
    openapiFields.add("entitlementDate");
    openapiFields.add("settlementDate");
    openapiFields.add("cashAmount");
    openapiFields.add("cashPercentage");

    // a set of required properties/fields (JSON key names)
    openapiRequiredFields = new HashSet<String>();
    openapiRequiredFields.add("instrumentEventType");
  }

 /**
  * Validates the JSON Element and throws an exception if issues found
  *
  * @param jsonElement JSON Element
  * @throws IOException if the JSON Element is invalid with respect to RepoPartialClosureEvent
  */
  public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      if (jsonElement == null) {
        if (!RepoPartialClosureEvent.openapiRequiredFields.isEmpty()) { // has required fields but JSON element is null
          throw new IllegalArgumentException(String.format("The required field(s) %s in RepoPartialClosureEvent is not found in the empty JSON string", RepoPartialClosureEvent.openapiRequiredFields.toString()));
        }
      }

      // check to make sure all required properties/fields are present in the JSON string
      for (String requiredField : RepoPartialClosureEvent.openapiRequiredFields) {
        if (jsonElement.getAsJsonObject().get(requiredField) == null) {
          throw new IllegalArgumentException(String.format("The required field `%s` is not found in the JSON string: %s", requiredField, jsonElement.toString()));
        }
      }
  }

  public static class CustomTypeAdapterFactory implements TypeAdapterFactory {
    @SuppressWarnings("unchecked")
    @Override
    public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {
       if (!RepoPartialClosureEvent.class.isAssignableFrom(type.getRawType())) {
         return null; // this class only serializes 'RepoPartialClosureEvent' and its subtypes
       }
       final TypeAdapter<JsonElement> elementAdapter = gson.getAdapter(JsonElement.class);
       final TypeAdapter<RepoPartialClosureEvent> thisAdapter
                        = gson.getDelegateAdapter(this, TypeToken.get(RepoPartialClosureEvent.class));

       return (TypeAdapter<T>) new TypeAdapter<RepoPartialClosureEvent>() {
           @Override
           public void write(JsonWriter out, RepoPartialClosureEvent value) throws IOException {
             JsonObject obj = thisAdapter.toJsonTree(value).getAsJsonObject();
             elementAdapter.write(out, obj);
           }

           @Override
           public RepoPartialClosureEvent read(JsonReader in) throws IOException {
             JsonElement jsonElement = elementAdapter.read(in);
             validateJsonElement(jsonElement);
             return thisAdapter.fromJsonTree(jsonElement);
           }

       }.nullSafe();
    }
  }

 /**
  * Create an instance of RepoPartialClosureEvent given an JSON string
  *
  * @param jsonString JSON string
  * @return An instance of RepoPartialClosureEvent
  * @throws IOException if the JSON string is invalid with respect to RepoPartialClosureEvent
  */
  public static RepoPartialClosureEvent fromJson(String jsonString) throws IOException {
    return JSON.getGson().fromJson(jsonString, RepoPartialClosureEvent.class);
  }

 /**
  * Convert an instance of RepoPartialClosureEvent to an JSON string
  *
  * @return JSON string
  */
  public String toJson() {
    return JSON.getGson().toJson(this);
  }
}
