/*
 * LUSID API
 *
 * Contact: info@finbourne.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

package com.finbourne.lusid.model;

import java.util.Objects;
import com.finbourne.lusid.model.LusidInstrument;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;
import java.time.OffsetDateTime;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import org.openapitools.jackson.nullable.JsonNullable;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonArray;
import com.google.gson.JsonDeserializationContext;
import com.google.gson.JsonDeserializer;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParseException;
import com.google.gson.TypeAdapterFactory;
import com.google.gson.reflect.TypeToken;
import com.google.gson.TypeAdapter;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;

import java.lang.reflect.Type;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Map.Entry;
import java.util.Set;

import com.finbourne.lusid.JSON;

/**
 * LUSID representation of a sale and repurchase agreement, supporting haircut, margin or repo rate methods.
 */
@jakarta.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen")
public class Repo extends LusidInstrument {
  public static final String SERIALIZED_NAME_START_DATE = "startDate";
  @SerializedName(SERIALIZED_NAME_START_DATE)
  private OffsetDateTime startDate;

  public static final String SERIALIZED_NAME_MATURITY_DATE = "maturityDate";
  @SerializedName(SERIALIZED_NAME_MATURITY_DATE)
  private OffsetDateTime maturityDate;

  public static final String SERIALIZED_NAME_DOM_CCY = "domCcy";
  @SerializedName(SERIALIZED_NAME_DOM_CCY)
  private String domCcy;

  public static final String SERIALIZED_NAME_ACCRUAL_BASIS = "accrualBasis";
  @SerializedName(SERIALIZED_NAME_ACCRUAL_BASIS)
  private String accrualBasis;

  public static final String SERIALIZED_NAME_COLLATERAL = "collateral";
  @SerializedName(SERIALIZED_NAME_COLLATERAL)
  private List<LusidInstrument> collateral;

  public static final String SERIALIZED_NAME_COLLATERAL_VALUE = "collateralValue";
  @SerializedName(SERIALIZED_NAME_COLLATERAL_VALUE)
  private java.math.BigDecimal collateralValue;

  public static final String SERIALIZED_NAME_HAIRCUT = "haircut";
  @SerializedName(SERIALIZED_NAME_HAIRCUT)
  private java.math.BigDecimal haircut;

  public static final String SERIALIZED_NAME_MARGIN = "margin";
  @SerializedName(SERIALIZED_NAME_MARGIN)
  private java.math.BigDecimal margin;

  public static final String SERIALIZED_NAME_PURCHASE_PRICE = "purchasePrice";
  @SerializedName(SERIALIZED_NAME_PURCHASE_PRICE)
  private java.math.BigDecimal purchasePrice;

  public static final String SERIALIZED_NAME_REPO_RATE = "repoRate";
  @SerializedName(SERIALIZED_NAME_REPO_RATE)
  private java.math.BigDecimal repoRate;

  public static final String SERIALIZED_NAME_REPURCHASE_PRICE = "repurchasePrice";
  @SerializedName(SERIALIZED_NAME_REPURCHASE_PRICE)
  private java.math.BigDecimal repurchasePrice;

  public Repo() {
    // this.instrumentType = this.getClass().getSimpleName();
  }

  public Repo startDate(OffsetDateTime startDate) {
    
    this.startDate = startDate;
    return this;
  }

   /**
   * The start date of the instrument. This is normally synonymous with the trade-date.
   * @return startDate
  **/
  @jakarta.annotation.Nonnull
  public OffsetDateTime getStartDate() {
    return startDate;
  }


  public void setStartDate(OffsetDateTime startDate) {
    this.startDate = startDate;
  }


  public Repo maturityDate(OffsetDateTime maturityDate) {
    
    this.maturityDate = maturityDate;
    return this;
  }

   /**
   * The final maturity date of the instrument. This means the last date on which the instruments makes a payment of any amount.  For the avoidance of doubt, that is not necessarily prior to its last sensitivity date for the purposes of risk; e.g. instruments such as  Constant Maturity Swaps (CMS) often have sensitivities to rates that may well be observed or set prior to the maturity date, but refer to a termination date beyond it.
   * @return maturityDate
  **/
  @jakarta.annotation.Nonnull
  public OffsetDateTime getMaturityDate() {
    return maturityDate;
  }


  public void setMaturityDate(OffsetDateTime maturityDate) {
    this.maturityDate = maturityDate;
  }


  public Repo domCcy(String domCcy) {
    
    this.domCcy = domCcy;
    return this;
  }

   /**
   * The domestic currency of the instrument.
   * @return domCcy
  **/
  @jakarta.annotation.Nonnull
  public String getDomCcy() {
    return domCcy;
  }


  public void setDomCcy(String domCcy) {
    this.domCcy = domCcy;
  }


  public Repo accrualBasis(String accrualBasis) {
    
    this.accrualBasis = accrualBasis;
    return this;
  }

   /**
   * For calculation of interest, the accrual basis to be used.  For more information on day counts, see [knowledge base article KA-01798](https://support.lusid.com/knowledgebase/article/KA-01798)                Supported string (enumeration) values are: [Actual360, Act360, MoneyMarket, Actual365, Act365, Thirty360, ThirtyU360, Bond, ThirtyE360, EuroBond, ActualActual, ActAct, ActActIsda, ActActIsma, ActActIcma, OneOne, Act364, Act365F, Act365L, Act365_25, Act252, Bus252, NL360, NL365, ActActAFB, Act365Cad, ThirtyActIsda, Thirty365Isda, ThirtyEActIsda, ThirtyE360Isda, ThirtyE365Isda, ThirtyU360EOM].
   * @return accrualBasis
  **/
  @jakarta.annotation.Nonnull
  public String getAccrualBasis() {
    return accrualBasis;
  }


  public void setAccrualBasis(String accrualBasis) {
    this.accrualBasis = accrualBasis;
  }


  public Repo collateral(List<LusidInstrument> collateral) {
    
    this.collateral = collateral;
    return this;
  }

  public Repo addCollateralItem(LusidInstrument collateralItem) {
    if (this.collateral == null) {
      this.collateral = new ArrayList<>();
    }
    this.collateral.add(collateralItem);
    return this;
  }

   /**
   * The actual collateral in the Repo.  This property is for informational purposes only, Lusid pricing is not affected.
   * @return collateral
  **/
  @jakarta.annotation.Nullable
  public List<LusidInstrument> getCollateral() {
    return collateral;
  }


  public void setCollateral(List<LusidInstrument> collateral) {
    this.collateral = collateral;
  }


  public Repo collateralValue(java.math.BigDecimal collateralValue) {
    
    this.collateralValue = collateralValue;
    return this;
  }

   /**
   * The full market value of the collateral in domestic currency, before any margin or haircut is applied.
   * @return collateralValue
  **/
  @jakarta.annotation.Nullable
  public java.math.BigDecimal getCollateralValue() {
    return collateralValue;
  }


  public void setCollateralValue(java.math.BigDecimal collateralValue) {
    this.collateralValue = collateralValue;
  }


  public Repo haircut(java.math.BigDecimal haircut) {
    
    this.haircut = haircut;
    return this;
  }

   /**
   * The haircut (or margin percentage) applied to the collateral, this should be a number between 0 and 1, i.e. for a 5% haircut this should be 0.05.  This is defined as (CollateralValue - PurchasePrice) / CollateralValue.  If this property is specified, so too must CollateralValue.  While this property is optional, one, and only one, of PurchasePrice, Margin and Haircut must be specified.
   * @return haircut
  **/
  @jakarta.annotation.Nullable
  public java.math.BigDecimal getHaircut() {
    return haircut;
  }


  public void setHaircut(java.math.BigDecimal haircut) {
    this.haircut = haircut;
  }


  public Repo margin(java.math.BigDecimal margin) {
    
    this.margin = margin;
    return this;
  }

   /**
   * The initial margin (or margin ratio) applied to the collateral, this should be a number greater than or equal to 1.0,  i.e. for a 102% margin this should be 1.02. A value of 1.0 means no margin (100%).  This is defined as CollateralValue / PurchasePrice.  If this property is specified, so too must CollateralValue.  While this property is optional, one, and only one, of PurchasePrice, Margin and Haircut must be specified.
   * @return margin
  **/
  @jakarta.annotation.Nullable
  public java.math.BigDecimal getMargin() {
    return margin;
  }


  public void setMargin(java.math.BigDecimal margin) {
    this.margin = margin;
  }


  public Repo purchasePrice(java.math.BigDecimal purchasePrice) {
    
    this.purchasePrice = purchasePrice;
    return this;
  }

   /**
   * The price the collateral is initially purchased for, this property can be used to explicitly set the purchase price and not require  collateral value and a margin or haircut.  While this property is optional, one, and only one, of PurchasePrice, Margin and Haircut must be specified.
   * @return purchasePrice
  **/
  @jakarta.annotation.Nullable
  public java.math.BigDecimal getPurchasePrice() {
    return purchasePrice;
  }


  public void setPurchasePrice(java.math.BigDecimal purchasePrice) {
    this.purchasePrice = purchasePrice;
  }


  public Repo repoRate(java.math.BigDecimal repoRate) {
    
    this.repoRate = repoRate;
    return this;
  }

   /**
   * The rate at which interest is to be accrue and be paid upon redemption of the collateral at maturity.  This field is used to calculate the Repurchase price.  While this property is optional, one, and only one, of the RepoRate and RepurchasePrice must be specified.
   * @return repoRate
  **/
  @jakarta.annotation.Nullable
  public java.math.BigDecimal getRepoRate() {
    return repoRate;
  }


  public void setRepoRate(java.math.BigDecimal repoRate) {
    this.repoRate = repoRate;
  }


  public Repo repurchasePrice(java.math.BigDecimal repurchasePrice) {
    
    this.repurchasePrice = repurchasePrice;
    return this;
  }

   /**
   * The price at which the collateral is repurchased, this field is optional and can be explicitly set here or will be calculated  from the PurchasePrice and RepoRate.  One, and only one, of the RepoRate and RepurchasePrice must be specified.
   * @return repurchasePrice
  **/
  @jakarta.annotation.Nullable
  public java.math.BigDecimal getRepurchasePrice() {
    return repurchasePrice;
  }


  public void setRepurchasePrice(java.math.BigDecimal repurchasePrice) {
    this.repurchasePrice = repurchasePrice;
  }



  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    Repo repo = (Repo) o;
    return Objects.equals(this.startDate, repo.startDate) &&
        Objects.equals(this.maturityDate, repo.maturityDate) &&
        Objects.equals(this.domCcy, repo.domCcy) &&
        Objects.equals(this.accrualBasis, repo.accrualBasis) &&
        Objects.equals(this.collateral, repo.collateral) &&
        (this.collateralValue.compareTo(repo.getCollateralValue()) == 0) &&
        (this.haircut.compareTo(repo.getHaircut()) == 0) &&
        (this.margin.compareTo(repo.getMargin()) == 0) &&
        (this.purchasePrice.compareTo(repo.getPurchasePrice()) == 0) &&
        (this.repoRate.compareTo(repo.getRepoRate()) == 0) &&
        (this.repurchasePrice.compareTo(repo.getRepurchasePrice()) == 0) &&
        super.equals(o);
  }

  private static <T> boolean equalsNullable(JsonNullable<T> a, JsonNullable<T> b) {
    return a == b || (a != null && b != null && a.isPresent() && b.isPresent() && Objects.deepEquals(a.get(), b.get()));
  }

  @Override
  public int hashCode() {
    return Objects.hash(startDate, maturityDate, domCcy, accrualBasis, collateral, collateralValue, haircut, margin, purchasePrice, repoRate, repurchasePrice, super.hashCode());
  }

  private static <T> int hashCodeNullable(JsonNullable<T> a) {
    if (a == null) {
      return 1;
    }
    return a.isPresent() ? Arrays.deepHashCode(new Object[]{a.get()}) : 31;
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class Repo {\n");
    sb.append("    ").append(toIndentedString(super.toString())).append("\n");
    sb.append("    startDate: ").append(toIndentedString(startDate)).append("\n");
    sb.append("    maturityDate: ").append(toIndentedString(maturityDate)).append("\n");
    sb.append("    domCcy: ").append(toIndentedString(domCcy)).append("\n");
    sb.append("    accrualBasis: ").append(toIndentedString(accrualBasis)).append("\n");
    sb.append("    collateral: ").append(toIndentedString(collateral)).append("\n");
    sb.append("    collateralValue: ").append(toIndentedString(collateralValue)).append("\n");
    sb.append("    haircut: ").append(toIndentedString(haircut)).append("\n");
    sb.append("    margin: ").append(toIndentedString(margin)).append("\n");
    sb.append("    purchasePrice: ").append(toIndentedString(purchasePrice)).append("\n");
    sb.append("    repoRate: ").append(toIndentedString(repoRate)).append("\n");
    sb.append("    repurchasePrice: ").append(toIndentedString(repurchasePrice)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }


  public static HashSet<String> openapiFields;
  public static HashSet<String> openapiRequiredFields;

  static {
    // a set of all properties/fields (JSON key names)
    openapiFields = new HashSet<String>();
    openapiFields.add("instrumentType");
    openapiFields.add("startDate");
    openapiFields.add("maturityDate");
    openapiFields.add("domCcy");
    openapiFields.add("accrualBasis");
    openapiFields.add("collateral");
    openapiFields.add("collateralValue");
    openapiFields.add("haircut");
    openapiFields.add("margin");
    openapiFields.add("purchasePrice");
    openapiFields.add("repoRate");
    openapiFields.add("repurchasePrice");

    // a set of required properties/fields (JSON key names)
    openapiRequiredFields = new HashSet<String>();
    openapiRequiredFields.add("startDate");
    openapiRequiredFields.add("maturityDate");
    openapiRequiredFields.add("domCcy");
    openapiRequiredFields.add("accrualBasis");
    openapiRequiredFields.add("instrumentType");
  }

 /**
  * Validates the JSON Object and throws an exception if issues found
  *
  * @param jsonObj JSON Object
  * @throws IOException if the JSON Object is invalid with respect to Repo
  */
  public static void validateJsonObject(JsonObject jsonObj) throws IOException {
      if (jsonObj == null) {
        if (!Repo.openapiRequiredFields.isEmpty()) { // has required fields but JSON object is null
          throw new IllegalArgumentException(String.format("The required field(s) %s in Repo is not found in the empty JSON string", Repo.openapiRequiredFields.toString()));
        }
      }

      Set<Entry<String, JsonElement>> entries = jsonObj.entrySet();
      // check to see if the JSON string contains additional fields
      for (Entry<String, JsonElement> entry : entries) {
        if (!Repo.openapiFields.contains(entry.getKey())) {
          throw new IllegalArgumentException(String.format("The field `%s` in the JSON string is not defined in the `Repo` properties. JSON: %s", entry.getKey(), jsonObj.toString()));
        }
      }

      // check to make sure all required properties/fields are present in the JSON string
      for (String requiredField : Repo.openapiRequiredFields) {
        if (jsonObj.get(requiredField) == null) {
          throw new IllegalArgumentException(String.format("The required field `%s` is not found in the JSON string: %s", requiredField, jsonObj.toString()));
        }
      }
  }

  public static class CustomTypeAdapterFactory implements TypeAdapterFactory {
    @SuppressWarnings("unchecked")
    @Override
    public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {
       if (!Repo.class.isAssignableFrom(type.getRawType())) {
         return null; // this class only serializes 'Repo' and its subtypes
       }
       final TypeAdapter<JsonElement> elementAdapter = gson.getAdapter(JsonElement.class);
       final TypeAdapter<Repo> thisAdapter
                        = gson.getDelegateAdapter(this, TypeToken.get(Repo.class));

       return (TypeAdapter<T>) new TypeAdapter<Repo>() {
           @Override
           public void write(JsonWriter out, Repo value) throws IOException {
             JsonObject obj = thisAdapter.toJsonTree(value).getAsJsonObject();
             elementAdapter.write(out, obj);
           }

           @Override
           public Repo read(JsonReader in) throws IOException {
             JsonObject jsonObj = elementAdapter.read(in).getAsJsonObject();
             validateJsonObject(jsonObj);
             return thisAdapter.fromJsonTree(jsonObj);
           }

       }.nullSafe();
    }
  }

 /**
  * Create an instance of Repo given an JSON string
  *
  * @param jsonString JSON string
  * @return An instance of Repo
  * @throws IOException if the JSON string is invalid with respect to Repo
  */
  public static Repo fromJson(String jsonString) throws IOException {
    return JSON.getGson().fromJson(jsonString, Repo.class);
  }

 /**
  * Convert an instance of Repo to an JSON string
  *
  * @return JSON string
  */
  public String toJson() {
    return JSON.getGson().toJson(this);
  }
}
