/*
 * LUSID API
 *
 * Contact: info@finbourne.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

package com.finbourne.lusid.model;

import java.util.Objects;
import com.finbourne.lusid.model.Compounding;
import com.finbourne.lusid.model.FlowConventionName;
import com.finbourne.lusid.model.FlowConventions;
import com.finbourne.lusid.model.IndexConvention;
import com.finbourne.lusid.model.StepSchedule;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;
import java.time.OffsetDateTime;
import java.util.Arrays;
import org.openapitools.jackson.nullable.JsonNullable;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonArray;
import com.google.gson.JsonDeserializationContext;
import com.google.gson.JsonDeserializer;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParseException;
import com.google.gson.TypeAdapterFactory;
import com.google.gson.reflect.TypeToken;
import com.google.gson.TypeAdapter;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;

import java.lang.reflect.Type;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Map.Entry;
import java.util.Set;

import com.finbourne.lusid.JSON;

/**
 * Definition of the set of flow and index conventions along with other miscellaneous information required to generate an instrument leg.
 */
@jakarta.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen")
public class LegDefinition {
  public static final String SERIALIZED_NAME_CONVENTION_NAME = "conventionName";
  @SerializedName(SERIALIZED_NAME_CONVENTION_NAME)
  private FlowConventionName conventionName;

  public static final String SERIALIZED_NAME_CONVENTIONS = "conventions";
  @SerializedName(SERIALIZED_NAME_CONVENTIONS)
  private FlowConventions conventions;

  public static final String SERIALIZED_NAME_INDEX_CONVENTION = "indexConvention";
  @SerializedName(SERIALIZED_NAME_INDEX_CONVENTION)
  private IndexConvention indexConvention;

  public static final String SERIALIZED_NAME_INDEX_CONVENTION_NAME = "indexConventionName";
  @SerializedName(SERIALIZED_NAME_INDEX_CONVENTION_NAME)
  private FlowConventionName indexConventionName;

  public static final String SERIALIZED_NAME_NOTIONAL_EXCHANGE_TYPE = "notionalExchangeType";
  @SerializedName(SERIALIZED_NAME_NOTIONAL_EXCHANGE_TYPE)
  private String notionalExchangeType;

  public static final String SERIALIZED_NAME_PAY_RECEIVE = "payReceive";
  @SerializedName(SERIALIZED_NAME_PAY_RECEIVE)
  private String payReceive;

  public static final String SERIALIZED_NAME_RATE_OR_SPREAD = "rateOrSpread";
  @SerializedName(SERIALIZED_NAME_RATE_OR_SPREAD)
  private java.math.BigDecimal rateOrSpread;

  public static final String SERIALIZED_NAME_RESET_CONVENTION = "resetConvention";
  @SerializedName(SERIALIZED_NAME_RESET_CONVENTION)
  private String resetConvention;

  public static final String SERIALIZED_NAME_STUB_TYPE = "stubType";
  @SerializedName(SERIALIZED_NAME_STUB_TYPE)
  private String stubType;

  public static final String SERIALIZED_NAME_COMPOUNDING = "compounding";
  @SerializedName(SERIALIZED_NAME_COMPOUNDING)
  private Compounding compounding;

  public static final String SERIALIZED_NAME_AMORTISATION = "amortisation";
  @SerializedName(SERIALIZED_NAME_AMORTISATION)
  private StepSchedule amortisation;

  public static final String SERIALIZED_NAME_FIRST_REGULAR_PAYMENT_DATE = "firstRegularPaymentDate";
  @SerializedName(SERIALIZED_NAME_FIRST_REGULAR_PAYMENT_DATE)
  private OffsetDateTime firstRegularPaymentDate;

  public static final String SERIALIZED_NAME_FIRST_COUPON_TYPE = "firstCouponType";
  @SerializedName(SERIALIZED_NAME_FIRST_COUPON_TYPE)
  private String firstCouponType;

  public static final String SERIALIZED_NAME_LAST_REGULAR_PAYMENT_DATE = "lastRegularPaymentDate";
  @SerializedName(SERIALIZED_NAME_LAST_REGULAR_PAYMENT_DATE)
  private OffsetDateTime lastRegularPaymentDate;

  public static final String SERIALIZED_NAME_LAST_COUPON_TYPE = "lastCouponType";
  @SerializedName(SERIALIZED_NAME_LAST_COUPON_TYPE)
  private String lastCouponType;

  public LegDefinition() {
  }

  public LegDefinition conventionName(FlowConventionName conventionName) {
    
    this.conventionName = conventionName;
    return this;
  }

   /**
   * Get conventionName
   * @return conventionName
  **/
  @jakarta.annotation.Nullable
  public FlowConventionName getConventionName() {
    return conventionName;
  }


  public void setConventionName(FlowConventionName conventionName) {
    this.conventionName = conventionName;
  }


  public LegDefinition conventions(FlowConventions conventions) {
    
    this.conventions = conventions;
    return this;
  }

   /**
   * Get conventions
   * @return conventions
  **/
  @jakarta.annotation.Nullable
  public FlowConventions getConventions() {
    return conventions;
  }


  public void setConventions(FlowConventions conventions) {
    this.conventions = conventions;
  }


  public LegDefinition indexConvention(IndexConvention indexConvention) {
    
    this.indexConvention = indexConvention;
    return this;
  }

   /**
   * Get indexConvention
   * @return indexConvention
  **/
  @jakarta.annotation.Nullable
  public IndexConvention getIndexConvention() {
    return indexConvention;
  }


  public void setIndexConvention(IndexConvention indexConvention) {
    this.indexConvention = indexConvention;
  }


  public LegDefinition indexConventionName(FlowConventionName indexConventionName) {
    
    this.indexConventionName = indexConventionName;
    return this;
  }

   /**
   * Get indexConventionName
   * @return indexConventionName
  **/
  @jakarta.annotation.Nullable
  public FlowConventionName getIndexConventionName() {
    return indexConventionName;
  }


  public void setIndexConventionName(FlowConventionName indexConventionName) {
    this.indexConventionName = indexConventionName;
  }


  public LegDefinition notionalExchangeType(String notionalExchangeType) {
    
    this.notionalExchangeType = notionalExchangeType;
    return this;
  }

   /**
   * what type of notional exchange does the leg have    Supported string (enumeration) values are: [None, Initial, Final, Both].
   * @return notionalExchangeType
  **/
  @jakarta.annotation.Nonnull
  public String getNotionalExchangeType() {
    return notionalExchangeType;
  }


  public void setNotionalExchangeType(String notionalExchangeType) {
    this.notionalExchangeType = notionalExchangeType;
  }


  public LegDefinition payReceive(String payReceive) {
    
    this.payReceive = payReceive;
    return this;
  }

   /**
   * Is the leg to be paid or received    Supported string (enumeration) values are: [Pay, Receive].
   * @return payReceive
  **/
  @jakarta.annotation.Nonnull
  public String getPayReceive() {
    return payReceive;
  }


  public void setPayReceive(String payReceive) {
    this.payReceive = payReceive;
  }


  public LegDefinition rateOrSpread(java.math.BigDecimal rateOrSpread) {
    
    this.rateOrSpread = rateOrSpread;
    return this;
  }

   /**
   * Is there either a fixed rate (non-zero) or spread to be paid over the value of the leg.
   * @return rateOrSpread
  **/
  @jakarta.annotation.Nonnull
  public java.math.BigDecimal getRateOrSpread() {
    return rateOrSpread;
  }


  public void setRateOrSpread(java.math.BigDecimal rateOrSpread) {
    this.rateOrSpread = rateOrSpread;
  }


  public LegDefinition resetConvention(String resetConvention) {
    
    this.resetConvention = resetConvention;
    return this;
  }

   /**
   * Control how resets are generated relative to swap payment convention(s).    Supported string (enumeration) values are: [InAdvance, InArrears].
   * @return resetConvention
  **/
  @jakarta.annotation.Nullable
  public String getResetConvention() {
    return resetConvention;
  }


  public void setResetConvention(String resetConvention) {
    this.resetConvention = resetConvention;
  }


  public LegDefinition stubType(String stubType) {
    
    this.stubType = stubType;
    return this;
  }

   /**
   * If a stub is required should it be at the front or back of the leg.    Supported string (enumeration) values are: [None, ShortFront, ShortBack, LongBack, LongFront, Both].
   * @return stubType
  **/
  @jakarta.annotation.Nonnull
  public String getStubType() {
    return stubType;
  }


  public void setStubType(String stubType) {
    this.stubType = stubType;
  }


  public LegDefinition compounding(Compounding compounding) {
    
    this.compounding = compounding;
    return this;
  }

   /**
   * Get compounding
   * @return compounding
  **/
  @jakarta.annotation.Nullable
  public Compounding getCompounding() {
    return compounding;
  }


  public void setCompounding(Compounding compounding) {
    this.compounding = compounding;
  }


  public LegDefinition amortisation(StepSchedule amortisation) {
    
    this.amortisation = amortisation;
    return this;
  }

   /**
   * Get amortisation
   * @return amortisation
  **/
  @jakarta.annotation.Nullable
  public StepSchedule getAmortisation() {
    return amortisation;
  }


  public void setAmortisation(StepSchedule amortisation) {
    this.amortisation = amortisation;
  }


  public LegDefinition firstRegularPaymentDate(OffsetDateTime firstRegularPaymentDate) {
    
    this.firstRegularPaymentDate = firstRegularPaymentDate;
    return this;
  }

   /**
   * Optional payment date of the first regular coupon.  Must be greater than the StartDate.  If set, the regular coupon schedule will be built such that the first regular coupon  will end on this date. The start date of this coupon will be calculated as normal and  a stub coupon will be created from the StartDate to the start of the first regular coupon.
   * @return firstRegularPaymentDate
  **/
  @jakarta.annotation.Nullable
  public OffsetDateTime getFirstRegularPaymentDate() {
    return firstRegularPaymentDate;
  }


  public void setFirstRegularPaymentDate(OffsetDateTime firstRegularPaymentDate) {
    this.firstRegularPaymentDate = firstRegularPaymentDate;
  }


  public LegDefinition firstCouponType(String firstCouponType) {
    
    this.firstCouponType = firstCouponType;
    return this;
  }

   /**
   * Optional coupon type setting for the first coupon, can be used with Stub coupons.  If set to \&quot;ProRata\&quot; (the default), the coupon year fraction is calculated as normal,  however if set to \&quot;Full\&quot; the year fraction is overwritten with the standard year fraction  for a regular ful\&quot; coupon. Note this does not use the day count convention but rather is defined  directly from the tenor (i.e. a quarterly leg will be set to 0.25).    Supported string (enumeration) values are: [ProRata, Full].
   * @return firstCouponType
  **/
  @jakarta.annotation.Nullable
  public String getFirstCouponType() {
    return firstCouponType;
  }


  public void setFirstCouponType(String firstCouponType) {
    this.firstCouponType = firstCouponType;
  }


  public LegDefinition lastRegularPaymentDate(OffsetDateTime lastRegularPaymentDate) {
    
    this.lastRegularPaymentDate = lastRegularPaymentDate;
    return this;
  }

   /**
   * Optional payment date of the last regular coupon.  Must be less than the Maturity date.  If set, the regular coupon schedule will be built up to this date and the final  coupon will be a stub between this date and the Maturity date.
   * @return lastRegularPaymentDate
  **/
  @jakarta.annotation.Nullable
  public OffsetDateTime getLastRegularPaymentDate() {
    return lastRegularPaymentDate;
  }


  public void setLastRegularPaymentDate(OffsetDateTime lastRegularPaymentDate) {
    this.lastRegularPaymentDate = lastRegularPaymentDate;
  }


  public LegDefinition lastCouponType(String lastCouponType) {
    
    this.lastCouponType = lastCouponType;
    return this;
  }

   /**
   * Optional coupon type setting for the last coupon, can be used with Stub coupons.  If set to \&quot;ProRata\&quot; (the default), the coupon year fraction is calculated as normal,  however if set to \&quot;Full\&quot; the year fraction is overwritten with the standard year fraction  for a regular ful\&quot; coupon. Note this does not use the day count convention but rather is defined  directly from the tenor (i.e. a quarterly leg will be set to 0.25).    Supported string (enumeration) values are: [ProRata, Full].
   * @return lastCouponType
  **/
  @jakarta.annotation.Nullable
  public String getLastCouponType() {
    return lastCouponType;
  }


  public void setLastCouponType(String lastCouponType) {
    this.lastCouponType = lastCouponType;
  }



  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    LegDefinition legDefinition = (LegDefinition) o;
    return Objects.equals(this.conventionName, legDefinition.conventionName) &&
        Objects.equals(this.conventions, legDefinition.conventions) &&
        Objects.equals(this.indexConvention, legDefinition.indexConvention) &&
        Objects.equals(this.indexConventionName, legDefinition.indexConventionName) &&
        Objects.equals(this.notionalExchangeType, legDefinition.notionalExchangeType) &&
        Objects.equals(this.payReceive, legDefinition.payReceive) &&
        (this.rateOrSpread.compareTo(legDefinition.getRateOrSpread()) == 0) &&
        Objects.equals(this.resetConvention, legDefinition.resetConvention) &&
        Objects.equals(this.stubType, legDefinition.stubType) &&
        Objects.equals(this.compounding, legDefinition.compounding) &&
        Objects.equals(this.amortisation, legDefinition.amortisation) &&
        Objects.equals(this.firstRegularPaymentDate, legDefinition.firstRegularPaymentDate) &&
        Objects.equals(this.firstCouponType, legDefinition.firstCouponType) &&
        Objects.equals(this.lastRegularPaymentDate, legDefinition.lastRegularPaymentDate) &&
        Objects.equals(this.lastCouponType, legDefinition.lastCouponType);
  }

  private static <T> boolean equalsNullable(JsonNullable<T> a, JsonNullable<T> b) {
    return a == b || (a != null && b != null && a.isPresent() && b.isPresent() && Objects.deepEquals(a.get(), b.get()));
  }

  @Override
  public int hashCode() {
    return Objects.hash(conventionName, conventions, indexConvention, indexConventionName, notionalExchangeType, payReceive, rateOrSpread, resetConvention, stubType, compounding, amortisation, firstRegularPaymentDate, firstCouponType, lastRegularPaymentDate, lastCouponType);
  }

  private static <T> int hashCodeNullable(JsonNullable<T> a) {
    if (a == null) {
      return 1;
    }
    return a.isPresent() ? Arrays.deepHashCode(new Object[]{a.get()}) : 31;
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class LegDefinition {\n");
    sb.append("    conventionName: ").append(toIndentedString(conventionName)).append("\n");
    sb.append("    conventions: ").append(toIndentedString(conventions)).append("\n");
    sb.append("    indexConvention: ").append(toIndentedString(indexConvention)).append("\n");
    sb.append("    indexConventionName: ").append(toIndentedString(indexConventionName)).append("\n");
    sb.append("    notionalExchangeType: ").append(toIndentedString(notionalExchangeType)).append("\n");
    sb.append("    payReceive: ").append(toIndentedString(payReceive)).append("\n");
    sb.append("    rateOrSpread: ").append(toIndentedString(rateOrSpread)).append("\n");
    sb.append("    resetConvention: ").append(toIndentedString(resetConvention)).append("\n");
    sb.append("    stubType: ").append(toIndentedString(stubType)).append("\n");
    sb.append("    compounding: ").append(toIndentedString(compounding)).append("\n");
    sb.append("    amortisation: ").append(toIndentedString(amortisation)).append("\n");
    sb.append("    firstRegularPaymentDate: ").append(toIndentedString(firstRegularPaymentDate)).append("\n");
    sb.append("    firstCouponType: ").append(toIndentedString(firstCouponType)).append("\n");
    sb.append("    lastRegularPaymentDate: ").append(toIndentedString(lastRegularPaymentDate)).append("\n");
    sb.append("    lastCouponType: ").append(toIndentedString(lastCouponType)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }


  public static HashSet<String> openapiFields;
  public static HashSet<String> openapiRequiredFields;

  static {
    // a set of all properties/fields (JSON key names)
    openapiFields = new HashSet<String>();
    openapiFields.add("conventionName");
    openapiFields.add("conventions");
    openapiFields.add("indexConvention");
    openapiFields.add("indexConventionName");
    openapiFields.add("notionalExchangeType");
    openapiFields.add("payReceive");
    openapiFields.add("rateOrSpread");
    openapiFields.add("resetConvention");
    openapiFields.add("stubType");
    openapiFields.add("compounding");
    openapiFields.add("amortisation");
    openapiFields.add("firstRegularPaymentDate");
    openapiFields.add("firstCouponType");
    openapiFields.add("lastRegularPaymentDate");
    openapiFields.add("lastCouponType");

    // a set of required properties/fields (JSON key names)
    openapiRequiredFields = new HashSet<String>();
    openapiRequiredFields.add("notionalExchangeType");
    openapiRequiredFields.add("payReceive");
    openapiRequiredFields.add("rateOrSpread");
    openapiRequiredFields.add("stubType");
  }

 /**
  * Validates the JSON Element and throws an exception if issues found
  *
  * @param jsonElement JSON Element
  * @throws IOException if the JSON Element is invalid with respect to LegDefinition
  */
  public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      if (jsonElement == null) {
        if (!LegDefinition.openapiRequiredFields.isEmpty()) { // has required fields but JSON element is null
          throw new IllegalArgumentException(String.format("The required field(s) %s in LegDefinition is not found in the empty JSON string", LegDefinition.openapiRequiredFields.toString()));
        }
      }

      // check to make sure all required properties/fields are present in the JSON string
      for (String requiredField : LegDefinition.openapiRequiredFields) {
        if (jsonElement.getAsJsonObject().get(requiredField) == null) {
          throw new IllegalArgumentException(String.format("The required field `%s` is not found in the JSON string: %s", requiredField, jsonElement.toString()));
        }
      }
        JsonObject jsonObj = jsonElement.getAsJsonObject();
      // validate the optional field `conventionName`
      if (jsonObj.get("conventionName") != null && !jsonObj.get("conventionName").isJsonNull()) {
        FlowConventionName.validateJsonElement(jsonObj.get("conventionName"));
      }
      // validate the optional field `conventions`
      if (jsonObj.get("conventions") != null && !jsonObj.get("conventions").isJsonNull()) {
        FlowConventions.validateJsonElement(jsonObj.get("conventions"));
      }
      // validate the optional field `indexConvention`
      if (jsonObj.get("indexConvention") != null && !jsonObj.get("indexConvention").isJsonNull()) {
        IndexConvention.validateJsonElement(jsonObj.get("indexConvention"));
      }
      // validate the optional field `indexConventionName`
      if (jsonObj.get("indexConventionName") != null && !jsonObj.get("indexConventionName").isJsonNull()) {
        FlowConventionName.validateJsonElement(jsonObj.get("indexConventionName"));
      }
      if (!jsonObj.get("notionalExchangeType").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `notionalExchangeType` to be a primitive type in the JSON string but got `%s`", jsonObj.get("notionalExchangeType").toString()));
      }
      if (!jsonObj.get("payReceive").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `payReceive` to be a primitive type in the JSON string but got `%s`", jsonObj.get("payReceive").toString()));
      }
      if ((jsonObj.get("resetConvention") != null && !jsonObj.get("resetConvention").isJsonNull()) && !jsonObj.get("resetConvention").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `resetConvention` to be a primitive type in the JSON string but got `%s`", jsonObj.get("resetConvention").toString()));
      }
      if (!jsonObj.get("stubType").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `stubType` to be a primitive type in the JSON string but got `%s`", jsonObj.get("stubType").toString()));
      }
      // validate the optional field `compounding`
      if (jsonObj.get("compounding") != null && !jsonObj.get("compounding").isJsonNull()) {
        Compounding.validateJsonElement(jsonObj.get("compounding"));
      }
      // validate the optional field `amortisation`
      if (jsonObj.get("amortisation") != null && !jsonObj.get("amortisation").isJsonNull()) {
        StepSchedule.validateJsonElement(jsonObj.get("amortisation"));
      }
      if ((jsonObj.get("firstCouponType") != null && !jsonObj.get("firstCouponType").isJsonNull()) && !jsonObj.get("firstCouponType").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `firstCouponType` to be a primitive type in the JSON string but got `%s`", jsonObj.get("firstCouponType").toString()));
      }
      if ((jsonObj.get("lastCouponType") != null && !jsonObj.get("lastCouponType").isJsonNull()) && !jsonObj.get("lastCouponType").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `lastCouponType` to be a primitive type in the JSON string but got `%s`", jsonObj.get("lastCouponType").toString()));
      }
  }

  public static class CustomTypeAdapterFactory implements TypeAdapterFactory {
    @SuppressWarnings("unchecked")
    @Override
    public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {
       if (!LegDefinition.class.isAssignableFrom(type.getRawType())) {
         return null; // this class only serializes 'LegDefinition' and its subtypes
       }
       final TypeAdapter<JsonElement> elementAdapter = gson.getAdapter(JsonElement.class);
       final TypeAdapter<LegDefinition> thisAdapter
                        = gson.getDelegateAdapter(this, TypeToken.get(LegDefinition.class));

       return (TypeAdapter<T>) new TypeAdapter<LegDefinition>() {
           @Override
           public void write(JsonWriter out, LegDefinition value) throws IOException {
             JsonObject obj = thisAdapter.toJsonTree(value).getAsJsonObject();
             elementAdapter.write(out, obj);
           }

           @Override
           public LegDefinition read(JsonReader in) throws IOException {
             JsonElement jsonElement = elementAdapter.read(in);
             validateJsonElement(jsonElement);
             return thisAdapter.fromJsonTree(jsonElement);
           }

       }.nullSafe();
    }
  }

 /**
  * Create an instance of LegDefinition given an JSON string
  *
  * @param jsonString JSON string
  * @return An instance of LegDefinition
  * @throws IOException if the JSON string is invalid with respect to LegDefinition
  */
  public static LegDefinition fromJson(String jsonString) throws IOException {
    return JSON.getGson().fromJson(jsonString, LegDefinition.class);
  }

 /**
  * Convert an instance of LegDefinition to an JSON string
  *
  * @return JSON string
  */
  public String toJson() {
    return JSON.getGson().toJson(this);
  }
}
