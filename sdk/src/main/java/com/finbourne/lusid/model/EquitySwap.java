/*
 * LUSID API
 *
 * Contact: info@finbourne.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

package com.finbourne.lusid.model;

import java.util.Objects;
import com.finbourne.lusid.model.FlowConventions;
import com.finbourne.lusid.model.InstrumentLeg;
import com.finbourne.lusid.model.LusidInstrument;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;
import java.time.OffsetDateTime;
import java.util.Arrays;
import org.openapitools.jackson.nullable.JsonNullable;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonArray;
import com.google.gson.JsonDeserializationContext;
import com.google.gson.JsonDeserializer;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParseException;
import com.google.gson.TypeAdapterFactory;
import com.google.gson.reflect.TypeToken;
import com.google.gson.TypeAdapter;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;

import java.lang.reflect.Type;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Map.Entry;
import java.util.Set;

import com.finbourne.lusid.JSON;

/**
 * LUSID representation of an Equity Swap.
 */
@jakarta.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen")
public class EquitySwap extends LusidInstrument {
  public static final String SERIALIZED_NAME_START_DATE = "startDate";
  @SerializedName(SERIALIZED_NAME_START_DATE)
  private OffsetDateTime startDate;

  public static final String SERIALIZED_NAME_MATURITY_DATE = "maturityDate";
  @SerializedName(SERIALIZED_NAME_MATURITY_DATE)
  private OffsetDateTime maturityDate;

  public static final String SERIALIZED_NAME_CODE = "code";
  @SerializedName(SERIALIZED_NAME_CODE)
  private String code;

  public static final String SERIALIZED_NAME_EQUITY_FLOW_CONVENTIONS = "equityFlowConventions";
  @SerializedName(SERIALIZED_NAME_EQUITY_FLOW_CONVENTIONS)
  private FlowConventions equityFlowConventions;

  public static final String SERIALIZED_NAME_FUNDING_LEG = "fundingLeg";
  @SerializedName(SERIALIZED_NAME_FUNDING_LEG)
  private InstrumentLeg fundingLeg;

  public static final String SERIALIZED_NAME_INCLUDE_DIVIDENDS = "includeDividends";
  @SerializedName(SERIALIZED_NAME_INCLUDE_DIVIDENDS)
  private Boolean includeDividends;

  public static final String SERIALIZED_NAME_INITIAL_PRICE = "initialPrice";
  @SerializedName(SERIALIZED_NAME_INITIAL_PRICE)
  private java.math.BigDecimal initialPrice;

  public static final String SERIALIZED_NAME_NOTIONAL_RESET = "notionalReset";
  @SerializedName(SERIALIZED_NAME_NOTIONAL_RESET)
  private Boolean notionalReset;

  public static final String SERIALIZED_NAME_QUANTITY = "quantity";
  @SerializedName(SERIALIZED_NAME_QUANTITY)
  private java.math.BigDecimal quantity;

  public static final String SERIALIZED_NAME_UNDERLYING_IDENTIFIER = "underlyingIdentifier";
  @SerializedName(SERIALIZED_NAME_UNDERLYING_IDENTIFIER)
  private String underlyingIdentifier;

  public static final String SERIALIZED_NAME_EQUITY_SWAP_DIVIDEND_PAYMENT_TIMING = "equitySwapDividendPaymentTiming";
  @SerializedName(SERIALIZED_NAME_EQUITY_SWAP_DIVIDEND_PAYMENT_TIMING)
  private String equitySwapDividendPaymentTiming;

  public EquitySwap() {
    // this.instrumentType = this.getClass().getSimpleName();
  }

  public EquitySwap startDate(OffsetDateTime startDate) {
    
    this.startDate = startDate;
    return this;
  }

   /**
   * The start date of the EquitySwap.
   * @return startDate
  **/
  @jakarta.annotation.Nonnull
  public OffsetDateTime getStartDate() {
    return startDate;
  }


  public void setStartDate(OffsetDateTime startDate) {
    this.startDate = startDate;
  }


  public EquitySwap maturityDate(OffsetDateTime maturityDate) {
    
    this.maturityDate = maturityDate;
    return this;
  }

   /**
   * The final maturity date of the instrument. This means the last date on which the instruments makes a payment of any amount.  For the avoidance of doubt, that is not necessarily prior to its last sensitivity date for the purposes of risk; e.g. instruments such as  Constant Maturity Swaps (CMS) often have sensitivities to rates that may well be observed or set prior to the maturity date, but refer to a termination date beyond it.
   * @return maturityDate
  **/
  @jakarta.annotation.Nonnull
  public OffsetDateTime getMaturityDate() {
    return maturityDate;
  }


  public void setMaturityDate(OffsetDateTime maturityDate) {
    this.maturityDate = maturityDate;
  }


  public EquitySwap code(String code) {
    
    this.code = code;
    return this;
  }

   /**
   * The code of the underlying.
   * @return code
  **/
  @jakarta.annotation.Nonnull
  public String getCode() {
    return code;
  }


  public void setCode(String code) {
    this.code = code;
  }


  public EquitySwap equityFlowConventions(FlowConventions equityFlowConventions) {
    
    this.equityFlowConventions = equityFlowConventions;
    return this;
  }

   /**
   * Get equityFlowConventions
   * @return equityFlowConventions
  **/
  @jakarta.annotation.Nonnull
  public FlowConventions getEquityFlowConventions() {
    return equityFlowConventions;
  }


  public void setEquityFlowConventions(FlowConventions equityFlowConventions) {
    this.equityFlowConventions = equityFlowConventions;
  }


  public EquitySwap fundingLeg(InstrumentLeg fundingLeg) {
    
    this.fundingLeg = fundingLeg;
    return this;
  }

   /**
   * Get fundingLeg
   * @return fundingLeg
  **/
  @jakarta.annotation.Nonnull
  public InstrumentLeg getFundingLeg() {
    return fundingLeg;
  }


  public void setFundingLeg(InstrumentLeg fundingLeg) {
    this.fundingLeg = fundingLeg;
  }


  public EquitySwap includeDividends(Boolean includeDividends) {
    
    this.includeDividends = includeDividends;
    return this;
  }

   /**
   * Dividend inclusion flag, if true dividends are included in the equity leg (total return).
   * @return includeDividends
  **/
  @jakarta.annotation.Nonnull
  public Boolean getIncludeDividends() {
    return includeDividends;
  }


  public void setIncludeDividends(Boolean includeDividends) {
    this.includeDividends = includeDividends;
  }


  public EquitySwap initialPrice(java.math.BigDecimal initialPrice) {
    
    this.initialPrice = initialPrice;
    return this;
  }

   /**
   * The initial equity price of the Equity Swap.
   * @return initialPrice
  **/
  @jakarta.annotation.Nonnull
  public java.math.BigDecimal getInitialPrice() {
    return initialPrice;
  }


  public void setInitialPrice(java.math.BigDecimal initialPrice) {
    this.initialPrice = initialPrice;
  }


  public EquitySwap notionalReset(Boolean notionalReset) {
    
    this.notionalReset = notionalReset;
    return this;
  }

   /**
   * Notional reset flag, if true the notional of the funding leg is reset at the start of every  coupon to match the value of the equity leg (equity price at start of coupon times quantity).
   * @return notionalReset
  **/
  @jakarta.annotation.Nonnull
  public Boolean getNotionalReset() {
    return notionalReset;
  }


  public void setNotionalReset(Boolean notionalReset) {
    this.notionalReset = notionalReset;
  }


  public EquitySwap quantity(java.math.BigDecimal quantity) {
    
    this.quantity = quantity;
    return this;
  }

   /**
   * The quantity or number of shares in the Equity Swap.
   * @return quantity
  **/
  @jakarta.annotation.Nonnull
  public java.math.BigDecimal getQuantity() {
    return quantity;
  }


  public void setQuantity(java.math.BigDecimal quantity) {
    this.quantity = quantity;
  }


  public EquitySwap underlyingIdentifier(String underlyingIdentifier) {
    
    this.underlyingIdentifier = underlyingIdentifier;
    return this;
  }

   /**
   * External market codes and identifiers for the EquitySwap, e.g. RIC.    Supported string (enumeration) values are: [LusidInstrumentId, Isin, Sedol, Cusip, ClientInternal, Figi, RIC, QuotePermId, REDCode, BBGId, ICECode].
   * @return underlyingIdentifier
  **/
  @jakarta.annotation.Nonnull
  public String getUnderlyingIdentifier() {
    return underlyingIdentifier;
  }


  public void setUnderlyingIdentifier(String underlyingIdentifier) {
    this.underlyingIdentifier = underlyingIdentifier;
  }


  public EquitySwap equitySwapDividendPaymentTiming(String equitySwapDividendPaymentTiming) {
    
    this.equitySwapDividendPaymentTiming = equitySwapDividendPaymentTiming;
    return this;
  }

   /**
   * Determines how the payment of dividends is handled for the equity swap.  Defaults to paying at the next Equity coupon date.                Supported string (enumeration) values are: [PayAtNextEquityCouponDate, PayAtMaturityOfSwap, PayAtNextFundingLegCouponDate, PayAtPaymentDateOfDividendEvent].
   * @return equitySwapDividendPaymentTiming
  **/
  @jakarta.annotation.Nullable
  public String getEquitySwapDividendPaymentTiming() {
    return equitySwapDividendPaymentTiming;
  }


  public void setEquitySwapDividendPaymentTiming(String equitySwapDividendPaymentTiming) {
    this.equitySwapDividendPaymentTiming = equitySwapDividendPaymentTiming;
  }



  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    EquitySwap equitySwap = (EquitySwap) o;
    return Objects.equals(this.startDate, equitySwap.startDate) &&
        Objects.equals(this.maturityDate, equitySwap.maturityDate) &&
        Objects.equals(this.code, equitySwap.code) &&
        Objects.equals(this.equityFlowConventions, equitySwap.equityFlowConventions) &&
        Objects.equals(this.fundingLeg, equitySwap.fundingLeg) &&
        Objects.equals(this.includeDividends, equitySwap.includeDividends) &&
        (this.initialPrice.compareTo(equitySwap.getInitialPrice()) == 0) &&
        Objects.equals(this.notionalReset, equitySwap.notionalReset) &&
        (this.quantity.compareTo(equitySwap.getQuantity()) == 0) &&
        Objects.equals(this.underlyingIdentifier, equitySwap.underlyingIdentifier) &&
        Objects.equals(this.equitySwapDividendPaymentTiming, equitySwap.equitySwapDividendPaymentTiming) &&
        super.equals(o);
  }

  private static <T> boolean equalsNullable(JsonNullable<T> a, JsonNullable<T> b) {
    return a == b || (a != null && b != null && a.isPresent() && b.isPresent() && Objects.deepEquals(a.get(), b.get()));
  }

  @Override
  public int hashCode() {
    return Objects.hash(startDate, maturityDate, code, equityFlowConventions, fundingLeg, includeDividends, initialPrice, notionalReset, quantity, underlyingIdentifier, equitySwapDividendPaymentTiming, super.hashCode());
  }

  private static <T> int hashCodeNullable(JsonNullable<T> a) {
    if (a == null) {
      return 1;
    }
    return a.isPresent() ? Arrays.deepHashCode(new Object[]{a.get()}) : 31;
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class EquitySwap {\n");
    sb.append("    ").append(toIndentedString(super.toString())).append("\n");
    sb.append("    startDate: ").append(toIndentedString(startDate)).append("\n");
    sb.append("    maturityDate: ").append(toIndentedString(maturityDate)).append("\n");
    sb.append("    code: ").append(toIndentedString(code)).append("\n");
    sb.append("    equityFlowConventions: ").append(toIndentedString(equityFlowConventions)).append("\n");
    sb.append("    fundingLeg: ").append(toIndentedString(fundingLeg)).append("\n");
    sb.append("    includeDividends: ").append(toIndentedString(includeDividends)).append("\n");
    sb.append("    initialPrice: ").append(toIndentedString(initialPrice)).append("\n");
    sb.append("    notionalReset: ").append(toIndentedString(notionalReset)).append("\n");
    sb.append("    quantity: ").append(toIndentedString(quantity)).append("\n");
    sb.append("    underlyingIdentifier: ").append(toIndentedString(underlyingIdentifier)).append("\n");
    sb.append("    equitySwapDividendPaymentTiming: ").append(toIndentedString(equitySwapDividendPaymentTiming)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }


  public static HashSet<String> openapiFields;
  public static HashSet<String> openapiRequiredFields;

  static {
    // a set of all properties/fields (JSON key names)
    openapiFields = new HashSet<String>();
    openapiFields.add("instrumentType");
    openapiFields.add("startDate");
    openapiFields.add("maturityDate");
    openapiFields.add("code");
    openapiFields.add("equityFlowConventions");
    openapiFields.add("fundingLeg");
    openapiFields.add("includeDividends");
    openapiFields.add("initialPrice");
    openapiFields.add("notionalReset");
    openapiFields.add("quantity");
    openapiFields.add("underlyingIdentifier");
    openapiFields.add("equitySwapDividendPaymentTiming");

    // a set of required properties/fields (JSON key names)
    openapiRequiredFields = new HashSet<String>();
    openapiRequiredFields.add("startDate");
    openapiRequiredFields.add("maturityDate");
    openapiRequiredFields.add("code");
    openapiRequiredFields.add("equityFlowConventions");
    openapiRequiredFields.add("fundingLeg");
    openapiRequiredFields.add("includeDividends");
    openapiRequiredFields.add("initialPrice");
    openapiRequiredFields.add("notionalReset");
    openapiRequiredFields.add("quantity");
    openapiRequiredFields.add("underlyingIdentifier");
    openapiRequiredFields.add("instrumentType");
  }

 /**
  * Validates the JSON Object and throws an exception if issues found
  *
  * @param jsonObj JSON Object
  * @throws IOException if the JSON Object is invalid with respect to EquitySwap
  */
  public static void validateJsonObject(JsonObject jsonObj) throws IOException {
      if (jsonObj == null) {
        if (!EquitySwap.openapiRequiredFields.isEmpty()) { // has required fields but JSON object is null
          throw new IllegalArgumentException(String.format("The required field(s) %s in EquitySwap is not found in the empty JSON string", EquitySwap.openapiRequiredFields.toString()));
        }
      }

      Set<Entry<String, JsonElement>> entries = jsonObj.entrySet();
      // check to see if the JSON string contains additional fields
      for (Entry<String, JsonElement> entry : entries) {
        if (!EquitySwap.openapiFields.contains(entry.getKey())) {
          throw new IllegalArgumentException(String.format("The field `%s` in the JSON string is not defined in the `EquitySwap` properties. JSON: %s", entry.getKey(), jsonObj.toString()));
        }
      }

      // check to make sure all required properties/fields are present in the JSON string
      for (String requiredField : EquitySwap.openapiRequiredFields) {
        if (jsonObj.get(requiredField) == null) {
          throw new IllegalArgumentException(String.format("The required field `%s` is not found in the JSON string: %s", requiredField, jsonObj.toString()));
        }
      }
  }

  public static class CustomTypeAdapterFactory implements TypeAdapterFactory {
    @SuppressWarnings("unchecked")
    @Override
    public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {
       if (!EquitySwap.class.isAssignableFrom(type.getRawType())) {
         return null; // this class only serializes 'EquitySwap' and its subtypes
       }
       final TypeAdapter<JsonElement> elementAdapter = gson.getAdapter(JsonElement.class);
       final TypeAdapter<EquitySwap> thisAdapter
                        = gson.getDelegateAdapter(this, TypeToken.get(EquitySwap.class));

       return (TypeAdapter<T>) new TypeAdapter<EquitySwap>() {
           @Override
           public void write(JsonWriter out, EquitySwap value) throws IOException {
             JsonObject obj = thisAdapter.toJsonTree(value).getAsJsonObject();
             elementAdapter.write(out, obj);
           }

           @Override
           public EquitySwap read(JsonReader in) throws IOException {
             JsonObject jsonObj = elementAdapter.read(in).getAsJsonObject();
             validateJsonObject(jsonObj);
             return thisAdapter.fromJsonTree(jsonObj);
           }

       }.nullSafe();
    }
  }

 /**
  * Create an instance of EquitySwap given an JSON string
  *
  * @param jsonString JSON string
  * @return An instance of EquitySwap
  * @throws IOException if the JSON string is invalid with respect to EquitySwap
  */
  public static EquitySwap fromJson(String jsonString) throws IOException {
    return JSON.getGson().fromJson(jsonString, EquitySwap.class);
  }

 /**
  * Convert an instance of EquitySwap to an JSON string
  *
  * @return JSON string
  */
  public String toJson() {
    return JSON.getGson().toJson(this);
  }
}
