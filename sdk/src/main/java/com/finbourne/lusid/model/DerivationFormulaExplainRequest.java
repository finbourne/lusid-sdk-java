/*
 * LUSID API
 *
 * Contact: info@finbourne.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

package com.finbourne.lusid.model;

import java.util.Objects;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;
import java.util.Arrays;
import java.util.HashMap;
import java.util.Map;
import org.openapitools.jackson.nullable.JsonNullable;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonArray;
import com.google.gson.JsonDeserializationContext;
import com.google.gson.JsonDeserializer;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParseException;
import com.google.gson.TypeAdapterFactory;
import com.google.gson.reflect.TypeToken;
import com.google.gson.TypeAdapter;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;

import java.lang.reflect.Type;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Map.Entry;
import java.util.Set;

import com.finbourne.lusid.JSON;

/**
 * DerivationFormulaExplainRequest
 */
@jakarta.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen")
public class DerivationFormulaExplainRequest {
  public static final String SERIALIZED_NAME_ENTITY_TYPE = "entityType";
  @SerializedName(SERIALIZED_NAME_ENTITY_TYPE)
  private String entityType;

  public static final String SERIALIZED_NAME_SCOPE = "scope";
  @SerializedName(SERIALIZED_NAME_SCOPE)
  private String scope;

  public static final String SERIALIZED_NAME_CODE = "code";
  @SerializedName(SERIALIZED_NAME_CODE)
  private String code;

  public static final String SERIALIZED_NAME_IDENTIFIER = "identifier";
  @SerializedName(SERIALIZED_NAME_IDENTIFIER)
  private Map<String, String> identifier;

  public static final String SERIALIZED_NAME_PROPERTY_KEY = "propertyKey";
  @SerializedName(SERIALIZED_NAME_PROPERTY_KEY)
  private String propertyKey;

  public static final String SERIALIZED_NAME_PARTIAL_FORMULA = "partialFormula";
  @SerializedName(SERIALIZED_NAME_PARTIAL_FORMULA)
  private String partialFormula;

  public DerivationFormulaExplainRequest() {
  }

  public DerivationFormulaExplainRequest entityType(String entityType) {
    
    this.entityType = entityType;
    return this;
  }

   /**
   * The type of the entity for which the derived property or partial formula is to be resolved against.
   * @return entityType
  **/
  @jakarta.annotation.Nonnull
  public String getEntityType() {
    return entityType;
  }


  public void setEntityType(String entityType) {
    this.entityType = entityType;
  }


  public DerivationFormulaExplainRequest scope(String scope) {
    
    this.scope = scope;
    return this;
  }

   /**
   * (Optional) The scope that entity exists in. If no scope is provided, the default scope for the entity type will be used.
   * @return scope
  **/
  @jakarta.annotation.Nullable
  public String getScope() {
    return scope;
  }


  public void setScope(String scope) {
    this.scope = scope;
  }


  public DerivationFormulaExplainRequest code(String code) {
    
    this.code = code;
    return this;
  }

   /**
   * (Optional) The code of the entity, to be provided for entities that support scope/code retrieval. If no code or identifier is provided, the logical evaluation tree without resolved values is returned.
   * @return code
  **/
  @jakarta.annotation.Nullable
  public String getCode() {
    return code;
  }


  public void setCode(String code) {
    this.code = code;
  }


  public DerivationFormulaExplainRequest identifier(Map<String, String> identifier) {
    
    this.identifier = identifier;
    return this;
  }

  public DerivationFormulaExplainRequest putIdentifierItem(String key, String identifierItem) {
    if (this.identifier == null) {
      this.identifier = new HashMap<>();
    }
    this.identifier.put(key, identifierItem);
    return this;
  }

   /**
   * (Optional). An identifier key/value pair that uniquely identifies the entity to explain the derived property for. This can be either an instrument identifier, or an identifier property. If no code or identifier is provided, the logical evaluation tree without resolved values is returned.
   * @return identifier
  **/
  @jakarta.annotation.Nullable
  public Map<String, String> getIdentifier() {
    return identifier;
  }


  public void setIdentifier(Map<String, String> identifier) {
    this.identifier = identifier;
  }


  public DerivationFormulaExplainRequest propertyKey(String propertyKey) {
    
    this.propertyKey = propertyKey;
    return this;
  }

   /**
   * (Optional) The key of the derived property to get an explanation for. This takes the format {domain}/{scope}/{code}. One of either property key or partial formula must be provided.
   * @return propertyKey
  **/
  @jakarta.annotation.Nullable
  public String getPropertyKey() {
    return propertyKey;
  }


  public void setPropertyKey(String propertyKey) {
    this.propertyKey = propertyKey;
  }


  public DerivationFormulaExplainRequest partialFormula(String partialFormula) {
    
    this.partialFormula = partialFormula;
    return this;
  }

   /**
   * (Optional) A partial derivation formula to get an explanation for. Can be provided in lieu of a property key. One of either property key or partial formula must be provided.
   * @return partialFormula
  **/
  @jakarta.annotation.Nullable
  public String getPartialFormula() {
    return partialFormula;
  }


  public void setPartialFormula(String partialFormula) {
    this.partialFormula = partialFormula;
  }



  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    DerivationFormulaExplainRequest derivationFormulaExplainRequest = (DerivationFormulaExplainRequest) o;
    return Objects.equals(this.entityType, derivationFormulaExplainRequest.entityType) &&
        Objects.equals(this.scope, derivationFormulaExplainRequest.scope) &&
        Objects.equals(this.code, derivationFormulaExplainRequest.code) &&
        Objects.equals(this.identifier, derivationFormulaExplainRequest.identifier) &&
        Objects.equals(this.propertyKey, derivationFormulaExplainRequest.propertyKey) &&
        Objects.equals(this.partialFormula, derivationFormulaExplainRequest.partialFormula);
  }

  private static <T> boolean equalsNullable(JsonNullable<T> a, JsonNullable<T> b) {
    return a == b || (a != null && b != null && a.isPresent() && b.isPresent() && Objects.deepEquals(a.get(), b.get()));
  }

  @Override
  public int hashCode() {
    return Objects.hash(entityType, scope, code, identifier, propertyKey, partialFormula);
  }

  private static <T> int hashCodeNullable(JsonNullable<T> a) {
    if (a == null) {
      return 1;
    }
    return a.isPresent() ? Arrays.deepHashCode(new Object[]{a.get()}) : 31;
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class DerivationFormulaExplainRequest {\n");
    sb.append("    entityType: ").append(toIndentedString(entityType)).append("\n");
    sb.append("    scope: ").append(toIndentedString(scope)).append("\n");
    sb.append("    code: ").append(toIndentedString(code)).append("\n");
    sb.append("    identifier: ").append(toIndentedString(identifier)).append("\n");
    sb.append("    propertyKey: ").append(toIndentedString(propertyKey)).append("\n");
    sb.append("    partialFormula: ").append(toIndentedString(partialFormula)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }


  public static HashSet<String> openapiFields;
  public static HashSet<String> openapiRequiredFields;

  static {
    // a set of all properties/fields (JSON key names)
    openapiFields = new HashSet<String>();
    openapiFields.add("entityType");
    openapiFields.add("scope");
    openapiFields.add("code");
    openapiFields.add("identifier");
    openapiFields.add("propertyKey");
    openapiFields.add("partialFormula");

    // a set of required properties/fields (JSON key names)
    openapiRequiredFields = new HashSet<String>();
    openapiRequiredFields.add("entityType");
  }

 /**
  * Validates the JSON Element and throws an exception if issues found
  *
  * @param jsonElement JSON Element
  * @throws IOException if the JSON Element is invalid with respect to DerivationFormulaExplainRequest
  */
  public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      if (jsonElement == null) {
        if (!DerivationFormulaExplainRequest.openapiRequiredFields.isEmpty()) { // has required fields but JSON element is null
          throw new IllegalArgumentException(String.format("The required field(s) %s in DerivationFormulaExplainRequest is not found in the empty JSON string", DerivationFormulaExplainRequest.openapiRequiredFields.toString()));
        }
      }

      // check to make sure all required properties/fields are present in the JSON string
      for (String requiredField : DerivationFormulaExplainRequest.openapiRequiredFields) {
        if (jsonElement.getAsJsonObject().get(requiredField) == null) {
          throw new IllegalArgumentException(String.format("The required field `%s` is not found in the JSON string: %s", requiredField, jsonElement.toString()));
        }
      }
        JsonObject jsonObj = jsonElement.getAsJsonObject();
      if (!jsonObj.get("entityType").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `entityType` to be a primitive type in the JSON string but got `%s`", jsonObj.get("entityType").toString()));
      }
      if ((jsonObj.get("scope") != null && !jsonObj.get("scope").isJsonNull()) && !jsonObj.get("scope").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `scope` to be a primitive type in the JSON string but got `%s`", jsonObj.get("scope").toString()));
      }
      if ((jsonObj.get("code") != null && !jsonObj.get("code").isJsonNull()) && !jsonObj.get("code").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `code` to be a primitive type in the JSON string but got `%s`", jsonObj.get("code").toString()));
      }
      if ((jsonObj.get("propertyKey") != null && !jsonObj.get("propertyKey").isJsonNull()) && !jsonObj.get("propertyKey").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `propertyKey` to be a primitive type in the JSON string but got `%s`", jsonObj.get("propertyKey").toString()));
      }
      if ((jsonObj.get("partialFormula") != null && !jsonObj.get("partialFormula").isJsonNull()) && !jsonObj.get("partialFormula").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `partialFormula` to be a primitive type in the JSON string but got `%s`", jsonObj.get("partialFormula").toString()));
      }
  }

  public static class CustomTypeAdapterFactory implements TypeAdapterFactory {
    @SuppressWarnings("unchecked")
    @Override
    public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {
       if (!DerivationFormulaExplainRequest.class.isAssignableFrom(type.getRawType())) {
         return null; // this class only serializes 'DerivationFormulaExplainRequest' and its subtypes
       }
       final TypeAdapter<JsonElement> elementAdapter = gson.getAdapter(JsonElement.class);
       final TypeAdapter<DerivationFormulaExplainRequest> thisAdapter
                        = gson.getDelegateAdapter(this, TypeToken.get(DerivationFormulaExplainRequest.class));

       return (TypeAdapter<T>) new TypeAdapter<DerivationFormulaExplainRequest>() {
           @Override
           public void write(JsonWriter out, DerivationFormulaExplainRequest value) throws IOException {
             JsonObject obj = thisAdapter.toJsonTree(value).getAsJsonObject();
             elementAdapter.write(out, obj);
           }

           @Override
           public DerivationFormulaExplainRequest read(JsonReader in) throws IOException {
             JsonElement jsonElement = elementAdapter.read(in);
             validateJsonElement(jsonElement);
             return thisAdapter.fromJsonTree(jsonElement);
           }

       }.nullSafe();
    }
  }

 /**
  * Create an instance of DerivationFormulaExplainRequest given an JSON string
  *
  * @param jsonString JSON string
  * @return An instance of DerivationFormulaExplainRequest
  * @throws IOException if the JSON string is invalid with respect to DerivationFormulaExplainRequest
  */
  public static DerivationFormulaExplainRequest fromJson(String jsonString) throws IOException {
    return JSON.getGson().fromJson(jsonString, DerivationFormulaExplainRequest.class);
  }

 /**
  * Convert an instance of DerivationFormulaExplainRequest to an JSON string
  *
  * @return JSON string
  */
  public String toJson() {
    return JSON.getGson().toJson(this);
  }
}
