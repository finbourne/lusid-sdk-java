/*
 * LUSID API
 *
 * Contact: info@finbourne.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

package com.finbourne.lusid.model;

import java.util.Objects;
import com.finbourne.lusid.model.AggregateSpec;
import com.finbourne.lusid.model.FundValuationSchedule;
import com.finbourne.lusid.model.MarketDataOverrides;
import com.finbourne.lusid.model.OrderBySpec;
import com.finbourne.lusid.model.OrderFlowConfiguration;
import com.finbourne.lusid.model.PropertyFilter;
import com.finbourne.lusid.model.ResourceId;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;
import java.time.OffsetDateTime;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import org.openapitools.jackson.nullable.JsonNullable;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonArray;
import com.google.gson.JsonDeserializationContext;
import com.google.gson.JsonDeserializer;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParseException;
import com.google.gson.TypeAdapterFactory;
import com.google.gson.reflect.TypeToken;
import com.google.gson.TypeAdapter;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;

import java.lang.reflect.Type;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Map.Entry;
import java.util.Set;

import com.finbourne.lusid.JSON;

/**
 * Specification object for the parameters of a valuation
 */
@jakarta.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen")
public class FundValuationRequest {
  public static final String SERIALIZED_NAME_AS_AT = "asAt";
  @SerializedName(SERIALIZED_NAME_AS_AT)
  private OffsetDateTime asAt;

  public static final String SERIALIZED_NAME_METRICS = "metrics";
  @SerializedName(SERIALIZED_NAME_METRICS)
  private List<AggregateSpec> metrics = new ArrayList<>();

  public static final String SERIALIZED_NAME_GROUP_BY = "groupBy";
  @SerializedName(SERIALIZED_NAME_GROUP_BY)
  private List<String> groupBy;

  public static final String SERIALIZED_NAME_FILTERS = "filters";
  @SerializedName(SERIALIZED_NAME_FILTERS)
  private List<PropertyFilter> filters;

  public static final String SERIALIZED_NAME_SORT = "sort";
  @SerializedName(SERIALIZED_NAME_SORT)
  private List<OrderBySpec> sort;

  public static final String SERIALIZED_NAME_EQUIP_WITH_SUBTOTALS = "equipWithSubtotals";
  @SerializedName(SERIALIZED_NAME_EQUIP_WITH_SUBTOTALS)
  private Boolean equipWithSubtotals;

  public static final String SERIALIZED_NAME_RETURN_RESULT_AS_EXPANDED_TYPES = "returnResultAsExpandedTypes";
  @SerializedName(SERIALIZED_NAME_RETURN_RESULT_AS_EXPANDED_TYPES)
  private Boolean returnResultAsExpandedTypes;

  public static final String SERIALIZED_NAME_INCLUDE_ORDER_FLOW = "includeOrderFlow";
  @SerializedName(SERIALIZED_NAME_INCLUDE_ORDER_FLOW)
  private OrderFlowConfiguration includeOrderFlow;

  public static final String SERIALIZED_NAME_FUND_VALUATION_SCHEDULE = "fundValuationSchedule";
  @SerializedName(SERIALIZED_NAME_FUND_VALUATION_SCHEDULE)
  private FundValuationSchedule fundValuationSchedule;

  public static final String SERIALIZED_NAME_MARKET_DATA_OVERRIDES = "marketDataOverrides";
  @SerializedName(SERIALIZED_NAME_MARKET_DATA_OVERRIDES)
  private MarketDataOverrides marketDataOverrides;

  public static final String SERIALIZED_NAME_CORPORATE_ACTION_SOURCE_ID = "corporateActionSourceId";
  @SerializedName(SERIALIZED_NAME_CORPORATE_ACTION_SOURCE_ID)
  private ResourceId corporateActionSourceId;

  public FundValuationRequest() {
  }

  public FundValuationRequest asAt(OffsetDateTime asAt) {
    
    this.asAt = asAt;
    return this;
  }

   /**
   * The asAt date to use.
   * @return asAt
  **/
  @jakarta.annotation.Nullable
  public OffsetDateTime getAsAt() {
    return asAt;
  }


  public void setAsAt(OffsetDateTime asAt) {
    this.asAt = asAt;
  }


  public FundValuationRequest metrics(List<AggregateSpec> metrics) {
    
    this.metrics = metrics;
    return this;
  }

  public FundValuationRequest addMetricsItem(AggregateSpec metricsItem) {
    if (this.metrics == null) {
      this.metrics = new ArrayList<>();
    }
    this.metrics.add(metricsItem);
    return this;
  }

   /**
   * The set of specifications to calculate or retrieve during the valuation and present in the results. For example: AggregateSpec(&#39;Valuation/PV&#39;,&#39;Sum&#39;) for returning the PV (present value) of holdings AggregateSpec(&#39;Holding/default/Units&#39;,&#39;Sum&#39;) for returning the units of holidays AggregateSpec(&#39;Instrument/default/LusidInstrumentId&#39;,&#39;Value&#39;) for returning the Lusid Instrument identifier
   * @return metrics
  **/
  @jakarta.annotation.Nonnull
  public List<AggregateSpec> getMetrics() {
    return metrics;
  }


  public void setMetrics(List<AggregateSpec> metrics) {
    this.metrics = metrics;
  }


  public FundValuationRequest groupBy(List<String> groupBy) {
    
    this.groupBy = groupBy;
    return this;
  }

  public FundValuationRequest addGroupByItem(String groupByItem) {
    if (this.groupBy == null) {
      this.groupBy = new ArrayList<>();
    }
    this.groupBy.add(groupByItem);
    return this;
  }

   /**
   * The set of items by which to perform grouping. This primarily matters when one or more of the metric operators is a mapping that reduces set size, e.g. sum or proportion. The group-by statement determines the set of keys by which to break the results out.
   * @return groupBy
  **/
  @jakarta.annotation.Nullable
  public List<String> getGroupBy() {
    return groupBy;
  }


  public void setGroupBy(List<String> groupBy) {
    this.groupBy = groupBy;
  }


  public FundValuationRequest filters(List<PropertyFilter> filters) {
    
    this.filters = filters;
    return this;
  }

  public FundValuationRequest addFiltersItem(PropertyFilter filtersItem) {
    if (this.filters == null) {
      this.filters = new ArrayList<>();
    }
    this.filters.add(filtersItem);
    return this;
  }

   /**
   * A set of filters to use to reduce the data found in a request. Equivalent to the &#39;where ...&#39; part of a Sql select statement. For example, filter a set of values within a given range or matching a particular value.
   * @return filters
  **/
  @jakarta.annotation.Nullable
  public List<PropertyFilter> getFilters() {
    return filters;
  }


  public void setFilters(List<PropertyFilter> filters) {
    this.filters = filters;
  }


  public FundValuationRequest sort(List<OrderBySpec> sort) {
    
    this.sort = sort;
    return this;
  }

  public FundValuationRequest addSortItem(OrderBySpec sortItem) {
    if (this.sort == null) {
      this.sort = new ArrayList<>();
    }
    this.sort.add(sortItem);
    return this;
  }

   /**
   * A (possibly empty/null) set of specifications for how to order the results.
   * @return sort
  **/
  @jakarta.annotation.Nullable
  public List<OrderBySpec> getSort() {
    return sort;
  }


  public void setSort(List<OrderBySpec> sort) {
    this.sort = sort;
  }


  public FundValuationRequest equipWithSubtotals(Boolean equipWithSubtotals) {
    
    this.equipWithSubtotals = equipWithSubtotals;
    return this;
  }

   /**
   * Flag directing the Valuation call to populate the results with subtotals of aggregates.
   * @return equipWithSubtotals
  **/
  @jakarta.annotation.Nullable
  public Boolean getEquipWithSubtotals() {
    return equipWithSubtotals;
  }


  public void setEquipWithSubtotals(Boolean equipWithSubtotals) {
    this.equipWithSubtotals = equipWithSubtotals;
  }


  public FundValuationRequest returnResultAsExpandedTypes(Boolean returnResultAsExpandedTypes) {
    
    this.returnResultAsExpandedTypes = returnResultAsExpandedTypes;
    return this;
  }

   /**
   * Financially meaningful results can be presented as either simple flat types or more complex expanded types. For example, the present value (PV) of a holding could be represented either as a simple decimal (with currency implied) or as a decimal-currency pair. This flag allows either representation to be returned. In the PV example, the returned value would be the decimal-currency pair if this flag is true, or the decimal only if this flag is false.
   * @return returnResultAsExpandedTypes
  **/
  @jakarta.annotation.Nullable
  public Boolean getReturnResultAsExpandedTypes() {
    return returnResultAsExpandedTypes;
  }


  public void setReturnResultAsExpandedTypes(Boolean returnResultAsExpandedTypes) {
    this.returnResultAsExpandedTypes = returnResultAsExpandedTypes;
  }


  public FundValuationRequest includeOrderFlow(OrderFlowConfiguration includeOrderFlow) {
    
    this.includeOrderFlow = includeOrderFlow;
    return this;
  }

   /**
   * Get includeOrderFlow
   * @return includeOrderFlow
  **/
  @jakarta.annotation.Nullable
  public OrderFlowConfiguration getIncludeOrderFlow() {
    return includeOrderFlow;
  }


  public void setIncludeOrderFlow(OrderFlowConfiguration includeOrderFlow) {
    this.includeOrderFlow = includeOrderFlow;
  }


  public FundValuationRequest fundValuationSchedule(FundValuationSchedule fundValuationSchedule) {
    
    this.fundValuationSchedule = fundValuationSchedule;
    return this;
  }

   /**
   * Get fundValuationSchedule
   * @return fundValuationSchedule
  **/
  @jakarta.annotation.Nonnull
  public FundValuationSchedule getFundValuationSchedule() {
    return fundValuationSchedule;
  }


  public void setFundValuationSchedule(FundValuationSchedule fundValuationSchedule) {
    this.fundValuationSchedule = fundValuationSchedule;
  }


  public FundValuationRequest marketDataOverrides(MarketDataOverrides marketDataOverrides) {
    
    this.marketDataOverrides = marketDataOverrides;
    return this;
  }

   /**
   * Get marketDataOverrides
   * @return marketDataOverrides
  **/
  @jakarta.annotation.Nullable
  public MarketDataOverrides getMarketDataOverrides() {
    return marketDataOverrides;
  }


  public void setMarketDataOverrides(MarketDataOverrides marketDataOverrides) {
    this.marketDataOverrides = marketDataOverrides;
  }


  public FundValuationRequest corporateActionSourceId(ResourceId corporateActionSourceId) {
    
    this.corporateActionSourceId = corporateActionSourceId;
    return this;
  }

   /**
   * Get corporateActionSourceId
   * @return corporateActionSourceId
  **/
  @jakarta.annotation.Nullable
  public ResourceId getCorporateActionSourceId() {
    return corporateActionSourceId;
  }


  public void setCorporateActionSourceId(ResourceId corporateActionSourceId) {
    this.corporateActionSourceId = corporateActionSourceId;
  }



  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    FundValuationRequest fundValuationRequest = (FundValuationRequest) o;
    return Objects.equals(this.asAt, fundValuationRequest.asAt) &&
        Objects.equals(this.metrics, fundValuationRequest.metrics) &&
        Objects.equals(this.groupBy, fundValuationRequest.groupBy) &&
        Objects.equals(this.filters, fundValuationRequest.filters) &&
        Objects.equals(this.sort, fundValuationRequest.sort) &&
        Objects.equals(this.equipWithSubtotals, fundValuationRequest.equipWithSubtotals) &&
        Objects.equals(this.returnResultAsExpandedTypes, fundValuationRequest.returnResultAsExpandedTypes) &&
        Objects.equals(this.includeOrderFlow, fundValuationRequest.includeOrderFlow) &&
        Objects.equals(this.fundValuationSchedule, fundValuationRequest.fundValuationSchedule) &&
        Objects.equals(this.marketDataOverrides, fundValuationRequest.marketDataOverrides) &&
        Objects.equals(this.corporateActionSourceId, fundValuationRequest.corporateActionSourceId);
  }

  private static <T> boolean equalsNullable(JsonNullable<T> a, JsonNullable<T> b) {
    return a == b || (a != null && b != null && a.isPresent() && b.isPresent() && Objects.deepEquals(a.get(), b.get()));
  }

  @Override
  public int hashCode() {
    return Objects.hash(asAt, metrics, groupBy, filters, sort, equipWithSubtotals, returnResultAsExpandedTypes, includeOrderFlow, fundValuationSchedule, marketDataOverrides, corporateActionSourceId);
  }

  private static <T> int hashCodeNullable(JsonNullable<T> a) {
    if (a == null) {
      return 1;
    }
    return a.isPresent() ? Arrays.deepHashCode(new Object[]{a.get()}) : 31;
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class FundValuationRequest {\n");
    sb.append("    asAt: ").append(toIndentedString(asAt)).append("\n");
    sb.append("    metrics: ").append(toIndentedString(metrics)).append("\n");
    sb.append("    groupBy: ").append(toIndentedString(groupBy)).append("\n");
    sb.append("    filters: ").append(toIndentedString(filters)).append("\n");
    sb.append("    sort: ").append(toIndentedString(sort)).append("\n");
    sb.append("    equipWithSubtotals: ").append(toIndentedString(equipWithSubtotals)).append("\n");
    sb.append("    returnResultAsExpandedTypes: ").append(toIndentedString(returnResultAsExpandedTypes)).append("\n");
    sb.append("    includeOrderFlow: ").append(toIndentedString(includeOrderFlow)).append("\n");
    sb.append("    fundValuationSchedule: ").append(toIndentedString(fundValuationSchedule)).append("\n");
    sb.append("    marketDataOverrides: ").append(toIndentedString(marketDataOverrides)).append("\n");
    sb.append("    corporateActionSourceId: ").append(toIndentedString(corporateActionSourceId)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }


  public static HashSet<String> openapiFields;
  public static HashSet<String> openapiRequiredFields;

  static {
    // a set of all properties/fields (JSON key names)
    openapiFields = new HashSet<String>();
    openapiFields.add("asAt");
    openapiFields.add("metrics");
    openapiFields.add("groupBy");
    openapiFields.add("filters");
    openapiFields.add("sort");
    openapiFields.add("equipWithSubtotals");
    openapiFields.add("returnResultAsExpandedTypes");
    openapiFields.add("includeOrderFlow");
    openapiFields.add("fundValuationSchedule");
    openapiFields.add("marketDataOverrides");
    openapiFields.add("corporateActionSourceId");

    // a set of required properties/fields (JSON key names)
    openapiRequiredFields = new HashSet<String>();
    openapiRequiredFields.add("metrics");
    openapiRequiredFields.add("fundValuationSchedule");
  }

 /**
  * Validates the JSON Element and throws an exception if issues found
  *
  * @param jsonElement JSON Element
  * @throws IOException if the JSON Element is invalid with respect to FundValuationRequest
  */
  public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      if (jsonElement == null) {
        if (!FundValuationRequest.openapiRequiredFields.isEmpty()) { // has required fields but JSON element is null
          throw new IllegalArgumentException(String.format("The required field(s) %s in FundValuationRequest is not found in the empty JSON string", FundValuationRequest.openapiRequiredFields.toString()));
        }
      }

      // check to make sure all required properties/fields are present in the JSON string
      for (String requiredField : FundValuationRequest.openapiRequiredFields) {
        if (jsonElement.getAsJsonObject().get(requiredField) == null) {
          throw new IllegalArgumentException(String.format("The required field `%s` is not found in the JSON string: %s", requiredField, jsonElement.toString()));
        }
      }
        JsonObject jsonObj = jsonElement.getAsJsonObject();
      // ensure the json data is an array
      if (!jsonObj.get("metrics").isJsonArray()) {
        throw new IllegalArgumentException(String.format("Expected the field `metrics` to be an array in the JSON string but got `%s`", jsonObj.get("metrics").toString()));
      }

      JsonArray jsonArraymetrics = jsonObj.getAsJsonArray("metrics");
      // validate the required field `metrics` (array)
      for (int i = 0; i < jsonArraymetrics.size(); i++) {
        AggregateSpec.validateJsonElement(jsonArraymetrics.get(i));
      };
      // ensure the optional json data is an array if present
      if (jsonObj.get("groupBy") != null && !jsonObj.get("groupBy").isJsonNull() && !jsonObj.get("groupBy").isJsonArray()) {
        throw new IllegalArgumentException(String.format("Expected the field `groupBy` to be an array in the JSON string but got `%s`", jsonObj.get("groupBy").toString()));
      }
      if (jsonObj.get("filters") != null && !jsonObj.get("filters").isJsonNull()) {
        JsonArray jsonArrayfilters = jsonObj.getAsJsonArray("filters");
        if (jsonArrayfilters != null) {
          // ensure the json data is an array
          if (!jsonObj.get("filters").isJsonArray()) {
            throw new IllegalArgumentException(String.format("Expected the field `filters` to be an array in the JSON string but got `%s`", jsonObj.get("filters").toString()));
          }

          // validate the optional field `filters` (array)
          for (int i = 0; i < jsonArrayfilters.size(); i++) {
            PropertyFilter.validateJsonElement(jsonArrayfilters.get(i));
          };
        }
      }
      if (jsonObj.get("sort") != null && !jsonObj.get("sort").isJsonNull()) {
        JsonArray jsonArraysort = jsonObj.getAsJsonArray("sort");
        if (jsonArraysort != null) {
          // ensure the json data is an array
          if (!jsonObj.get("sort").isJsonArray()) {
            throw new IllegalArgumentException(String.format("Expected the field `sort` to be an array in the JSON string but got `%s`", jsonObj.get("sort").toString()));
          }

          // validate the optional field `sort` (array)
          for (int i = 0; i < jsonArraysort.size(); i++) {
            OrderBySpec.validateJsonElement(jsonArraysort.get(i));
          };
        }
      }
      // validate the optional field `includeOrderFlow`
      if (jsonObj.get("includeOrderFlow") != null && !jsonObj.get("includeOrderFlow").isJsonNull()) {
        OrderFlowConfiguration.validateJsonElement(jsonObj.get("includeOrderFlow"));
      }
      // validate the required field `fundValuationSchedule`
      FundValuationSchedule.validateJsonElement(jsonObj.get("fundValuationSchedule"));
      // validate the optional field `marketDataOverrides`
      if (jsonObj.get("marketDataOverrides") != null && !jsonObj.get("marketDataOverrides").isJsonNull()) {
        MarketDataOverrides.validateJsonElement(jsonObj.get("marketDataOverrides"));
      }
      // validate the optional field `corporateActionSourceId`
      if (jsonObj.get("corporateActionSourceId") != null && !jsonObj.get("corporateActionSourceId").isJsonNull()) {
        ResourceId.validateJsonElement(jsonObj.get("corporateActionSourceId"));
      }
  }

  public static class CustomTypeAdapterFactory implements TypeAdapterFactory {
    @SuppressWarnings("unchecked")
    @Override
    public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {
       if (!FundValuationRequest.class.isAssignableFrom(type.getRawType())) {
         return null; // this class only serializes 'FundValuationRequest' and its subtypes
       }
       final TypeAdapter<JsonElement> elementAdapter = gson.getAdapter(JsonElement.class);
       final TypeAdapter<FundValuationRequest> thisAdapter
                        = gson.getDelegateAdapter(this, TypeToken.get(FundValuationRequest.class));

       return (TypeAdapter<T>) new TypeAdapter<FundValuationRequest>() {
           @Override
           public void write(JsonWriter out, FundValuationRequest value) throws IOException {
             JsonObject obj = thisAdapter.toJsonTree(value).getAsJsonObject();
             elementAdapter.write(out, obj);
           }

           @Override
           public FundValuationRequest read(JsonReader in) throws IOException {
             JsonElement jsonElement = elementAdapter.read(in);
             validateJsonElement(jsonElement);
             return thisAdapter.fromJsonTree(jsonElement);
           }

       }.nullSafe();
    }
  }

 /**
  * Create an instance of FundValuationRequest given an JSON string
  *
  * @param jsonString JSON string
  * @return An instance of FundValuationRequest
  * @throws IOException if the JSON string is invalid with respect to FundValuationRequest
  */
  public static FundValuationRequest fromJson(String jsonString) throws IOException {
    return JSON.getGson().fromJson(jsonString, FundValuationRequest.class);
  }

 /**
  * Convert an instance of FundValuationRequest to an JSON string
  *
  * @return JSON string
  */
  public String toJson() {
    return JSON.getGson().toJson(this);
  }
}
