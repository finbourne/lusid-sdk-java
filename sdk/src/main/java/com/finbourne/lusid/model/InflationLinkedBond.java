/*
 * LUSID API
 *
 * Contact: info@finbourne.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

package com.finbourne.lusid.model;

import java.util.Objects;
import com.finbourne.lusid.model.FlowConventions;
import com.finbourne.lusid.model.InflationIndexConventions;
import com.finbourne.lusid.model.LusidInstrument;
import com.finbourne.lusid.model.RoundingConvention;
import com.finbourne.lusid.model.TradingConventions;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;
import java.time.OffsetDateTime;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import org.openapitools.jackson.nullable.JsonNullable;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonArray;
import com.google.gson.JsonDeserializationContext;
import com.google.gson.JsonDeserializer;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParseException;
import com.google.gson.TypeAdapterFactory;
import com.google.gson.reflect.TypeToken;
import com.google.gson.TypeAdapter;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;

import java.lang.reflect.Type;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Map.Entry;
import java.util.Set;

import com.finbourne.lusid.JSON;

/**
 * Inflation Linked Bond.
 */
@jakarta.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen")
public class InflationLinkedBond extends LusidInstrument {
  public static final String SERIALIZED_NAME_START_DATE = "startDate";
  @SerializedName(SERIALIZED_NAME_START_DATE)
  private OffsetDateTime startDate;

  public static final String SERIALIZED_NAME_MATURITY_DATE = "maturityDate";
  @SerializedName(SERIALIZED_NAME_MATURITY_DATE)
  private OffsetDateTime maturityDate;

  public static final String SERIALIZED_NAME_FLOW_CONVENTIONS = "flowConventions";
  @SerializedName(SERIALIZED_NAME_FLOW_CONVENTIONS)
  private FlowConventions flowConventions;

  public static final String SERIALIZED_NAME_INFLATION_INDEX_CONVENTIONS = "inflationIndexConventions";
  @SerializedName(SERIALIZED_NAME_INFLATION_INDEX_CONVENTIONS)
  private InflationIndexConventions inflationIndexConventions;

  public static final String SERIALIZED_NAME_COUPON_RATE = "couponRate";
  @SerializedName(SERIALIZED_NAME_COUPON_RATE)
  private java.math.BigDecimal couponRate;

  public static final String SERIALIZED_NAME_IDENTIFIERS = "identifiers";
  @SerializedName(SERIALIZED_NAME_IDENTIFIERS)
  private Map<String, String> identifiers;

  public static final String SERIALIZED_NAME_BASE_C_P_I = "baseCPI";
  @SerializedName(SERIALIZED_NAME_BASE_C_P_I)
  private java.math.BigDecimal baseCPI;

  public static final String SERIALIZED_NAME_BASE_C_P_I_DATE = "baseCPIDate";
  @SerializedName(SERIALIZED_NAME_BASE_C_P_I_DATE)
  private OffsetDateTime baseCPIDate;

  public static final String SERIALIZED_NAME_CALCULATION_TYPE = "calculationType";
  @SerializedName(SERIALIZED_NAME_CALCULATION_TYPE)
  private String calculationType;

  public static final String SERIALIZED_NAME_EX_DIVIDEND_DAYS = "exDividendDays";
  @SerializedName(SERIALIZED_NAME_EX_DIVIDEND_DAYS)
  private Integer exDividendDays;

  public static final String SERIALIZED_NAME_INDEX_PRECISION = "indexPrecision";
  @SerializedName(SERIALIZED_NAME_INDEX_PRECISION)
  private Integer indexPrecision;

  public static final String SERIALIZED_NAME_PRINCIPAL = "principal";
  @SerializedName(SERIALIZED_NAME_PRINCIPAL)
  private java.math.BigDecimal principal;

  public static final String SERIALIZED_NAME_PRINCIPAL_PROTECTION = "principalProtection";
  @SerializedName(SERIALIZED_NAME_PRINCIPAL_PROTECTION)
  private Boolean principalProtection;

  public static final String SERIALIZED_NAME_STUB_TYPE = "stubType";
  @SerializedName(SERIALIZED_NAME_STUB_TYPE)
  private String stubType;

  public static final String SERIALIZED_NAME_ROUNDING_CONVENTIONS = "roundingConventions";
  @SerializedName(SERIALIZED_NAME_ROUNDING_CONVENTIONS)
  private List<RoundingConvention> roundingConventions;

  public static final String SERIALIZED_NAME_TRADING_CONVENTIONS = "tradingConventions";
  @SerializedName(SERIALIZED_NAME_TRADING_CONVENTIONS)
  private TradingConventions tradingConventions;

  public static final String SERIALIZED_NAME_ORIGINAL_ISSUE_PRICE = "originalIssuePrice";
  @SerializedName(SERIALIZED_NAME_ORIGINAL_ISSUE_PRICE)
  private java.math.BigDecimal originalIssuePrice;

  public InflationLinkedBond() {
    // this.instrumentType = this.getClass().getSimpleName();
  }

  public InflationLinkedBond startDate(OffsetDateTime startDate) {
    
    this.startDate = startDate;
    return this;
  }

   /**
   * The start date of the bond.
   * @return startDate
  **/
  @jakarta.annotation.Nonnull
  public OffsetDateTime getStartDate() {
    return startDate;
  }


  public void setStartDate(OffsetDateTime startDate) {
    this.startDate = startDate;
  }


  public InflationLinkedBond maturityDate(OffsetDateTime maturityDate) {
    
    this.maturityDate = maturityDate;
    return this;
  }

   /**
   * The final maturity date of the instrument. This means the last date on which the instruments makes a payment of any amount.  For the avoidance of doubt, that is not necessarily prior to its last sensitivity date for the purposes of risk; e.g. instruments such as  Constant Maturity Swaps (CMS) often have sensitivities to rates that may well be observed or set prior to the maturity date, but refer to a termination date beyond it.
   * @return maturityDate
  **/
  @jakarta.annotation.Nonnull
  public OffsetDateTime getMaturityDate() {
    return maturityDate;
  }


  public void setMaturityDate(OffsetDateTime maturityDate) {
    this.maturityDate = maturityDate;
  }


  public InflationLinkedBond flowConventions(FlowConventions flowConventions) {
    
    this.flowConventions = flowConventions;
    return this;
  }

   /**
   * Get flowConventions
   * @return flowConventions
  **/
  @jakarta.annotation.Nonnull
  public FlowConventions getFlowConventions() {
    return flowConventions;
  }


  public void setFlowConventions(FlowConventions flowConventions) {
    this.flowConventions = flowConventions;
  }


  public InflationLinkedBond inflationIndexConventions(InflationIndexConventions inflationIndexConventions) {
    
    this.inflationIndexConventions = inflationIndexConventions;
    return this;
  }

   /**
   * Get inflationIndexConventions
   * @return inflationIndexConventions
  **/
  @jakarta.annotation.Nonnull
  public InflationIndexConventions getInflationIndexConventions() {
    return inflationIndexConventions;
  }


  public void setInflationIndexConventions(InflationIndexConventions inflationIndexConventions) {
    this.inflationIndexConventions = inflationIndexConventions;
  }


  public InflationLinkedBond couponRate(java.math.BigDecimal couponRate) {
    
    this.couponRate = couponRate;
    return this;
  }

   /**
   * Simple coupon rate.
   * @return couponRate
  **/
  @jakarta.annotation.Nonnull
  public java.math.BigDecimal getCouponRate() {
    return couponRate;
  }


  public void setCouponRate(java.math.BigDecimal couponRate) {
    this.couponRate = couponRate;
  }


  public InflationLinkedBond identifiers(Map<String, String> identifiers) {
    
    this.identifiers = identifiers;
    return this;
  }

  public InflationLinkedBond putIdentifiersItem(String key, String identifiersItem) {
    if (this.identifiers == null) {
      this.identifiers = new HashMap<>();
    }
    this.identifiers.put(key, identifiersItem);
    return this;
  }

   /**
   * External market codes and identifiers for the bond, e.g. ISIN.
   * @return identifiers
  **/
  @jakarta.annotation.Nullable
  public Map<String, String> getIdentifiers() {
    return identifiers;
  }


  public void setIdentifiers(Map<String, String> identifiers) {
    this.identifiers = identifiers;
  }


  public InflationLinkedBond baseCPI(java.math.BigDecimal baseCPI) {
    
    this.baseCPI = baseCPI;
    return this;
  }

   /**
   * BaseCPI value. This is optional, if not provided the BaseCPI value will be calculated from the BaseCPIDate,  if that too is not present the StartDate will be used.     If provided then this value will always set the BaseCPI on this bond.     The BaseCPI of an inflation linked bond is calculated using the following logic:  - If a BaseCPI value is provided, this is used.  - Otherwise, if BaseCPIDate is provided, the CPI for this date is calculated and used.  - Otherwise, the CPI for the StartDate is calculated and used.     Note that if both BaseCPI and BaseCPIDate are set, the BaseCPI value will be used and the BaseCPIDate  will be ignored but can still be added for informative purposes.     Some bonds are issued with a BaseCPI date that does not correspond to the StartDate CPI value, in this  case the value should be provided here or with the BaseCPIDate.
   * @return baseCPI
  **/
  @jakarta.annotation.Nullable
  public java.math.BigDecimal getBaseCPI() {
    return baseCPI;
  }


  public void setBaseCPI(java.math.BigDecimal baseCPI) {
    this.baseCPI = baseCPI;
  }


  public InflationLinkedBond baseCPIDate(OffsetDateTime baseCPIDate) {
    
    this.baseCPIDate = baseCPIDate;
    return this;
  }

   /**
   * BaseCPIDate. This is optional. Gives the date that the BaseCPI is calculated for.     Note this is an un-lagged date (similar to StartDate) so the Bond ObservationLag will  be applied to this date when calculating the CPI.     The BaseCPI of an inflation linked bond is calculated using the following logic:  - If a BaseCPI value is provided, this is used.  - Otherwise, if BaseCPIDate is provided, the CPI for this date is calculated and used.  - Otherwise, the CPI for the StartDate is calculated and used.     Note that if both BaseCPI and BaseCPIDate are set, the BaseCPI value will be used and the BaseCPIDate  will be ignored but can still be added for informative purposes.     Some bonds are issued with a BaseCPI date that does not correspond to the StartDate CPI value, in this  case the value should be provided here or with the actual BaseCPI.
   * @return baseCPIDate
  **/
  @jakarta.annotation.Nullable
  public OffsetDateTime getBaseCPIDate() {
    return baseCPIDate;
  }


  public void setBaseCPIDate(OffsetDateTime baseCPIDate) {
    this.baseCPIDate = baseCPIDate;
  }


  public InflationLinkedBond calculationType(String calculationType) {
    
    this.calculationType = calculationType;
    return this;
  }

   /**
   * The calculation type applied to the bond coupon and principal amount.  The default CalculationType is &#x60;Standard&#x60;.    Supported string (enumeration) values are: [Standard, Quarterly, Ratio, Brazil, StandardAccruedOnly, RatioAccruedOnly, StandardWithCappedAccruedInterest].
   * @return calculationType
  **/
  @jakarta.annotation.Nullable
  public String getCalculationType() {
    return calculationType;
  }


  public void setCalculationType(String calculationType) {
    this.calculationType = calculationType;
  }


  public InflationLinkedBond exDividendDays(Integer exDividendDays) {
    
    this.exDividendDays = exDividendDays;
    return this;
  }

   /**
   * Number of Good Business Days before the next coupon payment, in which the bond goes ex-dividend.
   * @return exDividendDays
  **/
  @jakarta.annotation.Nullable
  public Integer getExDividendDays() {
    return exDividendDays;
  }


  public void setExDividendDays(Integer exDividendDays) {
    this.exDividendDays = exDividendDays;
  }


  public InflationLinkedBond indexPrecision(Integer indexPrecision) {
    
    this.indexPrecision = indexPrecision;
    return this;
  }

   /**
   * Number of decimal places used to round IndexRatio. This defaults to 5 if not set.
   * @return indexPrecision
  **/
  @jakarta.annotation.Nullable
  public Integer getIndexPrecision() {
    return indexPrecision;
  }


  public void setIndexPrecision(Integer indexPrecision) {
    this.indexPrecision = indexPrecision;
  }


  public InflationLinkedBond principal(java.math.BigDecimal principal) {
    
    this.principal = principal;
    return this;
  }

   /**
   * The face-value or principal for the bond at outset.
   * @return principal
  **/
  @jakarta.annotation.Nonnull
  public java.math.BigDecimal getPrincipal() {
    return principal;
  }


  public void setPrincipal(java.math.BigDecimal principal) {
    this.principal = principal;
  }


  public InflationLinkedBond principalProtection(Boolean principalProtection) {
    
    this.principalProtection = principalProtection;
    return this;
  }

   /**
   * If true then the principal is protected in that the redemption amount will be at least the face value (Principal).  This is typically set to true for inflation linked bonds issued by the United States and France (for example).  This is typically set to false for inflation linked bonds issued by the United Kingdom (post 2005).  For other sovereigns this can vary from issue to issue.  If not set this property defaults to true.  This is sometimes referred to as Deflation protection or an inflation floor of 0%.
   * @return principalProtection
  **/
  @jakarta.annotation.Nullable
  public Boolean getPrincipalProtection() {
    return principalProtection;
  }


  public void setPrincipalProtection(Boolean principalProtection) {
    this.principalProtection = principalProtection;
  }


  public InflationLinkedBond stubType(String stubType) {
    
    this.stubType = stubType;
    return this;
  }

   /**
   * StubType. Most Inflation linked bonds have a ShortFront stub type so this is the default, however in some cases  with a long front stub LongFront should be selected.  StubType Both is not supported for InflationLinkedBonds.    Supported string (enumeration) values are: [ShortFront, ShortBack, LongBack, LongFront, Both].
   * @return stubType
  **/
  @jakarta.annotation.Nullable
  public String getStubType() {
    return stubType;
  }


  public void setStubType(String stubType) {
    this.stubType = stubType;
  }


  public InflationLinkedBond roundingConventions(List<RoundingConvention> roundingConventions) {
    
    this.roundingConventions = roundingConventions;
    return this;
  }

  public InflationLinkedBond addRoundingConventionsItem(RoundingConvention roundingConventionsItem) {
    if (this.roundingConventions == null) {
      this.roundingConventions = new ArrayList<>();
    }
    this.roundingConventions.add(roundingConventionsItem);
    return this;
  }

   /**
   * Rounding conventions for analytics, if any.
   * @return roundingConventions
  **/
  @jakarta.annotation.Nullable
  public List<RoundingConvention> getRoundingConventions() {
    return roundingConventions;
  }


  public void setRoundingConventions(List<RoundingConvention> roundingConventions) {
    this.roundingConventions = roundingConventions;
  }


  public InflationLinkedBond tradingConventions(TradingConventions tradingConventions) {
    
    this.tradingConventions = tradingConventions;
    return this;
  }

   /**
   * Get tradingConventions
   * @return tradingConventions
  **/
  @jakarta.annotation.Nullable
  public TradingConventions getTradingConventions() {
    return tradingConventions;
  }


  public void setTradingConventions(TradingConventions tradingConventions) {
    this.tradingConventions = tradingConventions;
  }


  public InflationLinkedBond originalIssuePrice(java.math.BigDecimal originalIssuePrice) {
    
    this.originalIssuePrice = originalIssuePrice;
    return this;
  }

   /**
   * The price the bond was issued at. This is to be entered as a percentage of par, for example a value of 98.5 would represent 98.5%.
   * @return originalIssuePrice
  **/
  @jakarta.annotation.Nullable
  public java.math.BigDecimal getOriginalIssuePrice() {
    return originalIssuePrice;
  }


  public void setOriginalIssuePrice(java.math.BigDecimal originalIssuePrice) {
    this.originalIssuePrice = originalIssuePrice;
  }



  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    InflationLinkedBond inflationLinkedBond = (InflationLinkedBond) o;
    return Objects.equals(this.startDate, inflationLinkedBond.startDate) &&
        Objects.equals(this.maturityDate, inflationLinkedBond.maturityDate) &&
        Objects.equals(this.flowConventions, inflationLinkedBond.flowConventions) &&
        Objects.equals(this.inflationIndexConventions, inflationLinkedBond.inflationIndexConventions) &&
        (this.couponRate.compareTo(inflationLinkedBond.getCouponRate()) == 0) &&
        Objects.equals(this.identifiers, inflationLinkedBond.identifiers) &&
        (this.baseCPI.compareTo(inflationLinkedBond.getBaseCPI()) == 0) &&
        Objects.equals(this.baseCPIDate, inflationLinkedBond.baseCPIDate) &&
        Objects.equals(this.calculationType, inflationLinkedBond.calculationType) &&
        Objects.equals(this.exDividendDays, inflationLinkedBond.exDividendDays) &&
        Objects.equals(this.indexPrecision, inflationLinkedBond.indexPrecision) &&
        (this.principal.compareTo(inflationLinkedBond.getPrincipal()) == 0) &&
        Objects.equals(this.principalProtection, inflationLinkedBond.principalProtection) &&
        Objects.equals(this.stubType, inflationLinkedBond.stubType) &&
        Objects.equals(this.roundingConventions, inflationLinkedBond.roundingConventions) &&
        Objects.equals(this.tradingConventions, inflationLinkedBond.tradingConventions) &&
        (this.originalIssuePrice.compareTo(inflationLinkedBond.getOriginalIssuePrice()) == 0) &&
        super.equals(o);
  }

  private static <T> boolean equalsNullable(JsonNullable<T> a, JsonNullable<T> b) {
    return a == b || (a != null && b != null && a.isPresent() && b.isPresent() && Objects.deepEquals(a.get(), b.get()));
  }

  @Override
  public int hashCode() {
    return Objects.hash(startDate, maturityDate, flowConventions, inflationIndexConventions, couponRate, identifiers, baseCPI, baseCPIDate, calculationType, exDividendDays, indexPrecision, principal, principalProtection, stubType, roundingConventions, tradingConventions, originalIssuePrice, super.hashCode());
  }

  private static <T> int hashCodeNullable(JsonNullable<T> a) {
    if (a == null) {
      return 1;
    }
    return a.isPresent() ? Arrays.deepHashCode(new Object[]{a.get()}) : 31;
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class InflationLinkedBond {\n");
    sb.append("    ").append(toIndentedString(super.toString())).append("\n");
    sb.append("    startDate: ").append(toIndentedString(startDate)).append("\n");
    sb.append("    maturityDate: ").append(toIndentedString(maturityDate)).append("\n");
    sb.append("    flowConventions: ").append(toIndentedString(flowConventions)).append("\n");
    sb.append("    inflationIndexConventions: ").append(toIndentedString(inflationIndexConventions)).append("\n");
    sb.append("    couponRate: ").append(toIndentedString(couponRate)).append("\n");
    sb.append("    identifiers: ").append(toIndentedString(identifiers)).append("\n");
    sb.append("    baseCPI: ").append(toIndentedString(baseCPI)).append("\n");
    sb.append("    baseCPIDate: ").append(toIndentedString(baseCPIDate)).append("\n");
    sb.append("    calculationType: ").append(toIndentedString(calculationType)).append("\n");
    sb.append("    exDividendDays: ").append(toIndentedString(exDividendDays)).append("\n");
    sb.append("    indexPrecision: ").append(toIndentedString(indexPrecision)).append("\n");
    sb.append("    principal: ").append(toIndentedString(principal)).append("\n");
    sb.append("    principalProtection: ").append(toIndentedString(principalProtection)).append("\n");
    sb.append("    stubType: ").append(toIndentedString(stubType)).append("\n");
    sb.append("    roundingConventions: ").append(toIndentedString(roundingConventions)).append("\n");
    sb.append("    tradingConventions: ").append(toIndentedString(tradingConventions)).append("\n");
    sb.append("    originalIssuePrice: ").append(toIndentedString(originalIssuePrice)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }


  public static HashSet<String> openapiFields;
  public static HashSet<String> openapiRequiredFields;

  static {
    // a set of all properties/fields (JSON key names)
    openapiFields = new HashSet<String>();
    openapiFields.add("instrumentType");
    openapiFields.add("startDate");
    openapiFields.add("maturityDate");
    openapiFields.add("flowConventions");
    openapiFields.add("inflationIndexConventions");
    openapiFields.add("couponRate");
    openapiFields.add("identifiers");
    openapiFields.add("baseCPI");
    openapiFields.add("baseCPIDate");
    openapiFields.add("calculationType");
    openapiFields.add("exDividendDays");
    openapiFields.add("indexPrecision");
    openapiFields.add("principal");
    openapiFields.add("principalProtection");
    openapiFields.add("stubType");
    openapiFields.add("roundingConventions");
    openapiFields.add("tradingConventions");
    openapiFields.add("originalIssuePrice");

    // a set of required properties/fields (JSON key names)
    openapiRequiredFields = new HashSet<String>();
    openapiRequiredFields.add("startDate");
    openapiRequiredFields.add("maturityDate");
    openapiRequiredFields.add("flowConventions");
    openapiRequiredFields.add("inflationIndexConventions");
    openapiRequiredFields.add("couponRate");
    openapiRequiredFields.add("principal");
    openapiRequiredFields.add("instrumentType");
  }

 /**
  * Validates the JSON Element and throws an exception if issues found
  *
  * @param jsonElement JSON Element
  * @throws IOException if the JSON Element is invalid with respect to InflationLinkedBond
  */
  public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      if (jsonElement == null) {
        if (!InflationLinkedBond.openapiRequiredFields.isEmpty()) { // has required fields but JSON element is null
          throw new IllegalArgumentException(String.format("The required field(s) %s in InflationLinkedBond is not found in the empty JSON string", InflationLinkedBond.openapiRequiredFields.toString()));
        }
      }

      // check to make sure all required properties/fields are present in the JSON string
      for (String requiredField : InflationLinkedBond.openapiRequiredFields) {
        if (jsonElement.getAsJsonObject().get(requiredField) == null) {
          throw new IllegalArgumentException(String.format("The required field `%s` is not found in the JSON string: %s", requiredField, jsonElement.toString()));
        }
      }
  }

  public static class CustomTypeAdapterFactory implements TypeAdapterFactory {
    @SuppressWarnings("unchecked")
    @Override
    public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {
       if (!InflationLinkedBond.class.isAssignableFrom(type.getRawType())) {
         return null; // this class only serializes 'InflationLinkedBond' and its subtypes
       }
       final TypeAdapter<JsonElement> elementAdapter = gson.getAdapter(JsonElement.class);
       final TypeAdapter<InflationLinkedBond> thisAdapter
                        = gson.getDelegateAdapter(this, TypeToken.get(InflationLinkedBond.class));

       return (TypeAdapter<T>) new TypeAdapter<InflationLinkedBond>() {
           @Override
           public void write(JsonWriter out, InflationLinkedBond value) throws IOException {
             JsonObject obj = thisAdapter.toJsonTree(value).getAsJsonObject();
             elementAdapter.write(out, obj);
           }

           @Override
           public InflationLinkedBond read(JsonReader in) throws IOException {
             JsonElement jsonElement = elementAdapter.read(in);
             validateJsonElement(jsonElement);
             return thisAdapter.fromJsonTree(jsonElement);
           }

       }.nullSafe();
    }
  }

 /**
  * Create an instance of InflationLinkedBond given an JSON string
  *
  * @param jsonString JSON string
  * @return An instance of InflationLinkedBond
  * @throws IOException if the JSON string is invalid with respect to InflationLinkedBond
  */
  public static InflationLinkedBond fromJson(String jsonString) throws IOException {
    return JSON.getGson().fromJson(jsonString, InflationLinkedBond.class);
  }

 /**
  * Convert an instance of InflationLinkedBond to an JSON string
  *
  * @return JSON string
  */
  public String toJson() {
    return JSON.getGson().toJson(this);
  }
}
