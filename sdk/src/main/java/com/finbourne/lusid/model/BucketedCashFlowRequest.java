/*
 * LUSID API
 *
 * Contact: info@finbourne.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

package com.finbourne.lusid.model;

import java.util.Objects;
import com.finbourne.lusid.model.ResourceId;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;
import java.time.OffsetDateTime;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import org.openapitools.jackson.nullable.JsonNullable;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonArray;
import com.google.gson.JsonDeserializationContext;
import com.google.gson.JsonDeserializer;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParseException;
import com.google.gson.TypeAdapterFactory;
import com.google.gson.reflect.TypeToken;
import com.google.gson.TypeAdapter;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;

import java.lang.reflect.Type;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Map.Entry;
import java.util.Set;

import com.finbourne.lusid.JSON;

/**
 * Specification class consisting of parameters for BucketedCashFlow endpoint.
 */
@jakarta.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen")
public class BucketedCashFlowRequest {
  public static final String SERIALIZED_NAME_ROUNDING_METHOD = "roundingMethod";
  @SerializedName(SERIALIZED_NAME_ROUNDING_METHOD)
  private String roundingMethod;

  public static final String SERIALIZED_NAME_BUCKETING_DATES = "bucketingDates";
  @SerializedName(SERIALIZED_NAME_BUCKETING_DATES)
  private List<OffsetDateTime> bucketingDates;

  public static final String SERIALIZED_NAME_BUCKET_TENORS = "bucketTenors";
  @SerializedName(SERIALIZED_NAME_BUCKET_TENORS)
  private List<String> bucketTenors;

  public static final String SERIALIZED_NAME_EFFECTIVE_AT = "effectiveAt";
  @SerializedName(SERIALIZED_NAME_EFFECTIVE_AT)
  private String effectiveAt;

  public static final String SERIALIZED_NAME_WINDOW_START = "windowStart";
  @SerializedName(SERIALIZED_NAME_WINDOW_START)
  private String windowStart;

  public static final String SERIALIZED_NAME_WINDOW_END = "windowEnd";
  @SerializedName(SERIALIZED_NAME_WINDOW_END)
  private String windowEnd;

  public static final String SERIALIZED_NAME_RECIPE_ID = "recipeId";
  @SerializedName(SERIALIZED_NAME_RECIPE_ID)
  private ResourceId recipeId;

  public static final String SERIALIZED_NAME_REPORT_CURRENCY = "reportCurrency";
  @SerializedName(SERIALIZED_NAME_REPORT_CURRENCY)
  private String reportCurrency;

  public static final String SERIALIZED_NAME_GROUP_BY = "groupBy";
  @SerializedName(SERIALIZED_NAME_GROUP_BY)
  private List<String> groupBy;

  public static final String SERIALIZED_NAME_ADDRESSES = "addresses";
  @SerializedName(SERIALIZED_NAME_ADDRESSES)
  private List<String> addresses;

  public static final String SERIALIZED_NAME_EQUIP_WITH_SUBTOTALS = "equipWithSubtotals";
  @SerializedName(SERIALIZED_NAME_EQUIP_WITH_SUBTOTALS)
  private Boolean equipWithSubtotals;

  public static final String SERIALIZED_NAME_AS_AT = "asAt";
  @SerializedName(SERIALIZED_NAME_AS_AT)
  private OffsetDateTime asAt;

  public static final String SERIALIZED_NAME_EXCLUDE_UNSETTLED_TRADES = "excludeUnsettledTrades";
  @SerializedName(SERIALIZED_NAME_EXCLUDE_UNSETTLED_TRADES)
  private Boolean excludeUnsettledTrades;

  public static final String SERIALIZED_NAME_CASH_FLOW_TYPE = "cashFlowType";
  @SerializedName(SERIALIZED_NAME_CASH_FLOW_TYPE)
  private String cashFlowType;

  public BucketedCashFlowRequest() {
  }

  public BucketedCashFlowRequest roundingMethod(String roundingMethod) {
    
    this.roundingMethod = roundingMethod;
    return this;
  }

   /**
   * When bucketing, there is not a unique way to allocate the bucket points.  RoundingMethod Supported string (enumeration) values are: [RoundDown, RoundUp].
   * @return roundingMethod
  **/
  @jakarta.annotation.Nonnull
  public String getRoundingMethod() {
    return roundingMethod;
  }


  public void setRoundingMethod(String roundingMethod) {
    this.roundingMethod = roundingMethod;
  }


  public BucketedCashFlowRequest bucketingDates(List<OffsetDateTime> bucketingDates) {
    
    this.bucketingDates = bucketingDates;
    return this;
  }

  public BucketedCashFlowRequest addBucketingDatesItem(OffsetDateTime bucketingDatesItem) {
    if (this.bucketingDates == null) {
      this.bucketingDates = new ArrayList<>();
    }
    this.bucketingDates.add(bucketingDatesItem);
    return this;
  }

   /**
   * A list of dates to perform cashflow bucketing upon.  If this is provided, the list of tenors for bucketing should be empty.
   * @return bucketingDates
  **/
  @jakarta.annotation.Nullable
  public List<OffsetDateTime> getBucketingDates() {
    return bucketingDates;
  }


  public void setBucketingDates(List<OffsetDateTime> bucketingDates) {
    this.bucketingDates = bucketingDates;
  }


  public BucketedCashFlowRequest bucketTenors(List<String> bucketTenors) {
    
    this.bucketTenors = bucketTenors;
    return this;
  }

  public BucketedCashFlowRequest addBucketTenorsItem(String bucketTenorsItem) {
    if (this.bucketTenors == null) {
      this.bucketTenors = new ArrayList<>();
    }
    this.bucketTenors.add(bucketTenorsItem);
    return this;
  }

   /**
   * A list of tenors to perform cashflow bucketing upon.  If this is provided, the list of dates for bucketing should be empty.
   * @return bucketTenors
  **/
  @jakarta.annotation.Nullable
  public List<String> getBucketTenors() {
    return bucketTenors;
  }


  public void setBucketTenors(List<String> bucketTenors) {
    this.bucketTenors = bucketTenors;
  }


  public BucketedCashFlowRequest effectiveAt(String effectiveAt) {
    
    this.effectiveAt = effectiveAt;
    return this;
  }

   /**
   * The valuation (pricing) effective datetime or cut label (inclusive) at which to evaluate the cashflows.  This determines whether cashflows are evaluated in a historic or forward looking context and will, for certain models, affect where data is looked up.  For example, on a swap if the effectiveAt is in the middle of the window, cashflows before it will be historic and resets assumed to exist where if the effectiveAt  is before the start of the range they are forward looking and will be expectations assuming the model supports that.  There is evidently a presumption here about availability of data and that the effectiveAt is realistically on or before the real-world today.
   * @return effectiveAt
  **/
  @jakarta.annotation.Nullable
  public String getEffectiveAt() {
    return effectiveAt;
  }


  public void setEffectiveAt(String effectiveAt) {
    this.effectiveAt = effectiveAt;
  }


  public BucketedCashFlowRequest windowStart(String windowStart) {
    
    this.windowStart = windowStart;
    return this;
  }

   /**
   * The lower bound effective datetime or cut label (inclusive) from which to retrieve the cashflows.  There is no lower bound if this is not specified.
   * @return windowStart
  **/
  @jakarta.annotation.Nullable
  public String getWindowStart() {
    return windowStart;
  }


  public void setWindowStart(String windowStart) {
    this.windowStart = windowStart;
  }


  public BucketedCashFlowRequest windowEnd(String windowEnd) {
    
    this.windowEnd = windowEnd;
    return this;
  }

   /**
   * The upper bound effective datetime or cut label (inclusive) from which to retrieve the cashflows.  The upper bound defaults to &#39;today&#39; if it is not specified
   * @return windowEnd
  **/
  @jakarta.annotation.Nullable
  public String getWindowEnd() {
    return windowEnd;
  }


  public void setWindowEnd(String windowEnd) {
    this.windowEnd = windowEnd;
  }


  public BucketedCashFlowRequest recipeId(ResourceId recipeId) {
    
    this.recipeId = recipeId;
    return this;
  }

   /**
   * Get recipeId
   * @return recipeId
  **/
  @jakarta.annotation.Nullable
  public ResourceId getRecipeId() {
    return recipeId;
  }


  public void setRecipeId(ResourceId recipeId) {
    this.recipeId = recipeId;
  }


  public BucketedCashFlowRequest reportCurrency(String reportCurrency) {
    
    this.reportCurrency = reportCurrency;
    return this;
  }

   /**
   * Three letter ISO currency string indicating what currency to report in for ReportCurrency denominated queries.
   * @return reportCurrency
  **/
  @jakarta.annotation.Nullable
  public String getReportCurrency() {
    return reportCurrency;
  }


  public void setReportCurrency(String reportCurrency) {
    this.reportCurrency = reportCurrency;
  }


  public BucketedCashFlowRequest groupBy(List<String> groupBy) {
    
    this.groupBy = groupBy;
    return this;
  }

  public BucketedCashFlowRequest addGroupByItem(String groupByItem) {
    if (this.groupBy == null) {
      this.groupBy = new ArrayList<>();
    }
    this.groupBy.add(groupByItem);
    return this;
  }

   /**
   * The set of items by which to perform grouping. This primarily matters when one or more of the metric operators is a mapping  that reduces set size, e.g. sum or proportion. The group-by statement determines the set of keys by which to break the results out.
   * @return groupBy
  **/
  @jakarta.annotation.Nullable
  public List<String> getGroupBy() {
    return groupBy;
  }


  public void setGroupBy(List<String> groupBy) {
    this.groupBy = groupBy;
  }


  public BucketedCashFlowRequest addresses(List<String> addresses) {
    
    this.addresses = addresses;
    return this;
  }

  public BucketedCashFlowRequest addAddressesItem(String addressesItem) {
    if (this.addresses == null) {
      this.addresses = new ArrayList<>();
    }
    this.addresses.add(addressesItem);
    return this;
  }

   /**
   * The set of items that the user wishes to see in the results. If empty, will be defaulted to standard ones.
   * @return addresses
  **/
  @jakarta.annotation.Nullable
  public List<String> getAddresses() {
    return addresses;
  }


  public void setAddresses(List<String> addresses) {
    this.addresses = addresses;
  }


  public BucketedCashFlowRequest equipWithSubtotals(Boolean equipWithSubtotals) {
    
    this.equipWithSubtotals = equipWithSubtotals;
    return this;
  }

   /**
   * Flag directing the Valuation call to populate the results with subtotals of aggregates.
   * @return equipWithSubtotals
  **/
  @jakarta.annotation.Nullable
  public Boolean getEquipWithSubtotals() {
    return equipWithSubtotals;
  }


  public void setEquipWithSubtotals(Boolean equipWithSubtotals) {
    this.equipWithSubtotals = equipWithSubtotals;
  }


  public BucketedCashFlowRequest asAt(OffsetDateTime asAt) {
    
    this.asAt = asAt;
    return this;
  }

   /**
   * The time of the system at which to query for bucketed cashflows.
   * @return asAt
  **/
  @jakarta.annotation.Nullable
  public OffsetDateTime getAsAt() {
    return asAt;
  }


  public void setAsAt(OffsetDateTime asAt) {
    this.asAt = asAt;
  }


  public BucketedCashFlowRequest excludeUnsettledTrades(Boolean excludeUnsettledTrades) {
    
    this.excludeUnsettledTrades = excludeUnsettledTrades;
    return this;
  }

   /**
   * Flag directing the Valuation call to exclude cashflows from unsettled trades.  If absent or set to false, cashflows will returned based on trade date - more specifically, cashflows from any unsettled trades will be included in the results. If set to true, unsettled trades will be excluded from the result set.
   * @return excludeUnsettledTrades
  **/
  @jakarta.annotation.Nullable
  public Boolean getExcludeUnsettledTrades() {
    return excludeUnsettledTrades;
  }


  public void setExcludeUnsettledTrades(Boolean excludeUnsettledTrades) {
    this.excludeUnsettledTrades = excludeUnsettledTrades;
  }


  public BucketedCashFlowRequest cashFlowType(String cashFlowType) {
    
    this.cashFlowType = cashFlowType;
    return this;
  }

   /**
   * Indicate the requested cash flow representation InstrumentCashFlows or PortfolioCashFlows (GetCashLadder uses this)  Options: [InstrumentCashFlow, PortfolioCashFlow]
   * @return cashFlowType
  **/
  @jakarta.annotation.Nullable
  public String getCashFlowType() {
    return cashFlowType;
  }


  public void setCashFlowType(String cashFlowType) {
    this.cashFlowType = cashFlowType;
  }



  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    BucketedCashFlowRequest bucketedCashFlowRequest = (BucketedCashFlowRequest) o;
    return Objects.equals(this.roundingMethod, bucketedCashFlowRequest.roundingMethod) &&
        Objects.equals(this.bucketingDates, bucketedCashFlowRequest.bucketingDates) &&
        Objects.equals(this.bucketTenors, bucketedCashFlowRequest.bucketTenors) &&
        Objects.equals(this.effectiveAt, bucketedCashFlowRequest.effectiveAt) &&
        Objects.equals(this.windowStart, bucketedCashFlowRequest.windowStart) &&
        Objects.equals(this.windowEnd, bucketedCashFlowRequest.windowEnd) &&
        Objects.equals(this.recipeId, bucketedCashFlowRequest.recipeId) &&
        Objects.equals(this.reportCurrency, bucketedCashFlowRequest.reportCurrency) &&
        Objects.equals(this.groupBy, bucketedCashFlowRequest.groupBy) &&
        Objects.equals(this.addresses, bucketedCashFlowRequest.addresses) &&
        Objects.equals(this.equipWithSubtotals, bucketedCashFlowRequest.equipWithSubtotals) &&
        Objects.equals(this.asAt, bucketedCashFlowRequest.asAt) &&
        Objects.equals(this.excludeUnsettledTrades, bucketedCashFlowRequest.excludeUnsettledTrades) &&
        Objects.equals(this.cashFlowType, bucketedCashFlowRequest.cashFlowType);
  }

  private static <T> boolean equalsNullable(JsonNullable<T> a, JsonNullable<T> b) {
    return a == b || (a != null && b != null && a.isPresent() && b.isPresent() && Objects.deepEquals(a.get(), b.get()));
  }

  @Override
  public int hashCode() {
    return Objects.hash(roundingMethod, bucketingDates, bucketTenors, effectiveAt, windowStart, windowEnd, recipeId, reportCurrency, groupBy, addresses, equipWithSubtotals, asAt, excludeUnsettledTrades, cashFlowType);
  }

  private static <T> int hashCodeNullable(JsonNullable<T> a) {
    if (a == null) {
      return 1;
    }
    return a.isPresent() ? Arrays.deepHashCode(new Object[]{a.get()}) : 31;
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class BucketedCashFlowRequest {\n");
    sb.append("    roundingMethod: ").append(toIndentedString(roundingMethod)).append("\n");
    sb.append("    bucketingDates: ").append(toIndentedString(bucketingDates)).append("\n");
    sb.append("    bucketTenors: ").append(toIndentedString(bucketTenors)).append("\n");
    sb.append("    effectiveAt: ").append(toIndentedString(effectiveAt)).append("\n");
    sb.append("    windowStart: ").append(toIndentedString(windowStart)).append("\n");
    sb.append("    windowEnd: ").append(toIndentedString(windowEnd)).append("\n");
    sb.append("    recipeId: ").append(toIndentedString(recipeId)).append("\n");
    sb.append("    reportCurrency: ").append(toIndentedString(reportCurrency)).append("\n");
    sb.append("    groupBy: ").append(toIndentedString(groupBy)).append("\n");
    sb.append("    addresses: ").append(toIndentedString(addresses)).append("\n");
    sb.append("    equipWithSubtotals: ").append(toIndentedString(equipWithSubtotals)).append("\n");
    sb.append("    asAt: ").append(toIndentedString(asAt)).append("\n");
    sb.append("    excludeUnsettledTrades: ").append(toIndentedString(excludeUnsettledTrades)).append("\n");
    sb.append("    cashFlowType: ").append(toIndentedString(cashFlowType)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }


  public static HashSet<String> openapiFields;
  public static HashSet<String> openapiRequiredFields;

  static {
    // a set of all properties/fields (JSON key names)
    openapiFields = new HashSet<String>();
    openapiFields.add("roundingMethod");
    openapiFields.add("bucketingDates");
    openapiFields.add("bucketTenors");
    openapiFields.add("effectiveAt");
    openapiFields.add("windowStart");
    openapiFields.add("windowEnd");
    openapiFields.add("recipeId");
    openapiFields.add("reportCurrency");
    openapiFields.add("groupBy");
    openapiFields.add("addresses");
    openapiFields.add("equipWithSubtotals");
    openapiFields.add("asAt");
    openapiFields.add("excludeUnsettledTrades");
    openapiFields.add("cashFlowType");

    // a set of required properties/fields (JSON key names)
    openapiRequiredFields = new HashSet<String>();
    openapiRequiredFields.add("roundingMethod");
  }

 /**
  * Validates the JSON Object and throws an exception if issues found
  *
  * @param jsonObj JSON Object
  * @throws IOException if the JSON Object is invalid with respect to BucketedCashFlowRequest
  */
  public static void validateJsonObject(JsonObject jsonObj) throws IOException {
      if (jsonObj == null) {
        if (!BucketedCashFlowRequest.openapiRequiredFields.isEmpty()) { // has required fields but JSON object is null
          throw new IllegalArgumentException(String.format("The required field(s) %s in BucketedCashFlowRequest is not found in the empty JSON string", BucketedCashFlowRequest.openapiRequiredFields.toString()));
        }
      }

      Set<Entry<String, JsonElement>> entries = jsonObj.entrySet();
      // check to see if the JSON string contains additional fields
      for (Entry<String, JsonElement> entry : entries) {
        if (!BucketedCashFlowRequest.openapiFields.contains(entry.getKey())) {
          throw new IllegalArgumentException(String.format("The field `%s` in the JSON string is not defined in the `BucketedCashFlowRequest` properties. JSON: %s", entry.getKey(), jsonObj.toString()));
        }
      }

      // check to make sure all required properties/fields are present in the JSON string
      for (String requiredField : BucketedCashFlowRequest.openapiRequiredFields) {
        if (jsonObj.get(requiredField) == null) {
          throw new IllegalArgumentException(String.format("The required field `%s` is not found in the JSON string: %s", requiredField, jsonObj.toString()));
        }
      }
      if (!jsonObj.get("roundingMethod").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `roundingMethod` to be a primitive type in the JSON string but got `%s`", jsonObj.get("roundingMethod").toString()));
      }
      // ensure the optional json data is an array if present
      if (jsonObj.get("bucketingDates") != null && !jsonObj.get("bucketingDates").isJsonArray()) {
        throw new IllegalArgumentException(String.format("Expected the field `bucketingDates` to be an array in the JSON string but got `%s`", jsonObj.get("bucketingDates").toString()));
      }
      // ensure the optional json data is an array if present
      if (jsonObj.get("bucketTenors") != null && !jsonObj.get("bucketTenors").isJsonArray()) {
        throw new IllegalArgumentException(String.format("Expected the field `bucketTenors` to be an array in the JSON string but got `%s`", jsonObj.get("bucketTenors").toString()));
      }
      if ((jsonObj.get("effectiveAt") != null && !jsonObj.get("effectiveAt").isJsonNull()) && !jsonObj.get("effectiveAt").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `effectiveAt` to be a primitive type in the JSON string but got `%s`", jsonObj.get("effectiveAt").toString()));
      }
      if ((jsonObj.get("windowStart") != null && !jsonObj.get("windowStart").isJsonNull()) && !jsonObj.get("windowStart").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `windowStart` to be a primitive type in the JSON string but got `%s`", jsonObj.get("windowStart").toString()));
      }
      if ((jsonObj.get("windowEnd") != null && !jsonObj.get("windowEnd").isJsonNull()) && !jsonObj.get("windowEnd").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `windowEnd` to be a primitive type in the JSON string but got `%s`", jsonObj.get("windowEnd").toString()));
      }
      // validate the optional field `recipeId`
      if (jsonObj.get("recipeId") != null && !jsonObj.get("recipeId").isJsonNull()) {
        ResourceId.validateJsonObject(jsonObj.getAsJsonObject("recipeId"));
      }
      if ((jsonObj.get("reportCurrency") != null && !jsonObj.get("reportCurrency").isJsonNull()) && !jsonObj.get("reportCurrency").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `reportCurrency` to be a primitive type in the JSON string but got `%s`", jsonObj.get("reportCurrency").toString()));
      }
      // ensure the optional json data is an array if present
      if (jsonObj.get("groupBy") != null && !jsonObj.get("groupBy").isJsonArray()) {
        throw new IllegalArgumentException(String.format("Expected the field `groupBy` to be an array in the JSON string but got `%s`", jsonObj.get("groupBy").toString()));
      }
      // ensure the optional json data is an array if present
      if (jsonObj.get("addresses") != null && !jsonObj.get("addresses").isJsonArray()) {
        throw new IllegalArgumentException(String.format("Expected the field `addresses` to be an array in the JSON string but got `%s`", jsonObj.get("addresses").toString()));
      }
      if ((jsonObj.get("cashFlowType") != null && !jsonObj.get("cashFlowType").isJsonNull()) && !jsonObj.get("cashFlowType").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `cashFlowType` to be a primitive type in the JSON string but got `%s`", jsonObj.get("cashFlowType").toString()));
      }
  }

  public static class CustomTypeAdapterFactory implements TypeAdapterFactory {
    @SuppressWarnings("unchecked")
    @Override
    public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {
       if (!BucketedCashFlowRequest.class.isAssignableFrom(type.getRawType())) {
         return null; // this class only serializes 'BucketedCashFlowRequest' and its subtypes
       }
       final TypeAdapter<JsonElement> elementAdapter = gson.getAdapter(JsonElement.class);
       final TypeAdapter<BucketedCashFlowRequest> thisAdapter
                        = gson.getDelegateAdapter(this, TypeToken.get(BucketedCashFlowRequest.class));

       return (TypeAdapter<T>) new TypeAdapter<BucketedCashFlowRequest>() {
           @Override
           public void write(JsonWriter out, BucketedCashFlowRequest value) throws IOException {
             JsonObject obj = thisAdapter.toJsonTree(value).getAsJsonObject();
             elementAdapter.write(out, obj);
           }

           @Override
           public BucketedCashFlowRequest read(JsonReader in) throws IOException {
             JsonObject jsonObj = elementAdapter.read(in).getAsJsonObject();
             validateJsonObject(jsonObj);
             return thisAdapter.fromJsonTree(jsonObj);
           }

       }.nullSafe();
    }
  }

 /**
  * Create an instance of BucketedCashFlowRequest given an JSON string
  *
  * @param jsonString JSON string
  * @return An instance of BucketedCashFlowRequest
  * @throws IOException if the JSON string is invalid with respect to BucketedCashFlowRequest
  */
  public static BucketedCashFlowRequest fromJson(String jsonString) throws IOException {
    return JSON.getGson().fromJson(jsonString, BucketedCashFlowRequest.class);
  }

 /**
  * Convert an instance of BucketedCashFlowRequest to an JSON string
  *
  * @return JSON string
  */
  public String toJson() {
    return JSON.getGson().toJson(this);
  }
}
