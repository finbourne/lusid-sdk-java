/*
 * LUSID API
 *
 * Contact: info@finbourne.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

package com.finbourne.lusid.model;

import java.util.Objects;
import com.finbourne.lusid.model.AggregateSpec;
import com.finbourne.lusid.model.MarketDataOverrides;
import com.finbourne.lusid.model.OrderBySpec;
import com.finbourne.lusid.model.PropertyFilter;
import com.finbourne.lusid.model.ResourceId;
import com.finbourne.lusid.model.ValuationSchedule;
import com.finbourne.lusid.model.WeightedInstrument;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;
import java.time.OffsetDateTime;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import org.openapitools.jackson.nullable.JsonNullable;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonArray;
import com.google.gson.JsonDeserializationContext;
import com.google.gson.JsonDeserializer;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParseException;
import com.google.gson.TypeAdapterFactory;
import com.google.gson.reflect.TypeToken;
import com.google.gson.TypeAdapter;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;

import java.lang.reflect.Type;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Map.Entry;
import java.util.Set;

import com.finbourne.lusid.JSON;

/**
 * Specification object for the parameters of an inline valuation
 */
@jakarta.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen")
public class InlineValuationRequest {
  public static final String SERIALIZED_NAME_RECIPE_ID = "recipeId";
  @SerializedName(SERIALIZED_NAME_RECIPE_ID)
  private ResourceId recipeId;

  public static final String SERIALIZED_NAME_AS_AT = "asAt";
  @SerializedName(SERIALIZED_NAME_AS_AT)
  private OffsetDateTime asAt;

  public static final String SERIALIZED_NAME_METRICS = "metrics";
  @SerializedName(SERIALIZED_NAME_METRICS)
  private List<AggregateSpec> metrics = new ArrayList<>();

  public static final String SERIALIZED_NAME_GROUP_BY = "groupBy";
  @SerializedName(SERIALIZED_NAME_GROUP_BY)
  private List<String> groupBy;

  public static final String SERIALIZED_NAME_FILTERS = "filters";
  @SerializedName(SERIALIZED_NAME_FILTERS)
  private List<PropertyFilter> filters;

  public static final String SERIALIZED_NAME_SORT = "sort";
  @SerializedName(SERIALIZED_NAME_SORT)
  private List<OrderBySpec> sort;

  public static final String SERIALIZED_NAME_REPORT_CURRENCY = "reportCurrency";
  @SerializedName(SERIALIZED_NAME_REPORT_CURRENCY)
  private String reportCurrency;

  public static final String SERIALIZED_NAME_EQUIP_WITH_SUBTOTALS = "equipWithSubtotals";
  @SerializedName(SERIALIZED_NAME_EQUIP_WITH_SUBTOTALS)
  private Boolean equipWithSubtotals;

  public static final String SERIALIZED_NAME_RETURN_RESULT_AS_EXPANDED_TYPES = "returnResultAsExpandedTypes";
  @SerializedName(SERIALIZED_NAME_RETURN_RESULT_AS_EXPANDED_TYPES)
  private Boolean returnResultAsExpandedTypes;

  public static final String SERIALIZED_NAME_VALUATION_SCHEDULE = "valuationSchedule";
  @SerializedName(SERIALIZED_NAME_VALUATION_SCHEDULE)
  private ValuationSchedule valuationSchedule;

  public static final String SERIALIZED_NAME_INSTRUMENTS = "instruments";
  @SerializedName(SERIALIZED_NAME_INSTRUMENTS)
  private List<WeightedInstrument> instruments = new ArrayList<>();

  public static final String SERIALIZED_NAME_MARKET_DATA_OVERRIDES = "marketDataOverrides";
  @SerializedName(SERIALIZED_NAME_MARKET_DATA_OVERRIDES)
  private MarketDataOverrides marketDataOverrides;

  public static final String SERIALIZED_NAME_CORPORATE_ACTION_SOURCE_ID = "corporateActionSourceId";
  @SerializedName(SERIALIZED_NAME_CORPORATE_ACTION_SOURCE_ID)
  private ResourceId corporateActionSourceId;

  public InlineValuationRequest() {
  }

  public InlineValuationRequest recipeId(ResourceId recipeId) {
    
    this.recipeId = recipeId;
    return this;
  }

   /**
   * Get recipeId
   * @return recipeId
  **/
  @jakarta.annotation.Nullable
  public ResourceId getRecipeId() {
    return recipeId;
  }


  public void setRecipeId(ResourceId recipeId) {
    this.recipeId = recipeId;
  }


  public InlineValuationRequest asAt(OffsetDateTime asAt) {
    
    this.asAt = asAt;
    return this;
  }

   /**
   * The asAt date to use
   * @return asAt
  **/
  @jakarta.annotation.Nullable
  public OffsetDateTime getAsAt() {
    return asAt;
  }


  public void setAsAt(OffsetDateTime asAt) {
    this.asAt = asAt;
  }


  public InlineValuationRequest metrics(List<AggregateSpec> metrics) {
    
    this.metrics = metrics;
    return this;
  }

  public InlineValuationRequest addMetricsItem(AggregateSpec metricsItem) {
    if (this.metrics == null) {
      this.metrics = new ArrayList<>();
    }
    this.metrics.add(metricsItem);
    return this;
  }

   /**
   * The set of specifications to calculate or retrieve during the valuation and present in the results. For example:  AggregateSpec(&#39;Valuation/PV&#39;,&#39;Sum&#39;) for returning the PV (present value) of holdings  AggregateSpec(&#39;Holding/default/Units&#39;,&#39;Sum&#39;) for returning the units of holidays  AggregateSpec(&#39;Instrument/default/LusidInstrumentId&#39;,&#39;Value&#39;) for returning the Lusid Instrument identifier
   * @return metrics
  **/
  @jakarta.annotation.Nonnull
  public List<AggregateSpec> getMetrics() {
    return metrics;
  }


  public void setMetrics(List<AggregateSpec> metrics) {
    this.metrics = metrics;
  }


  public InlineValuationRequest groupBy(List<String> groupBy) {
    
    this.groupBy = groupBy;
    return this;
  }

  public InlineValuationRequest addGroupByItem(String groupByItem) {
    if (this.groupBy == null) {
      this.groupBy = new ArrayList<>();
    }
    this.groupBy.add(groupByItem);
    return this;
  }

   /**
   * The set of items by which to perform grouping. This primarily matters when one or more of the metric operators is a mapping  that reduces set size, e.g. sum or proportion. The group-by statement determines the set of keys by which to break the results out.
   * @return groupBy
  **/
  @jakarta.annotation.Nullable
  public List<String> getGroupBy() {
    return groupBy;
  }


  public void setGroupBy(List<String> groupBy) {
    this.groupBy = groupBy;
  }


  public InlineValuationRequest filters(List<PropertyFilter> filters) {
    
    this.filters = filters;
    return this;
  }

  public InlineValuationRequest addFiltersItem(PropertyFilter filtersItem) {
    if (this.filters == null) {
      this.filters = new ArrayList<>();
    }
    this.filters.add(filtersItem);
    return this;
  }

   /**
   * A set of filters to use to reduce the data found in a request. Equivalent to the &#39;where ...&#39; part of a Sql select statement.  For example, filter a set of values within a given range or matching a particular value.
   * @return filters
  **/
  @jakarta.annotation.Nullable
  public List<PropertyFilter> getFilters() {
    return filters;
  }


  public void setFilters(List<PropertyFilter> filters) {
    this.filters = filters;
  }


  public InlineValuationRequest sort(List<OrderBySpec> sort) {
    
    this.sort = sort;
    return this;
  }

  public InlineValuationRequest addSortItem(OrderBySpec sortItem) {
    if (this.sort == null) {
      this.sort = new ArrayList<>();
    }
    this.sort.add(sortItem);
    return this;
  }

   /**
   * A (possibly empty/null) set of specifications for how to order the results.
   * @return sort
  **/
  @jakarta.annotation.Nullable
  public List<OrderBySpec> getSort() {
    return sort;
  }


  public void setSort(List<OrderBySpec> sort) {
    this.sort = sort;
  }


  public InlineValuationRequest reportCurrency(String reportCurrency) {
    
    this.reportCurrency = reportCurrency;
    return this;
  }

   /**
   * Three letter ISO currency string indicating what currency to report in for ReportCurrency denominated queries.  If not present, then the currency of the relevant portfolio will be used in its place.
   * @return reportCurrency
  **/
  @jakarta.annotation.Nullable
  public String getReportCurrency() {
    return reportCurrency;
  }


  public void setReportCurrency(String reportCurrency) {
    this.reportCurrency = reportCurrency;
  }


  public InlineValuationRequest equipWithSubtotals(Boolean equipWithSubtotals) {
    
    this.equipWithSubtotals = equipWithSubtotals;
    return this;
  }

   /**
   * Flag directing the Valuation call to populate the results with subtotals of aggregates.
   * @return equipWithSubtotals
  **/
  @jakarta.annotation.Nullable
  public Boolean getEquipWithSubtotals() {
    return equipWithSubtotals;
  }


  public void setEquipWithSubtotals(Boolean equipWithSubtotals) {
    this.equipWithSubtotals = equipWithSubtotals;
  }


  public InlineValuationRequest returnResultAsExpandedTypes(Boolean returnResultAsExpandedTypes) {
    
    this.returnResultAsExpandedTypes = returnResultAsExpandedTypes;
    return this;
  }

   /**
   * Financially meaningful results can be presented as either simple flat types or more complex expanded types.  For example, the present value (PV) of a holding could be represented either as a simple decimal (with currency implied)  or as a decimal-currency pair. This flag allows either representation to be returned. In the PV example,  the returned value would be the decimal-currency pair if this flag is true, or the decimal only if this flag is false.
   * @return returnResultAsExpandedTypes
  **/
  @jakarta.annotation.Nullable
  public Boolean getReturnResultAsExpandedTypes() {
    return returnResultAsExpandedTypes;
  }


  public void setReturnResultAsExpandedTypes(Boolean returnResultAsExpandedTypes) {
    this.returnResultAsExpandedTypes = returnResultAsExpandedTypes;
  }


  public InlineValuationRequest valuationSchedule(ValuationSchedule valuationSchedule) {
    
    this.valuationSchedule = valuationSchedule;
    return this;
  }

   /**
   * Get valuationSchedule
   * @return valuationSchedule
  **/
  @jakarta.annotation.Nullable
  public ValuationSchedule getValuationSchedule() {
    return valuationSchedule;
  }


  public void setValuationSchedule(ValuationSchedule valuationSchedule) {
    this.valuationSchedule = valuationSchedule;
  }


  public InlineValuationRequest instruments(List<WeightedInstrument> instruments) {
    
    this.instruments = instruments;
    return this;
  }

  public InlineValuationRequest addInstrumentsItem(WeightedInstrument instrumentsItem) {
    if (this.instruments == null) {
      this.instruments = new ArrayList<>();
    }
    this.instruments.add(instrumentsItem);
    return this;
  }

   /**
   * The set of instruments, weighted by the quantities held that are required.  It is identified by an identifier tag that can be used to identify it externally.  For a single, unique trade or transaction this can be thought of as equivalent to the transaction identifier, or  a composite of the sub-holding keys for a regular sub-holding. When there are multiple transactions sharing the same underlying instrument  such as purchase of shares on multiple dates where tax implications are different this would not be the case.
   * @return instruments
  **/
  @jakarta.annotation.Nonnull
  public List<WeightedInstrument> getInstruments() {
    return instruments;
  }


  public void setInstruments(List<WeightedInstrument> instruments) {
    this.instruments = instruments;
  }


  public InlineValuationRequest marketDataOverrides(MarketDataOverrides marketDataOverrides) {
    
    this.marketDataOverrides = marketDataOverrides;
    return this;
  }

   /**
   * Get marketDataOverrides
   * @return marketDataOverrides
  **/
  @jakarta.annotation.Nullable
  public MarketDataOverrides getMarketDataOverrides() {
    return marketDataOverrides;
  }


  public void setMarketDataOverrides(MarketDataOverrides marketDataOverrides) {
    this.marketDataOverrides = marketDataOverrides;
  }


  public InlineValuationRequest corporateActionSourceId(ResourceId corporateActionSourceId) {
    
    this.corporateActionSourceId = corporateActionSourceId;
    return this;
  }

   /**
   * Get corporateActionSourceId
   * @return corporateActionSourceId
  **/
  @jakarta.annotation.Nullable
  public ResourceId getCorporateActionSourceId() {
    return corporateActionSourceId;
  }


  public void setCorporateActionSourceId(ResourceId corporateActionSourceId) {
    this.corporateActionSourceId = corporateActionSourceId;
  }



  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    InlineValuationRequest inlineValuationRequest = (InlineValuationRequest) o;
    return Objects.equals(this.recipeId, inlineValuationRequest.recipeId) &&
        Objects.equals(this.asAt, inlineValuationRequest.asAt) &&
        Objects.equals(this.metrics, inlineValuationRequest.metrics) &&
        Objects.equals(this.groupBy, inlineValuationRequest.groupBy) &&
        Objects.equals(this.filters, inlineValuationRequest.filters) &&
        Objects.equals(this.sort, inlineValuationRequest.sort) &&
        Objects.equals(this.reportCurrency, inlineValuationRequest.reportCurrency) &&
        Objects.equals(this.equipWithSubtotals, inlineValuationRequest.equipWithSubtotals) &&
        Objects.equals(this.returnResultAsExpandedTypes, inlineValuationRequest.returnResultAsExpandedTypes) &&
        Objects.equals(this.valuationSchedule, inlineValuationRequest.valuationSchedule) &&
        Objects.equals(this.instruments, inlineValuationRequest.instruments) &&
        Objects.equals(this.marketDataOverrides, inlineValuationRequest.marketDataOverrides) &&
        Objects.equals(this.corporateActionSourceId, inlineValuationRequest.corporateActionSourceId);
  }

  private static <T> boolean equalsNullable(JsonNullable<T> a, JsonNullable<T> b) {
    return a == b || (a != null && b != null && a.isPresent() && b.isPresent() && Objects.deepEquals(a.get(), b.get()));
  }

  @Override
  public int hashCode() {
    return Objects.hash(recipeId, asAt, metrics, groupBy, filters, sort, reportCurrency, equipWithSubtotals, returnResultAsExpandedTypes, valuationSchedule, instruments, marketDataOverrides, corporateActionSourceId);
  }

  private static <T> int hashCodeNullable(JsonNullable<T> a) {
    if (a == null) {
      return 1;
    }
    return a.isPresent() ? Arrays.deepHashCode(new Object[]{a.get()}) : 31;
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class InlineValuationRequest {\n");
    sb.append("    recipeId: ").append(toIndentedString(recipeId)).append("\n");
    sb.append("    asAt: ").append(toIndentedString(asAt)).append("\n");
    sb.append("    metrics: ").append(toIndentedString(metrics)).append("\n");
    sb.append("    groupBy: ").append(toIndentedString(groupBy)).append("\n");
    sb.append("    filters: ").append(toIndentedString(filters)).append("\n");
    sb.append("    sort: ").append(toIndentedString(sort)).append("\n");
    sb.append("    reportCurrency: ").append(toIndentedString(reportCurrency)).append("\n");
    sb.append("    equipWithSubtotals: ").append(toIndentedString(equipWithSubtotals)).append("\n");
    sb.append("    returnResultAsExpandedTypes: ").append(toIndentedString(returnResultAsExpandedTypes)).append("\n");
    sb.append("    valuationSchedule: ").append(toIndentedString(valuationSchedule)).append("\n");
    sb.append("    instruments: ").append(toIndentedString(instruments)).append("\n");
    sb.append("    marketDataOverrides: ").append(toIndentedString(marketDataOverrides)).append("\n");
    sb.append("    corporateActionSourceId: ").append(toIndentedString(corporateActionSourceId)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }


  public static HashSet<String> openapiFields;
  public static HashSet<String> openapiRequiredFields;

  static {
    // a set of all properties/fields (JSON key names)
    openapiFields = new HashSet<String>();
    openapiFields.add("recipeId");
    openapiFields.add("asAt");
    openapiFields.add("metrics");
    openapiFields.add("groupBy");
    openapiFields.add("filters");
    openapiFields.add("sort");
    openapiFields.add("reportCurrency");
    openapiFields.add("equipWithSubtotals");
    openapiFields.add("returnResultAsExpandedTypes");
    openapiFields.add("valuationSchedule");
    openapiFields.add("instruments");
    openapiFields.add("marketDataOverrides");
    openapiFields.add("corporateActionSourceId");

    // a set of required properties/fields (JSON key names)
    openapiRequiredFields = new HashSet<String>();
    openapiRequiredFields.add("metrics");
    openapiRequiredFields.add("instruments");
  }

 /**
  * Validates the JSON Object and throws an exception if issues found
  *
  * @param jsonObj JSON Object
  * @throws IOException if the JSON Object is invalid with respect to InlineValuationRequest
  */
  public static void validateJsonObject(JsonObject jsonObj) throws IOException {
      if (jsonObj == null) {
        if (!InlineValuationRequest.openapiRequiredFields.isEmpty()) { // has required fields but JSON object is null
          throw new IllegalArgumentException(String.format("The required field(s) %s in InlineValuationRequest is not found in the empty JSON string", InlineValuationRequest.openapiRequiredFields.toString()));
        }
      }

      Set<Entry<String, JsonElement>> entries = jsonObj.entrySet();
      // check to see if the JSON string contains additional fields
      for (Entry<String, JsonElement> entry : entries) {
        if (!InlineValuationRequest.openapiFields.contains(entry.getKey())) {
          throw new IllegalArgumentException(String.format("The field `%s` in the JSON string is not defined in the `InlineValuationRequest` properties. JSON: %s", entry.getKey(), jsonObj.toString()));
        }
      }

      // check to make sure all required properties/fields are present in the JSON string
      for (String requiredField : InlineValuationRequest.openapiRequiredFields) {
        if (jsonObj.get(requiredField) == null) {
          throw new IllegalArgumentException(String.format("The required field `%s` is not found in the JSON string: %s", requiredField, jsonObj.toString()));
        }
      }
      // validate the optional field `recipeId`
      if (jsonObj.get("recipeId") != null && !jsonObj.get("recipeId").isJsonNull()) {
        ResourceId.validateJsonObject(jsonObj.getAsJsonObject("recipeId"));
      }
      // ensure the json data is an array
      if (!jsonObj.get("metrics").isJsonArray()) {
        throw new IllegalArgumentException(String.format("Expected the field `metrics` to be an array in the JSON string but got `%s`", jsonObj.get("metrics").toString()));
      }

      JsonArray jsonArraymetrics = jsonObj.getAsJsonArray("metrics");
      // validate the required field `metrics` (array)
      for (int i = 0; i < jsonArraymetrics.size(); i++) {
        AggregateSpec.validateJsonObject(jsonArraymetrics.get(i).getAsJsonObject());
      };
      // ensure the optional json data is an array if present
      if (jsonObj.get("groupBy") != null && !jsonObj.get("groupBy").isJsonArray()) {
        throw new IllegalArgumentException(String.format("Expected the field `groupBy` to be an array in the JSON string but got `%s`", jsonObj.get("groupBy").toString()));
      }
      if (jsonObj.get("filters") != null && !jsonObj.get("filters").isJsonNull()) {
        JsonArray jsonArrayfilters = jsonObj.getAsJsonArray("filters");
        if (jsonArrayfilters != null) {
          // ensure the json data is an array
          if (!jsonObj.get("filters").isJsonArray()) {
            throw new IllegalArgumentException(String.format("Expected the field `filters` to be an array in the JSON string but got `%s`", jsonObj.get("filters").toString()));
          }

          // validate the optional field `filters` (array)
          for (int i = 0; i < jsonArrayfilters.size(); i++) {
            PropertyFilter.validateJsonObject(jsonArrayfilters.get(i).getAsJsonObject());
          };
        }
      }
      if (jsonObj.get("sort") != null && !jsonObj.get("sort").isJsonNull()) {
        JsonArray jsonArraysort = jsonObj.getAsJsonArray("sort");
        if (jsonArraysort != null) {
          // ensure the json data is an array
          if (!jsonObj.get("sort").isJsonArray()) {
            throw new IllegalArgumentException(String.format("Expected the field `sort` to be an array in the JSON string but got `%s`", jsonObj.get("sort").toString()));
          }

          // validate the optional field `sort` (array)
          for (int i = 0; i < jsonArraysort.size(); i++) {
            OrderBySpec.validateJsonObject(jsonArraysort.get(i).getAsJsonObject());
          };
        }
      }
      if ((jsonObj.get("reportCurrency") != null && !jsonObj.get("reportCurrency").isJsonNull()) && !jsonObj.get("reportCurrency").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `reportCurrency` to be a primitive type in the JSON string but got `%s`", jsonObj.get("reportCurrency").toString()));
      }
      // validate the optional field `valuationSchedule`
      if (jsonObj.get("valuationSchedule") != null && !jsonObj.get("valuationSchedule").isJsonNull()) {
        ValuationSchedule.validateJsonObject(jsonObj.getAsJsonObject("valuationSchedule"));
      }
      // ensure the json data is an array
      if (!jsonObj.get("instruments").isJsonArray()) {
        throw new IllegalArgumentException(String.format("Expected the field `instruments` to be an array in the JSON string but got `%s`", jsonObj.get("instruments").toString()));
      }

      JsonArray jsonArrayinstruments = jsonObj.getAsJsonArray("instruments");
      // validate the required field `instruments` (array)
      for (int i = 0; i < jsonArrayinstruments.size(); i++) {
        WeightedInstrument.validateJsonObject(jsonArrayinstruments.get(i).getAsJsonObject());
      };
      // validate the optional field `marketDataOverrides`
      if (jsonObj.get("marketDataOverrides") != null && !jsonObj.get("marketDataOverrides").isJsonNull()) {
        MarketDataOverrides.validateJsonObject(jsonObj.getAsJsonObject("marketDataOverrides"));
      }
      // validate the optional field `corporateActionSourceId`
      if (jsonObj.get("corporateActionSourceId") != null && !jsonObj.get("corporateActionSourceId").isJsonNull()) {
        ResourceId.validateJsonObject(jsonObj.getAsJsonObject("corporateActionSourceId"));
      }
  }

  public static class CustomTypeAdapterFactory implements TypeAdapterFactory {
    @SuppressWarnings("unchecked")
    @Override
    public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {
       if (!InlineValuationRequest.class.isAssignableFrom(type.getRawType())) {
         return null; // this class only serializes 'InlineValuationRequest' and its subtypes
       }
       final TypeAdapter<JsonElement> elementAdapter = gson.getAdapter(JsonElement.class);
       final TypeAdapter<InlineValuationRequest> thisAdapter
                        = gson.getDelegateAdapter(this, TypeToken.get(InlineValuationRequest.class));

       return (TypeAdapter<T>) new TypeAdapter<InlineValuationRequest>() {
           @Override
           public void write(JsonWriter out, InlineValuationRequest value) throws IOException {
             JsonObject obj = thisAdapter.toJsonTree(value).getAsJsonObject();
             elementAdapter.write(out, obj);
           }

           @Override
           public InlineValuationRequest read(JsonReader in) throws IOException {
             JsonObject jsonObj = elementAdapter.read(in).getAsJsonObject();
             validateJsonObject(jsonObj);
             return thisAdapter.fromJsonTree(jsonObj);
           }

       }.nullSafe();
    }
  }

 /**
  * Create an instance of InlineValuationRequest given an JSON string
  *
  * @param jsonString JSON string
  * @return An instance of InlineValuationRequest
  * @throws IOException if the JSON string is invalid with respect to InlineValuationRequest
  */
  public static InlineValuationRequest fromJson(String jsonString) throws IOException {
    return JSON.getGson().fromJson(jsonString, InlineValuationRequest.class);
  }

 /**
  * Convert an instance of InlineValuationRequest to an JSON string
  *
  * @return JSON string
  */
  public String toJson() {
    return JSON.getGson().toJson(this);
  }
}
