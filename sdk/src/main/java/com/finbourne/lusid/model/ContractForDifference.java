/*
 * LUSID API
 *
 * Contact: info@finbourne.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

package com.finbourne.lusid.model;

import java.util.Objects;
import java.util.Arrays;
import com.finbourne.lusid.model.LusidInstrument;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;
import java.time.OffsetDateTime;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonArray;
import com.google.gson.JsonDeserializationContext;
import com.google.gson.JsonDeserializer;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParseException;
import com.google.gson.TypeAdapterFactory;
import com.google.gson.reflect.TypeToken;
import com.google.gson.TypeAdapter;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;

import java.lang.reflect.Type;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Map.Entry;
import java.util.Set;

import com.finbourne.lusid.JSON;

/**
 * LUSID representation of a Contract for Difference.
 */
@javax.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen")
public class ContractForDifference extends LusidInstrument {
  public static final String SERIALIZED_NAME_START_DATE = "startDate";
  @SerializedName(SERIALIZED_NAME_START_DATE)
  private OffsetDateTime startDate;

  public static final String SERIALIZED_NAME_MATURITY_DATE = "maturityDate";
  @SerializedName(SERIALIZED_NAME_MATURITY_DATE)
  private OffsetDateTime maturityDate;

  public static final String SERIALIZED_NAME_CODE = "code";
  @SerializedName(SERIALIZED_NAME_CODE)
  private String code;

  public static final String SERIALIZED_NAME_CONTRACT_SIZE = "contractSize";
  @SerializedName(SERIALIZED_NAME_CONTRACT_SIZE)
  private java.math.BigDecimal contractSize;

  public static final String SERIALIZED_NAME_PAY_CCY = "payCcy";
  @SerializedName(SERIALIZED_NAME_PAY_CCY)
  private String payCcy;

  public static final String SERIALIZED_NAME_REFERENCE_RATE = "referenceRate";
  @SerializedName(SERIALIZED_NAME_REFERENCE_RATE)
  private java.math.BigDecimal referenceRate;

  public static final String SERIALIZED_NAME_TYPE = "type";
  @SerializedName(SERIALIZED_NAME_TYPE)
  private String type;

  public static final String SERIALIZED_NAME_UNDERLYING_CCY = "underlyingCcy";
  @SerializedName(SERIALIZED_NAME_UNDERLYING_CCY)
  private String underlyingCcy;

  public static final String SERIALIZED_NAME_UNDERLYING_IDENTIFIER = "underlyingIdentifier";
  @SerializedName(SERIALIZED_NAME_UNDERLYING_IDENTIFIER)
  private String underlyingIdentifier;

  public ContractForDifference() {
    // this.instrumentType = this.getClass().getSimpleName();
  }

  public ContractForDifference startDate(OffsetDateTime startDate) {
    
    this.startDate = startDate;
    return this;
  }

   /**
   * The start date of the CFD.
   * @return startDate
  **/
  @javax.annotation.Nonnull
  public OffsetDateTime getStartDate() {
    return startDate;
  }


  public void setStartDate(OffsetDateTime startDate) {
    this.startDate = startDate;
  }


  public ContractForDifference maturityDate(OffsetDateTime maturityDate) {
    
    this.maturityDate = maturityDate;
    return this;
  }

   /**
   * The maturity date for the CFD. If CFDType is Futures, this should be set to be the maturity date of the underlying  future. If CFDType is Cash, this should not be set.
   * @return maturityDate
  **/
  @javax.annotation.Nullable
  public OffsetDateTime getMaturityDate() {
    return maturityDate;
  }


  public void setMaturityDate(OffsetDateTime maturityDate) {
    this.maturityDate = maturityDate;
  }


  public ContractForDifference code(String code) {
    
    this.code = code;
    return this;
  }

   /**
   * The code of the underlying.
   * @return code
  **/
  @javax.annotation.Nonnull
  public String getCode() {
    return code;
  }


  public void setCode(String code) {
    this.code = code;
  }


  public ContractForDifference contractSize(java.math.BigDecimal contractSize) {
    
    this.contractSize = contractSize;
    return this;
  }

   /**
   * The size of the CFD contract, this should represent the total number of stocks that the CFD represents.
   * @return contractSize
  **/
  @javax.annotation.Nonnull
  public java.math.BigDecimal getContractSize() {
    return contractSize;
  }


  public void setContractSize(java.math.BigDecimal contractSize) {
    this.contractSize = contractSize;
  }


  public ContractForDifference payCcy(String payCcy) {
    
    this.payCcy = payCcy;
    return this;
  }

   /**
   * The currency that this CFD pays out, this can be different to the UnderlyingCcy.
   * @return payCcy
  **/
  @javax.annotation.Nonnull
  public String getPayCcy() {
    return payCcy;
  }


  public void setPayCcy(String payCcy) {
    this.payCcy = payCcy;
  }


  public ContractForDifference referenceRate(java.math.BigDecimal referenceRate) {
    
    this.referenceRate = referenceRate;
    return this;
  }

   /**
   * The reference rate of the CFD, this can be set to 0 but not negative values.  This field is optional, if not set it will default to 0.
   * @return referenceRate
  **/
  @javax.annotation.Nullable
  public java.math.BigDecimal getReferenceRate() {
    return referenceRate;
  }


  public void setReferenceRate(java.math.BigDecimal referenceRate) {
    this.referenceRate = referenceRate;
  }


  public ContractForDifference type(String type) {
    
    this.type = type;
    return this;
  }

   /**
   * The type of CFD.    Supported string (enumeration) values are: [Cash, Futures].
   * @return type
  **/
  @javax.annotation.Nonnull
  public String getType() {
    return type;
  }


  public void setType(String type) {
    this.type = type;
  }


  public ContractForDifference underlyingCcy(String underlyingCcy) {
    
    this.underlyingCcy = underlyingCcy;
    return this;
  }

   /**
   * The currency of the underlying
   * @return underlyingCcy
  **/
  @javax.annotation.Nonnull
  public String getUnderlyingCcy() {
    return underlyingCcy;
  }


  public void setUnderlyingCcy(String underlyingCcy) {
    this.underlyingCcy = underlyingCcy;
  }


  public ContractForDifference underlyingIdentifier(String underlyingIdentifier) {
    
    this.underlyingIdentifier = underlyingIdentifier;
    return this;
  }

   /**
   * External market codes and identifiers for the CFD, e.g. RIC.    Supported string (enumeration) values are: [LusidInstrumentId, Isin, Sedol, Cusip, ClientInternal, Figi, RIC, QuotePermId, REDCode, BBGId, ICECode].
   * @return underlyingIdentifier
  **/
  @javax.annotation.Nonnull
  public String getUnderlyingIdentifier() {
    return underlyingIdentifier;
  }


  public void setUnderlyingIdentifier(String underlyingIdentifier) {
    this.underlyingIdentifier = underlyingIdentifier;
  }



  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    ContractForDifference contractForDifference = (ContractForDifference) o;
    return Objects.equals(this.startDate, contractForDifference.startDate) &&
        Objects.equals(this.maturityDate, contractForDifference.maturityDate) &&
        Objects.equals(this.code, contractForDifference.code) &&
        (this.contractSize.compareTo(contractForDifference.getContractSize()) == 0) &&
        Objects.equals(this.payCcy, contractForDifference.payCcy) &&
        (this.referenceRate.compareTo(contractForDifference.getReferenceRate()) == 0) &&
        Objects.equals(this.type, contractForDifference.type) &&
        Objects.equals(this.underlyingCcy, contractForDifference.underlyingCcy) &&
        Objects.equals(this.underlyingIdentifier, contractForDifference.underlyingIdentifier) &&
        super.equals(o);
  }

  @Override
  public int hashCode() {
    return Objects.hash(startDate, maturityDate, code, contractSize, payCcy, referenceRate, type, underlyingCcy, underlyingIdentifier, super.hashCode());
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class ContractForDifference {\n");
    sb.append("    ").append(toIndentedString(super.toString())).append("\n");
    sb.append("    startDate: ").append(toIndentedString(startDate)).append("\n");
    sb.append("    maturityDate: ").append(toIndentedString(maturityDate)).append("\n");
    sb.append("    code: ").append(toIndentedString(code)).append("\n");
    sb.append("    contractSize: ").append(toIndentedString(contractSize)).append("\n");
    sb.append("    payCcy: ").append(toIndentedString(payCcy)).append("\n");
    sb.append("    referenceRate: ").append(toIndentedString(referenceRate)).append("\n");
    sb.append("    type: ").append(toIndentedString(type)).append("\n");
    sb.append("    underlyingCcy: ").append(toIndentedString(underlyingCcy)).append("\n");
    sb.append("    underlyingIdentifier: ").append(toIndentedString(underlyingIdentifier)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }


  public static HashSet<String> openapiFields;
  public static HashSet<String> openapiRequiredFields;

  static {
    // a set of all properties/fields (JSON key names)
    openapiFields = new HashSet<String>();
    openapiFields.add("instrumentType");
    openapiFields.add("startDate");
    openapiFields.add("maturityDate");
    openapiFields.add("code");
    openapiFields.add("contractSize");
    openapiFields.add("payCcy");
    openapiFields.add("referenceRate");
    openapiFields.add("type");
    openapiFields.add("underlyingCcy");
    openapiFields.add("underlyingIdentifier");

    // a set of required properties/fields (JSON key names)
    openapiRequiredFields = new HashSet<String>();
    openapiRequiredFields.add("startDate");
    openapiRequiredFields.add("code");
    openapiRequiredFields.add("contractSize");
    openapiRequiredFields.add("payCcy");
    openapiRequiredFields.add("type");
    openapiRequiredFields.add("underlyingCcy");
    openapiRequiredFields.add("underlyingIdentifier");
    openapiRequiredFields.add("instrumentType");
  }

 /**
  * Validates the JSON Object and throws an exception if issues found
  *
  * @param jsonObj JSON Object
  * @throws IOException if the JSON Object is invalid with respect to ContractForDifference
  */
  public static void validateJsonObject(JsonObject jsonObj) throws IOException {
      if (jsonObj == null) {
        if (!ContractForDifference.openapiRequiredFields.isEmpty()) { // has required fields but JSON object is null
          throw new IllegalArgumentException(String.format("The required field(s) %s in ContractForDifference is not found in the empty JSON string", ContractForDifference.openapiRequiredFields.toString()));
        }
      }

      Set<Entry<String, JsonElement>> entries = jsonObj.entrySet();
      // check to see if the JSON string contains additional fields
      for (Entry<String, JsonElement> entry : entries) {
        if (!ContractForDifference.openapiFields.contains(entry.getKey())) {
          throw new IllegalArgumentException(String.format("The field `%s` in the JSON string is not defined in the `ContractForDifference` properties. JSON: %s", entry.getKey(), jsonObj.toString()));
        }
      }

      // check to make sure all required properties/fields are present in the JSON string
      for (String requiredField : ContractForDifference.openapiRequiredFields) {
        if (jsonObj.get(requiredField) == null) {
          throw new IllegalArgumentException(String.format("The required field `%s` is not found in the JSON string: %s", requiredField, jsonObj.toString()));
        }
      }
  }

  public static class CustomTypeAdapterFactory implements TypeAdapterFactory {
    @SuppressWarnings("unchecked")
    @Override
    public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {
       if (!ContractForDifference.class.isAssignableFrom(type.getRawType())) {
         return null; // this class only serializes 'ContractForDifference' and its subtypes
       }
       final TypeAdapter<JsonElement> elementAdapter = gson.getAdapter(JsonElement.class);
       final TypeAdapter<ContractForDifference> thisAdapter
                        = gson.getDelegateAdapter(this, TypeToken.get(ContractForDifference.class));

       return (TypeAdapter<T>) new TypeAdapter<ContractForDifference>() {
           @Override
           public void write(JsonWriter out, ContractForDifference value) throws IOException {
             JsonObject obj = thisAdapter.toJsonTree(value).getAsJsonObject();
             elementAdapter.write(out, obj);
           }

           @Override
           public ContractForDifference read(JsonReader in) throws IOException {
             JsonObject jsonObj = elementAdapter.read(in).getAsJsonObject();
             validateJsonObject(jsonObj);
             return thisAdapter.fromJsonTree(jsonObj);
           }

       }.nullSafe();
    }
  }

 /**
  * Create an instance of ContractForDifference given an JSON string
  *
  * @param jsonString JSON string
  * @return An instance of ContractForDifference
  * @throws IOException if the JSON string is invalid with respect to ContractForDifference
  */
  public static ContractForDifference fromJson(String jsonString) throws IOException {
    return JSON.getGson().fromJson(jsonString, ContractForDifference.class);
  }

 /**
  * Convert an instance of ContractForDifference to an JSON string
  *
  * @return JSON string
  */
  public String toJson() {
    return JSON.getGson().toJson(this);
  }
}
