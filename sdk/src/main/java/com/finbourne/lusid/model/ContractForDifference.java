/*
 * LUSID API
 *
 * Contact: info@finbourne.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

package com.finbourne.lusid.model;

import java.util.Objects;
import com.finbourne.lusid.model.LusidInstrument;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;
import java.time.OffsetDateTime;
import java.util.Arrays;
import org.openapitools.jackson.nullable.JsonNullable;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonArray;
import com.google.gson.JsonDeserializationContext;
import com.google.gson.JsonDeserializer;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParseException;
import com.google.gson.TypeAdapterFactory;
import com.google.gson.reflect.TypeToken;
import com.google.gson.TypeAdapter;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;

import java.lang.reflect.Type;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Map.Entry;
import java.util.Set;

import com.finbourne.lusid.JSON;

/**
 * LUSID representation of a Contract for Difference.
 */
@jakarta.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen")
public class ContractForDifference extends LusidInstrument {
  public static final String SERIALIZED_NAME_START_DATE = "startDate";
  @SerializedName(SERIALIZED_NAME_START_DATE)
  private OffsetDateTime startDate;

  public static final String SERIALIZED_NAME_MATURITY_DATE = "maturityDate";
  @SerializedName(SERIALIZED_NAME_MATURITY_DATE)
  private OffsetDateTime maturityDate;

  public static final String SERIALIZED_NAME_CODE = "code";
  @SerializedName(SERIALIZED_NAME_CODE)
  private String code;

  public static final String SERIALIZED_NAME_CONTRACT_SIZE = "contractSize";
  @SerializedName(SERIALIZED_NAME_CONTRACT_SIZE)
  private java.math.BigDecimal contractSize;

  public static final String SERIALIZED_NAME_PAY_CCY = "payCcy";
  @SerializedName(SERIALIZED_NAME_PAY_CCY)
  private String payCcy;

  public static final String SERIALIZED_NAME_REFERENCE_RATE = "referenceRate";
  @SerializedName(SERIALIZED_NAME_REFERENCE_RATE)
  private java.math.BigDecimal referenceRate;

  public static final String SERIALIZED_NAME_TYPE = "type";
  @SerializedName(SERIALIZED_NAME_TYPE)
  private String type;

  public static final String SERIALIZED_NAME_UNDERLYING_CCY = "underlyingCcy";
  @SerializedName(SERIALIZED_NAME_UNDERLYING_CCY)
  private String underlyingCcy;

  public static final String SERIALIZED_NAME_UNDERLYING_IDENTIFIER = "underlyingIdentifier";
  @SerializedName(SERIALIZED_NAME_UNDERLYING_IDENTIFIER)
  private String underlyingIdentifier;

  public static final String SERIALIZED_NAME_LOT_SIZE = "lotSize";
  @SerializedName(SERIALIZED_NAME_LOT_SIZE)
  private Integer lotSize;

  public static final String SERIALIZED_NAME_UNDERLYING = "underlying";
  @SerializedName(SERIALIZED_NAME_UNDERLYING)
  private LusidInstrument underlying;

  public ContractForDifference() {
    // this.instrumentType = this.getClass().getSimpleName();
  }

  public ContractForDifference startDate(OffsetDateTime startDate) {
    
    this.startDate = startDate;
    return this;
  }

   /**
   * The start date of the CFD.
   * @return startDate
  **/
  @jakarta.annotation.Nonnull
  public OffsetDateTime getStartDate() {
    return startDate;
  }


  public void setStartDate(OffsetDateTime startDate) {
    this.startDate = startDate;
  }


  public ContractForDifference maturityDate(OffsetDateTime maturityDate) {
    
    this.maturityDate = maturityDate;
    return this;
  }

   /**
   * The maturity date for the CFD. If CFDType is Futures, this should be set to be the maturity date of the underlying  future. If CFDType is Cash, this should not be set.
   * @return maturityDate
  **/
  @jakarta.annotation.Nullable
  public OffsetDateTime getMaturityDate() {
    return maturityDate;
  }


  public void setMaturityDate(OffsetDateTime maturityDate) {
    this.maturityDate = maturityDate;
  }


  public ContractForDifference code(String code) {
    
    this.code = code;
    return this;
  }

   /**
   * The code of the underlying.
   * @return code
  **/
  @jakarta.annotation.Nullable
  public String getCode() {
    return code;
  }


  public void setCode(String code) {
    this.code = code;
  }


  public ContractForDifference contractSize(java.math.BigDecimal contractSize) {
    
    this.contractSize = contractSize;
    return this;
  }

   /**
   * The size of the CFD contract, this should represent the total number of stocks that the CFD represents.
   * @return contractSize
  **/
  @jakarta.annotation.Nonnull
  public java.math.BigDecimal getContractSize() {
    return contractSize;
  }


  public void setContractSize(java.math.BigDecimal contractSize) {
    this.contractSize = contractSize;
  }


  public ContractForDifference payCcy(String payCcy) {
    
    this.payCcy = payCcy;
    return this;
  }

   /**
   * The currency that this CFD pays out, this can be different to the UnderlyingCcy.
   * @return payCcy
  **/
  @jakarta.annotation.Nonnull
  public String getPayCcy() {
    return payCcy;
  }


  public void setPayCcy(String payCcy) {
    this.payCcy = payCcy;
  }


  public ContractForDifference referenceRate(java.math.BigDecimal referenceRate) {
    
    this.referenceRate = referenceRate;
    return this;
  }

   /**
   * The reference rate of the CFD, this can be set to 0 but not negative values.  This field is optional, if not set it will default to 0.
   * @return referenceRate
  **/
  @jakarta.annotation.Nullable
  public java.math.BigDecimal getReferenceRate() {
    return referenceRate;
  }


  public void setReferenceRate(java.math.BigDecimal referenceRate) {
    this.referenceRate = referenceRate;
  }


  public ContractForDifference type(String type) {
    
    this.type = type;
    return this;
  }

   /**
   * The type of CFD.    Supported string (enumeration) values are: [Cash, Futures].
   * @return type
  **/
  @jakarta.annotation.Nonnull
  public String getType() {
    return type;
  }


  public void setType(String type) {
    this.type = type;
  }


  public ContractForDifference underlyingCcy(String underlyingCcy) {
    
    this.underlyingCcy = underlyingCcy;
    return this;
  }

   /**
   * The currency of the underlying
   * @return underlyingCcy
  **/
  @jakarta.annotation.Nullable
  public String getUnderlyingCcy() {
    return underlyingCcy;
  }


  public void setUnderlyingCcy(String underlyingCcy) {
    this.underlyingCcy = underlyingCcy;
  }


  public ContractForDifference underlyingIdentifier(String underlyingIdentifier) {
    
    this.underlyingIdentifier = underlyingIdentifier;
    return this;
  }

   /**
   * External market codes and identifiers for the CFD, e.g. RIC.    Supported string (enumeration) values are: [LusidInstrumentId, Isin, Sedol, Cusip, ClientInternal, Figi, RIC, QuotePermId, REDCode, BBGId, ICECode].
   * @return underlyingIdentifier
  **/
  @jakarta.annotation.Nullable
  public String getUnderlyingIdentifier() {
    return underlyingIdentifier;
  }


  public void setUnderlyingIdentifier(String underlyingIdentifier) {
    this.underlyingIdentifier = underlyingIdentifier;
  }


  public ContractForDifference lotSize(Integer lotSize) {
    
    this.lotSize = lotSize;
    return this;
  }

   /**
   * CFD LotSize, the minimum number of shares that can be bought or sold at once.  Optional, if set must be non-negative, if not set defaults to 1.
   * @return lotSize
  **/
  @jakarta.annotation.Nullable
  public Integer getLotSize() {
    return lotSize;
  }


  public void setLotSize(Integer lotSize) {
    this.lotSize = lotSize;
  }


  public ContractForDifference underlying(LusidInstrument underlying) {
    
    this.underlying = underlying;
    return this;
  }

   /**
   * Get underlying
   * @return underlying
  **/
  @jakarta.annotation.Nullable
  public LusidInstrument getUnderlying() {
    return underlying;
  }


  public void setUnderlying(LusidInstrument underlying) {
    this.underlying = underlying;
  }



  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    ContractForDifference contractForDifference = (ContractForDifference) o;
    return Objects.equals(this.startDate, contractForDifference.startDate) &&
        Objects.equals(this.maturityDate, contractForDifference.maturityDate) &&
        Objects.equals(this.code, contractForDifference.code) &&
        (this.contractSize.compareTo(contractForDifference.getContractSize()) == 0) &&
        Objects.equals(this.payCcy, contractForDifference.payCcy) &&
        (this.referenceRate.compareTo(contractForDifference.getReferenceRate()) == 0) &&
        Objects.equals(this.type, contractForDifference.type) &&
        Objects.equals(this.underlyingCcy, contractForDifference.underlyingCcy) &&
        Objects.equals(this.underlyingIdentifier, contractForDifference.underlyingIdentifier) &&
        Objects.equals(this.lotSize, contractForDifference.lotSize) &&
        Objects.equals(this.underlying, contractForDifference.underlying) &&
        super.equals(o);
  }

  private static <T> boolean equalsNullable(JsonNullable<T> a, JsonNullable<T> b) {
    return a == b || (a != null && b != null && a.isPresent() && b.isPresent() && Objects.deepEquals(a.get(), b.get()));
  }

  @Override
  public int hashCode() {
    return Objects.hash(startDate, maturityDate, code, contractSize, payCcy, referenceRate, type, underlyingCcy, underlyingIdentifier, lotSize, underlying, super.hashCode());
  }

  private static <T> int hashCodeNullable(JsonNullable<T> a) {
    if (a == null) {
      return 1;
    }
    return a.isPresent() ? Arrays.deepHashCode(new Object[]{a.get()}) : 31;
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class ContractForDifference {\n");
    sb.append("    ").append(toIndentedString(super.toString())).append("\n");
    sb.append("    startDate: ").append(toIndentedString(startDate)).append("\n");
    sb.append("    maturityDate: ").append(toIndentedString(maturityDate)).append("\n");
    sb.append("    code: ").append(toIndentedString(code)).append("\n");
    sb.append("    contractSize: ").append(toIndentedString(contractSize)).append("\n");
    sb.append("    payCcy: ").append(toIndentedString(payCcy)).append("\n");
    sb.append("    referenceRate: ").append(toIndentedString(referenceRate)).append("\n");
    sb.append("    type: ").append(toIndentedString(type)).append("\n");
    sb.append("    underlyingCcy: ").append(toIndentedString(underlyingCcy)).append("\n");
    sb.append("    underlyingIdentifier: ").append(toIndentedString(underlyingIdentifier)).append("\n");
    sb.append("    lotSize: ").append(toIndentedString(lotSize)).append("\n");
    sb.append("    underlying: ").append(toIndentedString(underlying)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }


  public static HashSet<String> openapiFields;
  public static HashSet<String> openapiRequiredFields;

  static {
    // a set of all properties/fields (JSON key names)
    openapiFields = new HashSet<String>();
    openapiFields.add("instrumentType");
    openapiFields.add("startDate");
    openapiFields.add("maturityDate");
    openapiFields.add("code");
    openapiFields.add("contractSize");
    openapiFields.add("payCcy");
    openapiFields.add("referenceRate");
    openapiFields.add("type");
    openapiFields.add("underlyingCcy");
    openapiFields.add("underlyingIdentifier");
    openapiFields.add("lotSize");
    openapiFields.add("underlying");

    // a set of required properties/fields (JSON key names)
    openapiRequiredFields = new HashSet<String>();
    openapiRequiredFields.add("startDate");
    openapiRequiredFields.add("contractSize");
    openapiRequiredFields.add("payCcy");
    openapiRequiredFields.add("type");
    openapiRequiredFields.add("instrumentType");
  }

 /**
  * Validates the JSON Element and throws an exception if issues found
  *
  * @param jsonElement JSON Element
  * @throws IOException if the JSON Element is invalid with respect to ContractForDifference
  */
  public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      if (jsonElement == null) {
        if (!ContractForDifference.openapiRequiredFields.isEmpty()) { // has required fields but JSON element is null
          throw new IllegalArgumentException(String.format("The required field(s) %s in ContractForDifference is not found in the empty JSON string", ContractForDifference.openapiRequiredFields.toString()));
        }
      }

      // check to make sure all required properties/fields are present in the JSON string
      for (String requiredField : ContractForDifference.openapiRequiredFields) {
        if (jsonElement.getAsJsonObject().get(requiredField) == null) {
          throw new IllegalArgumentException(String.format("The required field `%s` is not found in the JSON string: %s", requiredField, jsonElement.toString()));
        }
      }
  }

  public static class CustomTypeAdapterFactory implements TypeAdapterFactory {
    @SuppressWarnings("unchecked")
    @Override
    public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {
       if (!ContractForDifference.class.isAssignableFrom(type.getRawType())) {
         return null; // this class only serializes 'ContractForDifference' and its subtypes
       }
       final TypeAdapter<JsonElement> elementAdapter = gson.getAdapter(JsonElement.class);
       final TypeAdapter<ContractForDifference> thisAdapter
                        = gson.getDelegateAdapter(this, TypeToken.get(ContractForDifference.class));

       return (TypeAdapter<T>) new TypeAdapter<ContractForDifference>() {
           @Override
           public void write(JsonWriter out, ContractForDifference value) throws IOException {
             JsonObject obj = thisAdapter.toJsonTree(value).getAsJsonObject();
             elementAdapter.write(out, obj);
           }

           @Override
           public ContractForDifference read(JsonReader in) throws IOException {
             JsonElement jsonElement = elementAdapter.read(in);
             validateJsonElement(jsonElement);
             return thisAdapter.fromJsonTree(jsonElement);
           }

       }.nullSafe();
    }
  }

 /**
  * Create an instance of ContractForDifference given an JSON string
  *
  * @param jsonString JSON string
  * @return An instance of ContractForDifference
  * @throws IOException if the JSON string is invalid with respect to ContractForDifference
  */
  public static ContractForDifference fromJson(String jsonString) throws IOException {
    return JSON.getGson().fromJson(jsonString, ContractForDifference.class);
  }

 /**
  * Convert an instance of ContractForDifference to an JSON string
  *
  * @return JSON string
  */
  public String toJson() {
    return JSON.getGson().toJson(this);
  }
}
