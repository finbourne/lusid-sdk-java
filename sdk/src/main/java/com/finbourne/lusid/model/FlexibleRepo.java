/*
 * LUSID API
 *
 * Contact: info@finbourne.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

package com.finbourne.lusid.model;

import java.util.Objects;
import com.finbourne.lusid.model.Collateral;
import com.finbourne.lusid.model.LusidInstrument;
import com.finbourne.lusid.model.Schedule;
import com.finbourne.lusid.model.TimeZoneConventions;
import com.finbourne.lusid.model.TradingConventions;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;
import java.time.OffsetDateTime;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import org.openapitools.jackson.nullable.JsonNullable;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonArray;
import com.google.gson.JsonDeserializationContext;
import com.google.gson.JsonDeserializer;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParseException;
import com.google.gson.TypeAdapterFactory;
import com.google.gson.reflect.TypeToken;
import com.google.gson.TypeAdapter;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;

import java.lang.reflect.Type;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Map.Entry;
import java.util.Set;

import com.finbourne.lusid.JSON;

/**
 * Lusid representation of a repurchase agreement, where one party sells some collateral and agrees to re-buy it at a later date for some given price.
 */
@jakarta.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen")
public class FlexibleRepo extends LusidInstrument {
  public static final String SERIALIZED_NAME_START_DATE = "startDate";
  @SerializedName(SERIALIZED_NAME_START_DATE)
  private OffsetDateTime startDate;

  public static final String SERIALIZED_NAME_MATURITY_DATE = "maturityDate";
  @SerializedName(SERIALIZED_NAME_MATURITY_DATE)
  private OffsetDateTime maturityDate;

  public static final String SERIALIZED_NAME_BUYER_OR_SELLER = "buyerOrSeller";
  @SerializedName(SERIALIZED_NAME_BUYER_OR_SELLER)
  private String buyerOrSeller;

  public static final String SERIALIZED_NAME_REPO_CCY = "repoCcy";
  @SerializedName(SERIALIZED_NAME_REPO_CCY)
  private String repoCcy;

  public static final String SERIALIZED_NAME_REPO_TYPE = "repoType";
  @SerializedName(SERIALIZED_NAME_REPO_TYPE)
  private String repoType;

  public static final String SERIALIZED_NAME_ACCRUAL_BASIS = "accrualBasis";
  @SerializedName(SERIALIZED_NAME_ACCRUAL_BASIS)
  private String accrualBasis;

  public static final String SERIALIZED_NAME_COLLATERAL = "collateral";
  @SerializedName(SERIALIZED_NAME_COLLATERAL)
  private Collateral collateral;

  public static final String SERIALIZED_NAME_HAIRCUT = "haircut";
  @SerializedName(SERIALIZED_NAME_HAIRCUT)
  private java.math.BigDecimal haircut;

  public static final String SERIALIZED_NAME_MARGIN = "margin";
  @SerializedName(SERIALIZED_NAME_MARGIN)
  private java.math.BigDecimal margin;

  public static final String SERIALIZED_NAME_OPEN_REPO_ROLLING_PERIOD = "openRepoRollingPeriod";
  @SerializedName(SERIALIZED_NAME_OPEN_REPO_ROLLING_PERIOD)
  private String openRepoRollingPeriod;

  public static final String SERIALIZED_NAME_PURCHASE_PRICE = "purchasePrice";
  @SerializedName(SERIALIZED_NAME_PURCHASE_PRICE)
  private java.math.BigDecimal purchasePrice;

  public static final String SERIALIZED_NAME_REPO_RATE_SCHEDULES = "repoRateSchedules";
  @SerializedName(SERIALIZED_NAME_REPO_RATE_SCHEDULES)
  private List<Schedule> repoRateSchedules;

  public static final String SERIALIZED_NAME_REPURCHASE_PRICE = "repurchasePrice";
  @SerializedName(SERIALIZED_NAME_REPURCHASE_PRICE)
  private java.math.BigDecimal repurchasePrice;

  public static final String SERIALIZED_NAME_TIME_ZONE_CONVENTIONS = "timeZoneConventions";
  @SerializedName(SERIALIZED_NAME_TIME_ZONE_CONVENTIONS)
  private TimeZoneConventions timeZoneConventions;

  public static final String SERIALIZED_NAME_TRADING_CONVENTIONS = "tradingConventions";
  @SerializedName(SERIALIZED_NAME_TRADING_CONVENTIONS)
  private TradingConventions tradingConventions;

  public FlexibleRepo() {
    // this.instrumentType = this.getClass().getSimpleName();
  }

  public FlexibleRepo startDate(OffsetDateTime startDate) {
    
    this.startDate = startDate;
    return this;
  }

   /**
   * The start date of the instrument. This is normally synonymous with the trade-date.
   * @return startDate
  **/
  @jakarta.annotation.Nonnull
  public OffsetDateTime getStartDate() {
    return startDate;
  }


  public void setStartDate(OffsetDateTime startDate) {
    this.startDate = startDate;
  }


  public FlexibleRepo maturityDate(OffsetDateTime maturityDate) {
    
    this.maturityDate = maturityDate;
    return this;
  }

   /**
   * The maturity date of the instrument. This is the date at which the repurchase will occur for a TermRepo.  Optional for OpenRepo, but if not provided, defaults to the StartDate plus a long period (e.g. 2099-12-31).
   * @return maturityDate
  **/
  @jakarta.annotation.Nullable
  public OffsetDateTime getMaturityDate() {
    return maturityDate;
  }


  public void setMaturityDate(OffsetDateTime maturityDate) {
    this.maturityDate = maturityDate;
  }


  public FlexibleRepo buyerOrSeller(String buyerOrSeller) {
    
    this.buyerOrSeller = buyerOrSeller;
    return this;
  }

   /**
   * Is the user the Buyer or the Seller of this repo?  Every repo agreement has two sides, a buyer and a seller.  The Buyer pays the PurchasePrice to the Seller in exchange for legal ownership of the collateral.  At Maturity, the Buyer then receives the RepurchasePrice in exchange for returning legal ownership of the collateral.  Controls the direction of purchase and repurchase cashflows, as well as the recipient of cashflows from the collateral.    Supported string (enumeration) values are: [Buyer, Seller].
   * @return buyerOrSeller
  **/
  @jakarta.annotation.Nonnull
  public String getBuyerOrSeller() {
    return buyerOrSeller;
  }


  public void setBuyerOrSeller(String buyerOrSeller) {
    this.buyerOrSeller = buyerOrSeller;
  }


  public FlexibleRepo repoCcy(String repoCcy) {
    
    this.repoCcy = repoCcy;
    return this;
  }

   /**
   * Currency of the purchase and repurchase prices. May differ from the currencies on any collateral.
   * @return repoCcy
  **/
  @jakarta.annotation.Nonnull
  public String getRepoCcy() {
    return repoCcy;
  }


  public void setRepoCcy(String repoCcy) {
    this.repoCcy = repoCcy;
  }


  public FlexibleRepo repoType(String repoType) {
    
    this.repoType = repoType;
    return this;
  }

   /**
   * The type of the repurchase agreement, Open or Term.  If Term, the repurchase automatically takes place at Maturity.  If Open, the agreement is rolled by the given tenor, and an interest cashflow is paid out with each roll,  unless manually triggered by a FlexibleRepoFullClosureEvent.    Supported string (enumeration) values are: [OpenRepo, TermRepo].
   * @return repoType
  **/
  @jakarta.annotation.Nonnull
  public String getRepoType() {
    return repoType;
  }


  public void setRepoType(String repoType) {
    this.repoType = repoType;
  }


  public FlexibleRepo accrualBasis(String accrualBasis) {
    
    this.accrualBasis = accrualBasis;
    return this;
  }

   /**
   * For calculation of interest, the accrual day count to be used.  Required if no RepoRateSchedules are provided.  If both RepoRateSchedules and AccrualBasis are provided,  then AccrualBasis will take precedence.    Supported string (enumeration) values are: [Actual360, Act360, MoneyMarket, Actual365, Act365, Thirty360, ThirtyU360, Bond, ThirtyE360, EuroBond, ActualActual, ActAct, ActActIsda, ActActIsma, ActActIcma, OneOne, Act364, Act365F, Act365L, Act365_25, Act252, Bus252, NL360, NL365, ActActAFB, Act365Cad, ThirtyActIsda, Thirty365Isda, ThirtyEActIsda, ThirtyE360Isda, ThirtyE365Isda, ThirtyU360EOM].
   * @return accrualBasis
  **/
  @jakarta.annotation.Nullable
  public String getAccrualBasis() {
    return accrualBasis;
  }


  public void setAccrualBasis(String accrualBasis) {
    this.accrualBasis = accrualBasis;
  }


  public FlexibleRepo collateral(Collateral collateral) {
    
    this.collateral = collateral;
    return this;
  }

   /**
   * Get collateral
   * @return collateral
  **/
  @jakarta.annotation.Nullable
  public Collateral getCollateral() {
    return collateral;
  }


  public void setCollateral(Collateral collateral) {
    this.collateral = collateral;
  }


  public FlexibleRepo haircut(java.math.BigDecimal haircut) {
    
    this.haircut = haircut;
    return this;
  }

   /**
   * Haircut on the value of the collateral, used to calculate PurchasePrice if not provided directly.  Haircut or Margin should be specified if PurchasePrice is not specified.
   * @return haircut
  **/
  @jakarta.annotation.Nullable
  public java.math.BigDecimal getHaircut() {
    return haircut;
  }


  public void setHaircut(java.math.BigDecimal haircut) {
    this.haircut = haircut;
  }


  public FlexibleRepo margin(java.math.BigDecimal margin) {
    
    this.margin = margin;
    return this;
  }

   /**
   * Initial margin on the value of the collateral, used to calculate PurchasePrice if not provided directly.  Haircut or Margin should be specified if PurchasePrice is not specified.
   * @return margin
  **/
  @jakarta.annotation.Nullable
  public java.math.BigDecimal getMargin() {
    return margin;
  }


  public void setMargin(java.math.BigDecimal margin) {
    this.margin = margin;
  }


  public FlexibleRepo openRepoRollingPeriod(String openRepoRollingPeriod) {
    
    this.openRepoRollingPeriod = openRepoRollingPeriod;
    return this;
  }

   /**
   * Required if the RepoType is Open.  The tenor representing the mandatory roll period if the FlexibleRepo is not manually matured.  If a user matures the FlexibleRepo via an instrument event, then the repurchase will delay until the end of this rolling period.  Generally this is set to 1D (one day), i.e. the repurchase will occur on the same day as the instrument event,  though any valid tenor is accepted with TenorUnit set to Day, Week, Month, or Year.  Note that TenorUnit T is not accepted here.
   * @return openRepoRollingPeriod
  **/
  @jakarta.annotation.Nullable
  public String getOpenRepoRollingPeriod() {
    return openRepoRollingPeriod;
  }


  public void setOpenRepoRollingPeriod(String openRepoRollingPeriod) {
    this.openRepoRollingPeriod = openRepoRollingPeriod;
  }


  public FlexibleRepo purchasePrice(java.math.BigDecimal purchasePrice) {
    
    this.purchasePrice = purchasePrice;
    return this;
  }

   /**
   * The initial purchase price of the collateral.  If provided directly in this field, then Collateral.CollateralValue,  Haircut, and Margin should not be provided.
   * @return purchasePrice
  **/
  @jakarta.annotation.Nullable
  public java.math.BigDecimal getPurchasePrice() {
    return purchasePrice;
  }


  public void setPurchasePrice(java.math.BigDecimal purchasePrice) {
    this.purchasePrice = purchasePrice;
  }


  public FlexibleRepo repoRateSchedules(List<Schedule> repoRateSchedules) {
    
    this.repoRateSchedules = repoRateSchedules;
    return this;
  }

  public FlexibleRepo addRepoRateSchedulesItem(Schedule repoRateSchedulesItem) {
    if (this.repoRateSchedules == null) {
      this.repoRateSchedules = new ArrayList<>();
    }
    this.repoRateSchedules.add(repoRateSchedulesItem);
    return this;
  }

   /**
   * Schedules used to calculate the repurchase price and any interest payments on the FlexibleRepo.  Only one schedule may be provided, and must be of type FixedSchedule or FloatSchedule.  If RepoType is OpenRepo, a FixedSchedule or FloatSchedule must be provided to calculate the expected Repo Rate,  and RepurchasePrice must be omitted.  If RepoType is TermRepo, only one of RepurchasePrice and RepoRateSchedules should be provided.  If a RepoRateSchedule is provided on a TermRepo, the PaymentFrequency in the FlowConventions should be 1T.  StubType must be set to None, and no ExDividend configuration should be provided.
   * @return repoRateSchedules
  **/
  @jakarta.annotation.Nullable
  public List<Schedule> getRepoRateSchedules() {
    return repoRateSchedules;
  }


  public void setRepoRateSchedules(List<Schedule> repoRateSchedules) {
    this.repoRateSchedules = repoRateSchedules;
  }


  public FlexibleRepo repurchasePrice(java.math.BigDecimal repurchasePrice) {
    
    this.repurchasePrice = repurchasePrice;
    return this;
  }

   /**
   * The repurchase price of the repo, if known.  Only one of RepurchasePrice and RepoRateSchedules should be provided.  In the case of an OpenRepo, RepurchasePrice should not be provided,  and RepoRateSchedules should be provided instead in order to calculate the RepoRate.
   * @return repurchasePrice
  **/
  @jakarta.annotation.Nullable
  public java.math.BigDecimal getRepurchasePrice() {
    return repurchasePrice;
  }


  public void setRepurchasePrice(java.math.BigDecimal repurchasePrice) {
    this.repurchasePrice = repurchasePrice;
  }


  public FlexibleRepo timeZoneConventions(TimeZoneConventions timeZoneConventions) {
    
    this.timeZoneConventions = timeZoneConventions;
    return this;
  }

   /**
   * Get timeZoneConventions
   * @return timeZoneConventions
  **/
  @jakarta.annotation.Nullable
  public TimeZoneConventions getTimeZoneConventions() {
    return timeZoneConventions;
  }


  public void setTimeZoneConventions(TimeZoneConventions timeZoneConventions) {
    this.timeZoneConventions = timeZoneConventions;
  }


  public FlexibleRepo tradingConventions(TradingConventions tradingConventions) {
    
    this.tradingConventions = tradingConventions;
    return this;
  }

   /**
   * Get tradingConventions
   * @return tradingConventions
  **/
  @jakarta.annotation.Nullable
  public TradingConventions getTradingConventions() {
    return tradingConventions;
  }


  public void setTradingConventions(TradingConventions tradingConventions) {
    this.tradingConventions = tradingConventions;
  }



  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    FlexibleRepo flexibleRepo = (FlexibleRepo) o;
    return Objects.equals(this.startDate, flexibleRepo.startDate) &&
        Objects.equals(this.maturityDate, flexibleRepo.maturityDate) &&
        Objects.equals(this.buyerOrSeller, flexibleRepo.buyerOrSeller) &&
        Objects.equals(this.repoCcy, flexibleRepo.repoCcy) &&
        Objects.equals(this.repoType, flexibleRepo.repoType) &&
        Objects.equals(this.accrualBasis, flexibleRepo.accrualBasis) &&
        Objects.equals(this.collateral, flexibleRepo.collateral) &&
        (this.haircut.compareTo(flexibleRepo.getHaircut()) == 0) &&
        (this.margin.compareTo(flexibleRepo.getMargin()) == 0) &&
        Objects.equals(this.openRepoRollingPeriod, flexibleRepo.openRepoRollingPeriod) &&
        (this.purchasePrice.compareTo(flexibleRepo.getPurchasePrice()) == 0) &&
        Objects.equals(this.repoRateSchedules, flexibleRepo.repoRateSchedules) &&
        (this.repurchasePrice.compareTo(flexibleRepo.getRepurchasePrice()) == 0) &&
        Objects.equals(this.timeZoneConventions, flexibleRepo.timeZoneConventions) &&
        Objects.equals(this.tradingConventions, flexibleRepo.tradingConventions) &&
        super.equals(o);
  }

  private static <T> boolean equalsNullable(JsonNullable<T> a, JsonNullable<T> b) {
    return a == b || (a != null && b != null && a.isPresent() && b.isPresent() && Objects.deepEquals(a.get(), b.get()));
  }

  @Override
  public int hashCode() {
    return Objects.hash(startDate, maturityDate, buyerOrSeller, repoCcy, repoType, accrualBasis, collateral, haircut, margin, openRepoRollingPeriod, purchasePrice, repoRateSchedules, repurchasePrice, timeZoneConventions, tradingConventions, super.hashCode());
  }

  private static <T> int hashCodeNullable(JsonNullable<T> a) {
    if (a == null) {
      return 1;
    }
    return a.isPresent() ? Arrays.deepHashCode(new Object[]{a.get()}) : 31;
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class FlexibleRepo {\n");
    sb.append("    ").append(toIndentedString(super.toString())).append("\n");
    sb.append("    startDate: ").append(toIndentedString(startDate)).append("\n");
    sb.append("    maturityDate: ").append(toIndentedString(maturityDate)).append("\n");
    sb.append("    buyerOrSeller: ").append(toIndentedString(buyerOrSeller)).append("\n");
    sb.append("    repoCcy: ").append(toIndentedString(repoCcy)).append("\n");
    sb.append("    repoType: ").append(toIndentedString(repoType)).append("\n");
    sb.append("    accrualBasis: ").append(toIndentedString(accrualBasis)).append("\n");
    sb.append("    collateral: ").append(toIndentedString(collateral)).append("\n");
    sb.append("    haircut: ").append(toIndentedString(haircut)).append("\n");
    sb.append("    margin: ").append(toIndentedString(margin)).append("\n");
    sb.append("    openRepoRollingPeriod: ").append(toIndentedString(openRepoRollingPeriod)).append("\n");
    sb.append("    purchasePrice: ").append(toIndentedString(purchasePrice)).append("\n");
    sb.append("    repoRateSchedules: ").append(toIndentedString(repoRateSchedules)).append("\n");
    sb.append("    repurchasePrice: ").append(toIndentedString(repurchasePrice)).append("\n");
    sb.append("    timeZoneConventions: ").append(toIndentedString(timeZoneConventions)).append("\n");
    sb.append("    tradingConventions: ").append(toIndentedString(tradingConventions)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }


  public static HashSet<String> openapiFields;
  public static HashSet<String> openapiRequiredFields;

  static {
    // a set of all properties/fields (JSON key names)
    openapiFields = new HashSet<String>();
    openapiFields.add("instrumentType");
    openapiFields.add("startDate");
    openapiFields.add("maturityDate");
    openapiFields.add("buyerOrSeller");
    openapiFields.add("repoCcy");
    openapiFields.add("repoType");
    openapiFields.add("accrualBasis");
    openapiFields.add("collateral");
    openapiFields.add("haircut");
    openapiFields.add("margin");
    openapiFields.add("openRepoRollingPeriod");
    openapiFields.add("purchasePrice");
    openapiFields.add("repoRateSchedules");
    openapiFields.add("repurchasePrice");
    openapiFields.add("timeZoneConventions");
    openapiFields.add("tradingConventions");

    // a set of required properties/fields (JSON key names)
    openapiRequiredFields = new HashSet<String>();
    openapiRequiredFields.add("startDate");
    openapiRequiredFields.add("buyerOrSeller");
    openapiRequiredFields.add("repoCcy");
    openapiRequiredFields.add("repoType");
    openapiRequiredFields.add("instrumentType");
  }

 /**
  * Validates the JSON Element and throws an exception if issues found
  *
  * @param jsonElement JSON Element
  * @throws IOException if the JSON Element is invalid with respect to FlexibleRepo
  */
  public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      if (jsonElement == null) {
        if (!FlexibleRepo.openapiRequiredFields.isEmpty()) { // has required fields but JSON element is null
          throw new IllegalArgumentException(String.format("The required field(s) %s in FlexibleRepo is not found in the empty JSON string", FlexibleRepo.openapiRequiredFields.toString()));
        }
      }

      // check to make sure all required properties/fields are present in the JSON string
      for (String requiredField : FlexibleRepo.openapiRequiredFields) {
        if (jsonElement.getAsJsonObject().get(requiredField) == null) {
          throw new IllegalArgumentException(String.format("The required field `%s` is not found in the JSON string: %s", requiredField, jsonElement.toString()));
        }
      }
  }

  public static class CustomTypeAdapterFactory implements TypeAdapterFactory {
    @SuppressWarnings("unchecked")
    @Override
    public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {
       if (!FlexibleRepo.class.isAssignableFrom(type.getRawType())) {
         return null; // this class only serializes 'FlexibleRepo' and its subtypes
       }
       final TypeAdapter<JsonElement> elementAdapter = gson.getAdapter(JsonElement.class);
       final TypeAdapter<FlexibleRepo> thisAdapter
                        = gson.getDelegateAdapter(this, TypeToken.get(FlexibleRepo.class));

       return (TypeAdapter<T>) new TypeAdapter<FlexibleRepo>() {
           @Override
           public void write(JsonWriter out, FlexibleRepo value) throws IOException {
             JsonObject obj = thisAdapter.toJsonTree(value).getAsJsonObject();
             elementAdapter.write(out, obj);
           }

           @Override
           public FlexibleRepo read(JsonReader in) throws IOException {
             JsonElement jsonElement = elementAdapter.read(in);
             validateJsonElement(jsonElement);
             return thisAdapter.fromJsonTree(jsonElement);
           }

       }.nullSafe();
    }
  }

 /**
  * Create an instance of FlexibleRepo given an JSON string
  *
  * @param jsonString JSON string
  * @return An instance of FlexibleRepo
  * @throws IOException if the JSON string is invalid with respect to FlexibleRepo
  */
  public static FlexibleRepo fromJson(String jsonString) throws IOException {
    return JSON.getGson().fromJson(jsonString, FlexibleRepo.class);
  }

 /**
  * Convert an instance of FlexibleRepo to an JSON string
  *
  * @return JSON string
  */
  public String toJson() {
    return JSON.getGson().toJson(this);
  }
}
