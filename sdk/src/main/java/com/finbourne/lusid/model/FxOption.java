/*
 * LUSID API
 *
 * Contact: info@finbourne.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

package com.finbourne.lusid.model;

import java.util.Objects;
import java.util.Arrays;
import com.finbourne.lusid.model.Barrier;
import com.finbourne.lusid.model.LusidInstrument;
import com.finbourne.lusid.model.Premium;
import com.finbourne.lusid.model.Touch;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;
import java.time.OffsetDateTime;
import java.util.ArrayList;
import java.util.List;
import org.openapitools.jackson.nullable.JsonNullable;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonArray;
import com.google.gson.JsonDeserializationContext;
import com.google.gson.JsonDeserializer;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParseException;
import com.google.gson.TypeAdapterFactory;
import com.google.gson.reflect.TypeToken;
import com.google.gson.TypeAdapter;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;

import java.lang.reflect.Type;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Map.Entry;
import java.util.Set;

import com.finbourne.lusid.JSON;

/**
 * LUSID representation of an FX Option.  Including Vanilla, American, European, and Digital (Binary) options.
 */
@javax.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen")
public class FxOption extends LusidInstrument {
  public static final String SERIALIZED_NAME_START_DATE = "startDate";
  @SerializedName(SERIALIZED_NAME_START_DATE)
  private OffsetDateTime startDate;

  public static final String SERIALIZED_NAME_DOM_CCY = "domCcy";
  @SerializedName(SERIALIZED_NAME_DOM_CCY)
  private String domCcy;

  public static final String SERIALIZED_NAME_DOM_AMOUNT = "domAmount";
  @SerializedName(SERIALIZED_NAME_DOM_AMOUNT)
  private java.math.BigDecimal domAmount;

  public static final String SERIALIZED_NAME_FGN_CCY = "fgnCcy";
  @SerializedName(SERIALIZED_NAME_FGN_CCY)
  private String fgnCcy;

  public static final String SERIALIZED_NAME_FGN_AMOUNT = "fgnAmount";
  @SerializedName(SERIALIZED_NAME_FGN_AMOUNT)
  private java.math.BigDecimal fgnAmount;

  public static final String SERIALIZED_NAME_STRIKE = "strike";
  @SerializedName(SERIALIZED_NAME_STRIKE)
  private java.math.BigDecimal strike;

  public static final String SERIALIZED_NAME_BARRIERS = "barriers";
  @SerializedName(SERIALIZED_NAME_BARRIERS)
  private List<Barrier> barriers;

  public static final String SERIALIZED_NAME_EXERCISE_TYPE = "exerciseType";
  @SerializedName(SERIALIZED_NAME_EXERCISE_TYPE)
  private String exerciseType;

  public static final String SERIALIZED_NAME_IS_CALL_NOT_PUT = "isCallNotPut";
  @SerializedName(SERIALIZED_NAME_IS_CALL_NOT_PUT)
  private Boolean isCallNotPut;

  public static final String SERIALIZED_NAME_IS_DELIVERY_NOT_CASH = "isDeliveryNotCash";
  @SerializedName(SERIALIZED_NAME_IS_DELIVERY_NOT_CASH)
  private Boolean isDeliveryNotCash;

  public static final String SERIALIZED_NAME_IS_PAYOFF_DIGITAL = "isPayoffDigital";
  @SerializedName(SERIALIZED_NAME_IS_PAYOFF_DIGITAL)
  private Boolean isPayoffDigital;

  public static final String SERIALIZED_NAME_OPTION_MATURITY_DATE = "optionMaturityDate";
  @SerializedName(SERIALIZED_NAME_OPTION_MATURITY_DATE)
  private OffsetDateTime optionMaturityDate;

  public static final String SERIALIZED_NAME_OPTION_SETTLEMENT_DATE = "optionSettlementDate";
  @SerializedName(SERIALIZED_NAME_OPTION_SETTLEMENT_DATE)
  private OffsetDateTime optionSettlementDate;

  public static final String SERIALIZED_NAME_PAYOUT_STYLE = "payoutStyle";
  @SerializedName(SERIALIZED_NAME_PAYOUT_STYLE)
  private String payoutStyle;

  public static final String SERIALIZED_NAME_PREMIUM = "premium";
  @SerializedName(SERIALIZED_NAME_PREMIUM)
  private Premium premium;

  public static final String SERIALIZED_NAME_TOUCHES = "touches";
  @SerializedName(SERIALIZED_NAME_TOUCHES)
  private List<Touch> touches;

  public FxOption() {
    // this.instrumentType = this.getClass().getSimpleName();
  }

  public FxOption startDate(OffsetDateTime startDate) {
    
    this.startDate = startDate;
    return this;
  }

   /**
   * The start date of the instrument. This is normally synonymous with the trade-date.
   * @return startDate
  **/
  @javax.annotation.Nonnull
  public OffsetDateTime getStartDate() {
    return startDate;
  }


  public void setStartDate(OffsetDateTime startDate) {
    this.startDate = startDate;
  }


  public FxOption domCcy(String domCcy) {
    
    this.domCcy = domCcy;
    return this;
  }

   /**
   * The domestic currency of the instrument.
   * @return domCcy
  **/
  @javax.annotation.Nonnull
  public String getDomCcy() {
    return domCcy;
  }


  public void setDomCcy(String domCcy) {
    this.domCcy = domCcy;
  }


  public FxOption domAmount(java.math.BigDecimal domAmount) {
    
    this.domAmount = domAmount;
    return this;
  }

   /**
   * The Amount of DomCcy that will be exchanged if the option is exercised.  This amount should be a positive number, with the Call/Put flag used to indicate direction.  The corresponding amount of FgnCcy that will be exchanged is this amount times the strike.  Note there is no rounding performed on this computed value.  This is an optional field, if not set the option ContractSize will default to 1.
   * @return domAmount
  **/
  @javax.annotation.Nullable
  public java.math.BigDecimal getDomAmount() {
    return domAmount;
  }


  public void setDomAmount(java.math.BigDecimal domAmount) {
    this.domAmount = domAmount;
  }


  public FxOption fgnCcy(String fgnCcy) {
    
    this.fgnCcy = fgnCcy;
    return this;
  }

   /**
   * The foreign currency of the FX.
   * @return fgnCcy
  **/
  @javax.annotation.Nonnull
  public String getFgnCcy() {
    return fgnCcy;
  }


  public void setFgnCcy(String fgnCcy) {
    this.fgnCcy = fgnCcy;
  }


  public FxOption fgnAmount(java.math.BigDecimal fgnAmount) {
    
    this.fgnAmount = fgnAmount;
    return this;
  }

   /**
   * For a vanilla FxOption contract, FgnAmount cannot be set.  In case of a digital FxOption (IsPayoffDigital&#x3D;&#x3D;true)  a payoff (if the option is in the money) can be either  in domestic or in foreign currency - for the latter  FgnAmount must be set.  Note: It is invalid to have FgnAmount and DomAmount  at the same time.
   * @return fgnAmount
  **/
  @javax.annotation.Nullable
  public java.math.BigDecimal getFgnAmount() {
    return fgnAmount;
  }


  public void setFgnAmount(java.math.BigDecimal fgnAmount) {
    this.fgnAmount = fgnAmount;
  }


  public FxOption strike(java.math.BigDecimal strike) {
    
    this.strike = strike;
    return this;
  }

   /**
   * The strike of the option.
   * @return strike
  **/
  @javax.annotation.Nullable
  public java.math.BigDecimal getStrike() {
    return strike;
  }


  public void setStrike(java.math.BigDecimal strike) {
    this.strike = strike;
  }


  public FxOption barriers(List<Barrier> barriers) {
    
    this.barriers = barriers;
    return this;
  }

  public FxOption addBarriersItem(Barrier barriersItem) {
    if (this.barriers == null) {
      this.barriers = new ArrayList<>();
    }
    this.barriers.add(barriersItem);
    return this;
  }

   /**
   * For a barrier option the list should not be empty. Up to two barriers are supported.  An option cannot be at the same time barrier- and touch-option.  One (or both) of the lists must be empty.
   * @return barriers
  **/
  @javax.annotation.Nullable
  public List<Barrier> getBarriers() {
    return barriers;
  }


  public void setBarriers(List<Barrier> barriers) {
    this.barriers = barriers;
  }


  public FxOption exerciseType(String exerciseType) {
    
    this.exerciseType = exerciseType;
    return this;
  }

   /**
   * Type of optionality that is present; European, American.    Supported string (enumeration) values are: [European, American].
   * @return exerciseType
  **/
  @javax.annotation.Nullable
  public String getExerciseType() {
    return exerciseType;
  }


  public void setExerciseType(String exerciseType) {
    this.exerciseType = exerciseType;
  }


  public FxOption isCallNotPut(Boolean isCallNotPut) {
    
    this.isCallNotPut = isCallNotPut;
    return this;
  }

   /**
   * True if the option is a call, false if the option is a put.
   * @return isCallNotPut
  **/
  @javax.annotation.Nonnull
  public Boolean getIsCallNotPut() {
    return isCallNotPut;
  }


  public void setIsCallNotPut(Boolean isCallNotPut) {
    this.isCallNotPut = isCallNotPut;
  }


  public FxOption isDeliveryNotCash(Boolean isDeliveryNotCash) {
    
    this.isDeliveryNotCash = isDeliveryNotCash;
    return this;
  }

   /**
   * True if the option delivers the FX underlying, False if the option is settled in cash.
   * @return isDeliveryNotCash
  **/
  @javax.annotation.Nonnull
  public Boolean getIsDeliveryNotCash() {
    return isDeliveryNotCash;
  }


  public void setIsDeliveryNotCash(Boolean isDeliveryNotCash) {
    this.isDeliveryNotCash = isDeliveryNotCash;
  }


  public FxOption isPayoffDigital(Boolean isPayoffDigital) {
    
    this.isPayoffDigital = isPayoffDigital;
    return this;
  }

   /**
   * By default IsPayoffDigital is false. If IsPayoffDigital&#x3D;true,  the option is &#39;digital&#39;, and the option payoff is 0 or 1 unit of currency,  instead of a vanilla CallPayoff&#x3D;max(spot-strike,0) or PutPayoff&#x3D;max(strike-spot,0).
   * @return isPayoffDigital
  **/
  @javax.annotation.Nullable
  public Boolean getIsPayoffDigital() {
    return isPayoffDigital;
  }


  public void setIsPayoffDigital(Boolean isPayoffDigital) {
    this.isPayoffDigital = isPayoffDigital;
  }


  public FxOption optionMaturityDate(OffsetDateTime optionMaturityDate) {
    
    this.optionMaturityDate = optionMaturityDate;
    return this;
  }

   /**
   * The maturity date of the option.
   * @return optionMaturityDate
  **/
  @javax.annotation.Nonnull
  public OffsetDateTime getOptionMaturityDate() {
    return optionMaturityDate;
  }


  public void setOptionMaturityDate(OffsetDateTime optionMaturityDate) {
    this.optionMaturityDate = optionMaturityDate;
  }


  public FxOption optionSettlementDate(OffsetDateTime optionSettlementDate) {
    
    this.optionSettlementDate = optionSettlementDate;
    return this;
  }

   /**
   * The settlement date of the option.
   * @return optionSettlementDate
  **/
  @javax.annotation.Nonnull
  public OffsetDateTime getOptionSettlementDate() {
    return optionSettlementDate;
  }


  public void setOptionSettlementDate(OffsetDateTime optionSettlementDate) {
    this.optionSettlementDate = optionSettlementDate;
  }


  public FxOption payoutStyle(String payoutStyle) {
    
    this.payoutStyle = payoutStyle;
    return this;
  }

   /**
   * PayoutStyle for touch options.                For options without touch optionality, payoutStyle should not be set.  For options with touch optionality (where the touches data has been set), payoutStyle must be defined and cannot be None.    Supported string (enumeration) values are: [Deferred, Immediate].
   * @return payoutStyle
  **/
  @javax.annotation.Nullable
  public String getPayoutStyle() {
    return payoutStyle;
  }


  public void setPayoutStyle(String payoutStyle) {
    this.payoutStyle = payoutStyle;
  }


  public FxOption premium(Premium premium) {
    
    this.premium = premium;
    return this;
  }

   /**
   * Get premium
   * @return premium
  **/
  @javax.annotation.Nullable
  public Premium getPremium() {
    return premium;
  }


  public void setPremium(Premium premium) {
    this.premium = premium;
  }


  public FxOption touches(List<Touch> touches) {
    
    this.touches = touches;
    return this;
  }

  public FxOption addTouchesItem(Touch touchesItem) {
    if (this.touches == null) {
      this.touches = new ArrayList<>();
    }
    this.touches.add(touchesItem);
    return this;
  }

   /**
   * For a touch option the list should not be empty. Up to two touches are supported.  An option cannot be at the same time barrier- and touch-option.  One (or both) of the lists must be empty.
   * @return touches
  **/
  @javax.annotation.Nullable
  public List<Touch> getTouches() {
    return touches;
  }


  public void setTouches(List<Touch> touches) {
    this.touches = touches;
  }



  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    FxOption fxOption = (FxOption) o;
    return Objects.equals(this.startDate, fxOption.startDate) &&
        Objects.equals(this.domCcy, fxOption.domCcy) &&
        (this.domAmount.compareTo(fxOption.getDomAmount()) == 0) &&
        Objects.equals(this.fgnCcy, fxOption.fgnCcy) &&
        (this.fgnAmount.compareTo(fxOption.getFgnAmount()) == 0) &&
        (this.strike.compareTo(fxOption.getStrike()) == 0) &&
        Objects.equals(this.barriers, fxOption.barriers) &&
        Objects.equals(this.exerciseType, fxOption.exerciseType) &&
        Objects.equals(this.isCallNotPut, fxOption.isCallNotPut) &&
        Objects.equals(this.isDeliveryNotCash, fxOption.isDeliveryNotCash) &&
        Objects.equals(this.isPayoffDigital, fxOption.isPayoffDigital) &&
        Objects.equals(this.optionMaturityDate, fxOption.optionMaturityDate) &&
        Objects.equals(this.optionSettlementDate, fxOption.optionSettlementDate) &&
        Objects.equals(this.payoutStyle, fxOption.payoutStyle) &&
        Objects.equals(this.premium, fxOption.premium) &&
        Objects.equals(this.touches, fxOption.touches) &&
        super.equals(o);
  }

  private static <T> boolean equalsNullable(JsonNullable<T> a, JsonNullable<T> b) {
    return a == b || (a != null && b != null && a.isPresent() && b.isPresent() && Objects.deepEquals(a.get(), b.get()));
  }

  @Override
  public int hashCode() {
    return Objects.hash(startDate, domCcy, domAmount, fgnCcy, fgnAmount, strike, barriers, exerciseType, isCallNotPut, isDeliveryNotCash, isPayoffDigital, optionMaturityDate, optionSettlementDate, payoutStyle, premium, touches, super.hashCode());
  }

  private static <T> int hashCodeNullable(JsonNullable<T> a) {
    if (a == null) {
      return 1;
    }
    return a.isPresent() ? Arrays.deepHashCode(new Object[]{a.get()}) : 31;
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class FxOption {\n");
    sb.append("    ").append(toIndentedString(super.toString())).append("\n");
    sb.append("    startDate: ").append(toIndentedString(startDate)).append("\n");
    sb.append("    domCcy: ").append(toIndentedString(domCcy)).append("\n");
    sb.append("    domAmount: ").append(toIndentedString(domAmount)).append("\n");
    sb.append("    fgnCcy: ").append(toIndentedString(fgnCcy)).append("\n");
    sb.append("    fgnAmount: ").append(toIndentedString(fgnAmount)).append("\n");
    sb.append("    strike: ").append(toIndentedString(strike)).append("\n");
    sb.append("    barriers: ").append(toIndentedString(barriers)).append("\n");
    sb.append("    exerciseType: ").append(toIndentedString(exerciseType)).append("\n");
    sb.append("    isCallNotPut: ").append(toIndentedString(isCallNotPut)).append("\n");
    sb.append("    isDeliveryNotCash: ").append(toIndentedString(isDeliveryNotCash)).append("\n");
    sb.append("    isPayoffDigital: ").append(toIndentedString(isPayoffDigital)).append("\n");
    sb.append("    optionMaturityDate: ").append(toIndentedString(optionMaturityDate)).append("\n");
    sb.append("    optionSettlementDate: ").append(toIndentedString(optionSettlementDate)).append("\n");
    sb.append("    payoutStyle: ").append(toIndentedString(payoutStyle)).append("\n");
    sb.append("    premium: ").append(toIndentedString(premium)).append("\n");
    sb.append("    touches: ").append(toIndentedString(touches)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }


  public static HashSet<String> openapiFields;
  public static HashSet<String> openapiRequiredFields;

  static {
    // a set of all properties/fields (JSON key names)
    openapiFields = new HashSet<String>();
    openapiFields.add("instrumentType");
    openapiFields.add("startDate");
    openapiFields.add("domCcy");
    openapiFields.add("domAmount");
    openapiFields.add("fgnCcy");
    openapiFields.add("fgnAmount");
    openapiFields.add("strike");
    openapiFields.add("barriers");
    openapiFields.add("exerciseType");
    openapiFields.add("isCallNotPut");
    openapiFields.add("isDeliveryNotCash");
    openapiFields.add("isPayoffDigital");
    openapiFields.add("optionMaturityDate");
    openapiFields.add("optionSettlementDate");
    openapiFields.add("payoutStyle");
    openapiFields.add("premium");
    openapiFields.add("touches");

    // a set of required properties/fields (JSON key names)
    openapiRequiredFields = new HashSet<String>();
    openapiRequiredFields.add("startDate");
    openapiRequiredFields.add("domCcy");
    openapiRequiredFields.add("fgnCcy");
    openapiRequiredFields.add("isCallNotPut");
    openapiRequiredFields.add("isDeliveryNotCash");
    openapiRequiredFields.add("optionMaturityDate");
    openapiRequiredFields.add("optionSettlementDate");
    openapiRequiredFields.add("instrumentType");
  }

 /**
  * Validates the JSON Object and throws an exception if issues found
  *
  * @param jsonObj JSON Object
  * @throws IOException if the JSON Object is invalid with respect to FxOption
  */
  public static void validateJsonObject(JsonObject jsonObj) throws IOException {
      if (jsonObj == null) {
        if (!FxOption.openapiRequiredFields.isEmpty()) { // has required fields but JSON object is null
          throw new IllegalArgumentException(String.format("The required field(s) %s in FxOption is not found in the empty JSON string", FxOption.openapiRequiredFields.toString()));
        }
      }

      Set<Entry<String, JsonElement>> entries = jsonObj.entrySet();
      // check to see if the JSON string contains additional fields
      for (Entry<String, JsonElement> entry : entries) {
        if (!FxOption.openapiFields.contains(entry.getKey())) {
          throw new IllegalArgumentException(String.format("The field `%s` in the JSON string is not defined in the `FxOption` properties. JSON: %s", entry.getKey(), jsonObj.toString()));
        }
      }

      // check to make sure all required properties/fields are present in the JSON string
      for (String requiredField : FxOption.openapiRequiredFields) {
        if (jsonObj.get(requiredField) == null) {
          throw new IllegalArgumentException(String.format("The required field `%s` is not found in the JSON string: %s", requiredField, jsonObj.toString()));
        }
      }
  }

  public static class CustomTypeAdapterFactory implements TypeAdapterFactory {
    @SuppressWarnings("unchecked")
    @Override
    public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {
       if (!FxOption.class.isAssignableFrom(type.getRawType())) {
         return null; // this class only serializes 'FxOption' and its subtypes
       }
       final TypeAdapter<JsonElement> elementAdapter = gson.getAdapter(JsonElement.class);
       final TypeAdapter<FxOption> thisAdapter
                        = gson.getDelegateAdapter(this, TypeToken.get(FxOption.class));

       return (TypeAdapter<T>) new TypeAdapter<FxOption>() {
           @Override
           public void write(JsonWriter out, FxOption value) throws IOException {
             JsonObject obj = thisAdapter.toJsonTree(value).getAsJsonObject();
             elementAdapter.write(out, obj);
           }

           @Override
           public FxOption read(JsonReader in) throws IOException {
             JsonObject jsonObj = elementAdapter.read(in).getAsJsonObject();
             validateJsonObject(jsonObj);
             return thisAdapter.fromJsonTree(jsonObj);
           }

       }.nullSafe();
    }
  }

 /**
  * Create an instance of FxOption given an JSON string
  *
  * @param jsonString JSON string
  * @return An instance of FxOption
  * @throws IOException if the JSON string is invalid with respect to FxOption
  */
  public static FxOption fromJson(String jsonString) throws IOException {
    return JSON.getGson().fromJson(jsonString, FxOption.class);
  }

 /**
  * Convert an instance of FxOption to an JSON string
  *
  * @return JSON string
  */
  public String toJson() {
    return JSON.getGson().toJson(this);
  }
}
