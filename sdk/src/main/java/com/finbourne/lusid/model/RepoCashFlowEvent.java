/*
 * LUSID API
 *
 * Contact: info@finbourne.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

package com.finbourne.lusid.model;

import java.util.Objects;
import com.finbourne.lusid.model.InstrumentEvent;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;
import java.time.OffsetDateTime;
import java.util.Arrays;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonArray;
import com.google.gson.JsonDeserializationContext;
import com.google.gson.JsonDeserializer;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParseException;
import com.google.gson.TypeAdapterFactory;
import com.google.gson.reflect.TypeToken;
import com.google.gson.TypeAdapter;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;

import java.lang.reflect.Type;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Map.Entry;
import java.util.Set;

import com.finbourne.lusid.JSON;

/**
 * Event representing a repurchase agreement cashflow.   For example, cashflow for a partial closure of the   repurchase agreement.
 */
@jakarta.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen")
public class RepoCashFlowEvent extends InstrumentEvent {
  public static final String SERIALIZED_NAME_ENTITLEMENT_DATE = "entitlementDate";
  @SerializedName(SERIALIZED_NAME_ENTITLEMENT_DATE)
  private OffsetDateTime entitlementDate;

  public static final String SERIALIZED_NAME_SETTLEMENT_DATE = "settlementDate";
  @SerializedName(SERIALIZED_NAME_SETTLEMENT_DATE)
  private OffsetDateTime settlementDate;

  public static final String SERIALIZED_NAME_CASH_FLOW_PER_UNIT = "cashFlowPerUnit";
  @SerializedName(SERIALIZED_NAME_CASH_FLOW_PER_UNIT)
  private java.math.BigDecimal cashFlowPerUnit;

  public static final String SERIALIZED_NAME_CURRENCY = "currency";
  @SerializedName(SERIALIZED_NAME_CURRENCY)
  private String currency;

  public RepoCashFlowEvent() {
    // this.instrumentEventType = this.getClass().getSimpleName();
  }

  public RepoCashFlowEvent entitlementDate(OffsetDateTime entitlementDate) {
    
    this.entitlementDate = entitlementDate;
    return this;
  }

   /**
   * The date on which the counterparties become entitled   to exchange cash as part of a partial closure of the   repurchase agreement. The date must be before or on   the settlement date, and on or before the maturity   date of the repo. This is a required field.
   * @return entitlementDate
  **/
  @jakarta.annotation.Nullable
  public OffsetDateTime getEntitlementDate() {
    return entitlementDate;
  }


  public void setEntitlementDate(OffsetDateTime entitlementDate) {
    this.entitlementDate = entitlementDate;
  }


  public RepoCashFlowEvent settlementDate(OffsetDateTime settlementDate) {
    
    this.settlementDate = settlementDate;
    return this;
  }

   /**
   * The date on which the exchange of cash is settled.   The date must be on or after the entitlement date,  and on or before the maturity date of the repo.   This is a required field.
   * @return settlementDate
  **/
  @jakarta.annotation.Nullable
  public OffsetDateTime getSettlementDate() {
    return settlementDate;
  }


  public void setSettlementDate(OffsetDateTime settlementDate) {
    this.settlementDate = settlementDate;
  }


  public RepoCashFlowEvent cashFlowPerUnit(java.math.BigDecimal cashFlowPerUnit) {
    
    this.cashFlowPerUnit = cashFlowPerUnit;
    return this;
  }

   /**
   * The amount of cash to be exchanged for each unit   of the instrument held on the entitlement date.
   * @return cashFlowPerUnit
  **/
  @jakarta.annotation.Nonnull
  public java.math.BigDecimal getCashFlowPerUnit() {
    return cashFlowPerUnit;
  }


  public void setCashFlowPerUnit(java.math.BigDecimal cashFlowPerUnit) {
    this.cashFlowPerUnit = cashFlowPerUnit;
  }


  public RepoCashFlowEvent currency(String currency) {
    
    this.currency = currency;
    return this;
  }

   /**
   * The currency in which the cashflow is paid.
   * @return currency
  **/
  @jakarta.annotation.Nonnull
  public String getCurrency() {
    return currency;
  }


  public void setCurrency(String currency) {
    this.currency = currency;
  }



  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    RepoCashFlowEvent repoCashFlowEvent = (RepoCashFlowEvent) o;
    return Objects.equals(this.entitlementDate, repoCashFlowEvent.entitlementDate) &&
        Objects.equals(this.settlementDate, repoCashFlowEvent.settlementDate) &&
        (this.cashFlowPerUnit.compareTo(repoCashFlowEvent.getCashFlowPerUnit()) == 0) &&
        Objects.equals(this.currency, repoCashFlowEvent.currency) &&
        super.equals(o);
  }

  @Override
  public int hashCode() {
    return Objects.hash(entitlementDate, settlementDate, cashFlowPerUnit, currency, super.hashCode());
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class RepoCashFlowEvent {\n");
    sb.append("    ").append(toIndentedString(super.toString())).append("\n");
    sb.append("    entitlementDate: ").append(toIndentedString(entitlementDate)).append("\n");
    sb.append("    settlementDate: ").append(toIndentedString(settlementDate)).append("\n");
    sb.append("    cashFlowPerUnit: ").append(toIndentedString(cashFlowPerUnit)).append("\n");
    sb.append("    currency: ").append(toIndentedString(currency)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }


  public static HashSet<String> openapiFields;
  public static HashSet<String> openapiRequiredFields;

  static {
    // a set of all properties/fields (JSON key names)
    openapiFields = new HashSet<String>();
    openapiFields.add("instrumentEventType");
    openapiFields.add("entitlementDate");
    openapiFields.add("settlementDate");
    openapiFields.add("cashFlowPerUnit");
    openapiFields.add("currency");

    // a set of required properties/fields (JSON key names)
    openapiRequiredFields = new HashSet<String>();
    openapiRequiredFields.add("cashFlowPerUnit");
    openapiRequiredFields.add("currency");
    openapiRequiredFields.add("instrumentEventType");
  }

 /**
  * Validates the JSON Element and throws an exception if issues found
  *
  * @param jsonElement JSON Element
  * @throws IOException if the JSON Element is invalid with respect to RepoCashFlowEvent
  */
  public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      if (jsonElement == null) {
        if (!RepoCashFlowEvent.openapiRequiredFields.isEmpty()) { // has required fields but JSON element is null
          throw new IllegalArgumentException(String.format("The required field(s) %s in RepoCashFlowEvent is not found in the empty JSON string", RepoCashFlowEvent.openapiRequiredFields.toString()));
        }
      }

      // check to make sure all required properties/fields are present in the JSON string
      for (String requiredField : RepoCashFlowEvent.openapiRequiredFields) {
        if (jsonElement.getAsJsonObject().get(requiredField) == null) {
          throw new IllegalArgumentException(String.format("The required field `%s` is not found in the JSON string: %s", requiredField, jsonElement.toString()));
        }
      }
  }

  public static class CustomTypeAdapterFactory implements TypeAdapterFactory {
    @SuppressWarnings("unchecked")
    @Override
    public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {
       if (!RepoCashFlowEvent.class.isAssignableFrom(type.getRawType())) {
         return null; // this class only serializes 'RepoCashFlowEvent' and its subtypes
       }
       final TypeAdapter<JsonElement> elementAdapter = gson.getAdapter(JsonElement.class);
       final TypeAdapter<RepoCashFlowEvent> thisAdapter
                        = gson.getDelegateAdapter(this, TypeToken.get(RepoCashFlowEvent.class));

       return (TypeAdapter<T>) new TypeAdapter<RepoCashFlowEvent>() {
           @Override
           public void write(JsonWriter out, RepoCashFlowEvent value) throws IOException {
             JsonObject obj = thisAdapter.toJsonTree(value).getAsJsonObject();
             elementAdapter.write(out, obj);
           }

           @Override
           public RepoCashFlowEvent read(JsonReader in) throws IOException {
             JsonElement jsonElement = elementAdapter.read(in);
             validateJsonElement(jsonElement);
             return thisAdapter.fromJsonTree(jsonElement);
           }

       }.nullSafe();
    }
  }

 /**
  * Create an instance of RepoCashFlowEvent given an JSON string
  *
  * @param jsonString JSON string
  * @return An instance of RepoCashFlowEvent
  * @throws IOException if the JSON string is invalid with respect to RepoCashFlowEvent
  */
  public static RepoCashFlowEvent fromJson(String jsonString) throws IOException {
    return JSON.getGson().fromJson(jsonString, RepoCashFlowEvent.class);
  }

 /**
  * Convert an instance of RepoCashFlowEvent to an JSON string
  *
  * @return JSON string
  */
  public String toJson() {
    return JSON.getGson().toJson(this);
  }
}
